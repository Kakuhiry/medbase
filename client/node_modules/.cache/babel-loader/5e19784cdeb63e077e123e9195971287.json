{"ast":null,"code":"if (typeof require === \"function\") {\n  var parsexp = require(\"./parsexp\");\n\n  parsexp.lexer = require(\"./reglex\");\n} else parsexp.lexer = reglex;\n\nvar yy = parsexp.yy;\nvar parse = parsexp.parse.bind(parsexp);\nif (typeof module === \"object\") module.exports = parse;\n\nyy.atom = function (symbol) {\n  var start = {};\n  var final = {};\n  start[symbol] = [final];\n  return {\n    start: start,\n    final: final\n  };\n};\n\nyy.group = function (atom) {\n  var start = {};\n  var final = {};\n  var moves = start[\"\"] = [atom.start, final];\n  addMoves(atom.final, \"\", moves.slice());\n  return {\n    start: start,\n    final: final\n  };\n};\n\nyy.sequence = function (sequence, group) {\n  var start = sequence.start;\n  var final = group.final;\n  var begin = group.start;\n  var end = sequence.final;\n  addMoves(begin, \"\", [end]);\n  addMoves(end, \"\", [begin]);\n  return {\n    start: start,\n    final: final\n  };\n};\n\nyy.expression = function (expression, sequence) {\n  var start = {};\n  var final = {};\n  start[\"\"] = [expression.start, sequence.start];\n  addMoves(expression.final, \"\", [final]);\n  addMoves(sequence.final, \"\", [final]);\n  return {\n    start: start,\n    final: final\n  };\n};\n\nfunction addMoves(state, symbol, moves) {\n  var oldMoves = state[symbol];\n  state[symbol] = oldMoves ? oldMoves.concat(moves) : moves;\n}","map":{"version":3,"sources":["/home/elvis/Documents/GitHub/medbase/mern-auth/node_modules/regex/lib/parse.js"],"names":["require","parsexp","lexer","reglex","yy","parse","bind","module","exports","atom","symbol","start","final","group","moves","addMoves","slice","sequence","begin","end","expression","state","oldMoves","concat"],"mappings":"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","sourcesContent":["if (typeof require === \"function\") {\n    var parsexp = require(\"./parsexp\");\n    parsexp.lexer = require(\"./reglex\");\n} else parsexp.lexer = reglex;\n\nvar yy = parsexp.yy;\nvar parse = parsexp.parse.bind(parsexp);\nif (typeof module === \"object\") module.exports = parse;\n\nyy.atom = function (symbol) {\n    var start = {};\n    var final = {};\n\n    start[symbol] = [final];\n\n    return {\n        start: start,\n        final: final\n    };\n};\n\nyy.group = function (atom) {\n    var start = {};\n    var final = {};\n\n    var moves = start[\"\"] = [atom.start, final];\n    addMoves(atom.final, \"\", moves.slice());\n\n    return {\n        start: start,\n        final: final\n    };\n};\n\nyy.sequence = function (sequence, group) {\n    var start = sequence.start;\n    var final = group.final;\n\n    var begin = group.start; \n    var end = sequence.final;\n    addMoves(begin, \"\", [end]);\n    addMoves(end, \"\", [begin]);\n\n    return {\n        start: start,\n        final: final\n    };\n};\n\nyy.expression = function (expression, sequence) {\n    var start = {};\n    var final = {};\n\n    start[\"\"] = [expression.start, sequence.start];\n    addMoves(expression.final, \"\", [final]);\n    addMoves(sequence.final, \"\", [final]);\n\n    return {\n        start: start,\n        final: final\n    };\n};\n\nfunction addMoves(state, symbol, moves) {\n    var oldMoves = state[symbol];\n    state[symbol] = oldMoves ? oldMoves.concat(moves) : moves;\n}\n"]},"metadata":{},"sourceType":"script"}