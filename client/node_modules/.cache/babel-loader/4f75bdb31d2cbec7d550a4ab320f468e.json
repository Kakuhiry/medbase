{"ast":null,"code":"// Jison, an LR(0), SLR(1), LARL(1), LR(1) Parser Generator\n// Zachary Carter <zach@carter.name>\n// MIT X Licensed\nvar typal = require('./util/typal').typal;\n\nvar Set = require('./util/set').Set;\n\nvar Lexer = require('jison-lex');\n\nvar ebnfParser = require('ebnf-parser');\n\nvar JSONSelect = require('JSONSelect');\n\nvar esprima = require('esprima');\n\nvar escodegen = require('escodegen');\n\nvar version = require('../package.json').version;\n\nvar Jison = exports.Jison = exports;\nJison.version = version; // detect print\n\nif (typeof console !== 'undefined' && console.log) {\n  Jison.print = console.log;\n} else if (typeof puts !== 'undefined') {\n  Jison.print = function print() {\n    puts([].join.call(arguments, ' '));\n  };\n} else if (typeof print !== 'undefined') {\n  Jison.print = print;\n} else {\n  Jison.print = function print() {};\n}\n\nJison.Parser = function () {\n  // iterator utility\n  function each(obj, func) {\n    if (obj.forEach) {\n      obj.forEach(func);\n    } else {\n      var p;\n\n      for (p in obj) {\n        if (obj.hasOwnProperty(p)) {\n          func.call(obj, obj[p], p, obj);\n        }\n      }\n    }\n  }\n\n  var Nonterminal = typal.construct({\n    constructor: function Nonterminal(symbol) {\n      this.symbol = symbol;\n      this.productions = new Set();\n      this.first = [];\n      this.follows = [];\n      this.nullable = false;\n    },\n    toString: function Nonterminal_toString() {\n      var str = this.symbol + \"\\n\";\n      str += this.nullable ? 'nullable' : 'not nullable';\n      str += \"\\nFirsts: \" + this.first.join(', ');\n      str += \"\\nFollows: \" + this.first.join(', ');\n      str += \"\\nProductions:\\n  \" + this.productions.join('\\n  ');\n      return str;\n    }\n  });\n  var Production = typal.construct({\n    constructor: function Production(symbol, handle, id) {\n      this.symbol = symbol;\n      this.handle = handle;\n      this.nullable = false;\n      this.id = id;\n      this.first = [];\n      this.precedence = 0;\n    },\n    toString: function Production_toString() {\n      return this.symbol + \" -> \" + this.handle.join(' ');\n    }\n  });\n  var generator = typal.beget();\n\n  generator.constructor = function Jison_Generator(grammar, opt) {\n    if (typeof grammar === 'string') {\n      grammar = ebnfParser.parse(grammar);\n    }\n\n    var options = typal.mix.call({}, grammar.options, opt);\n    this.terms = {};\n    this.operators = {};\n    this.productions = [];\n    this.conflicts = 0;\n    this.resolutions = [];\n    this.options = options;\n    this.yy = {}; // accessed as yy free variable in the parser/lexer actions\n    // source included in semantic action execution scope\n\n    if (grammar.actionInclude) {\n      if (typeof grammar.actionInclude === 'function') {\n        grammar.actionInclude = String(grammar.actionInclude).replace(/^\\s*function \\(\\) \\{/, '').replace(/\\}\\s*$/, '');\n      }\n\n      this.actionInclude = grammar.actionInclude;\n    }\n\n    this.moduleInclude = grammar.moduleInclude || '';\n    this.DEBUG = options.debug || false;\n    if (this.DEBUG) this.mix(generatorDebug); // mixin debug methods\n\n    this.processGrammar(grammar);\n\n    if (grammar.lex) {\n      this.lexer = new Lexer(grammar.lex, null, this.terminals_);\n    }\n  };\n\n  generator.processGrammar = function processGrammarDef(grammar) {\n    var bnf = grammar.bnf,\n        tokens = grammar.tokens,\n        nonterminals = this.nonterminals = {},\n        productions = this.productions,\n        self = this;\n\n    if (!grammar.bnf && grammar.ebnf) {\n      bnf = grammar.bnf = ebnfParser.transform(grammar.ebnf);\n    }\n\n    if (tokens) {\n      if (typeof tokens === 'string') {\n        tokens = tokens.trim().split(' ');\n      } else {\n        tokens = tokens.slice(0);\n      }\n    }\n\n    var symbols = this.symbols = []; // calculate precedence of operators\n\n    var operators = this.operators = processOperators(grammar.operators); // build productions from cfg\n\n    this.buildProductions(grammar.bnf, productions, nonterminals, symbols, operators);\n\n    if (tokens && this.terminals.length !== tokens.length) {\n      self.trace(\"Warning: declared tokens differ from tokens found in rules.\");\n      self.trace(this.terminals);\n      self.trace(tokens);\n    } // augment the grammar\n\n\n    this.augmentGrammar(grammar);\n  };\n\n  generator.augmentGrammar = function augmentGrammar(grammar) {\n    // use specified start symbol, or default to first user defined production\n    this.startSymbol = grammar.start || grammar.startSymbol || this.productions[0].symbol;\n\n    if (!this.nonterminals[this.startSymbol]) {\n      throw new Error(\"Grammar error: startSymbol must be a non-terminal found in your grammar.\");\n    }\n\n    this.EOF = \"$end\"; // augment the grammar\n\n    var acceptProduction = new Production('$accept', [this.startSymbol, '$end'], 0);\n    this.productions.unshift(acceptProduction); // prepend parser tokens\n\n    this.symbols.unshift(\"$accept\", this.EOF);\n    this.symbols_.$accept = 0;\n    this.symbols_[this.EOF] = 1;\n    this.terminals.unshift(this.EOF);\n    this.nonterminals.$accept = new Nonterminal(\"$accept\");\n    this.nonterminals.$accept.productions.push(acceptProduction); // add follow $ to start symbol\n\n    this.nonterminals[this.startSymbol].follows.push(this.EOF);\n  }; // set precedence and associativity of operators\n\n\n  function processOperators(ops) {\n    if (!ops) return {};\n    var operators = {};\n\n    for (var i = 0, k, prec; prec = ops[i]; i++) {\n      for (k = 1; k < prec.length; k++) {\n        operators[prec[k]] = {\n          precedence: i + 1,\n          assoc: prec[0]\n        };\n      }\n    }\n\n    return operators;\n  }\n\n  generator.buildProductions = function buildProductions(bnf, productions, nonterminals, symbols, operators) {\n    var actions = ['/* this == yyval */', this.actionInclude || '', 'var $0 = $$.length - 1;', 'switch (yystate) {'];\n    var prods, symbol;\n    var productions_ = [0];\n    var symbolId = 1;\n    var symbols_ = {};\n    var her = false; // has error recovery\n\n    function addSymbol(s) {\n      if (s && !symbols_[s]) {\n        symbols_[s] = ++symbolId;\n        symbols.push(s);\n      }\n    } // add error symbol; will be third symbol, or \"2\" ($accept, $end, error)\n\n\n    addSymbol(\"error\");\n\n    for (symbol in bnf) {\n      if (!bnf.hasOwnProperty(symbol)) continue;\n      addSymbol(symbol);\n      nonterminals[symbol] = new Nonterminal(symbol);\n\n      if (typeof bnf[symbol] === 'string') {\n        prods = bnf[symbol].split(/\\s*\\|\\s*/g);\n      } else {\n        prods = bnf[symbol].slice(0);\n      }\n\n      prods.forEach(buildProduction);\n    }\n\n    var sym,\n        terms = [],\n        terms_ = {};\n    each(symbols_, function (id, sym) {\n      if (!nonterminals[sym]) {\n        terms.push(sym);\n        terms_[id] = sym;\n      }\n    });\n    this.hasErrorRecovery = her;\n    this.terminals = terms;\n    this.terminals_ = terms_;\n    this.symbols_ = symbols_;\n    this.productions_ = productions_;\n    actions.push('}'); // first try to create the performAction function the old way,\n    // but this will break for some legal constructs in the user action code:\n\n    try {\n      this.performAction = Function(\"yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */\", actions.join(\"\\n\"));\n    } catch (e) {\n      this.performAction = \"function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\\n\" + actions.join(\"\\n\") + \"\\n}\";\n    }\n\n    function buildProduction(handle) {\n      var r, rhs, i;\n\n      if (handle.constructor === Array) {\n        rhs = typeof handle[0] === 'string' ? handle[0].trim().split(' ') : handle[0].slice(0);\n\n        for (i = 0; i < rhs.length; i++) {\n          if (rhs[i] === 'error') her = true;\n\n          if (!symbols_[rhs[i]]) {\n            addSymbol(rhs[i]);\n          }\n        }\n\n        if (typeof handle[1] === 'string' || handle.length == 3) {\n          // semantic action specified\n          var action = 'case ' + (productions.length + 1) + ':' + handle[1] + '\\nbreak;'; // replace named semantic values ($nonterminal)\n\n          if (action.match(/[$@][a-zA-Z][a-zA-Z0-9_]*/)) {\n            var count = {},\n                names = {};\n\n            for (i = 0; i < rhs.length; i++) {\n              if (names[rhs[i]]) {\n                names[rhs[i] + ++count[rhs[i]]] = i + 1;\n              } else {\n                names[rhs[i]] = i + 1;\n                names[rhs[i] + \"1\"] = i + 1;\n                count[rhs[i]] = 1;\n              }\n            }\n\n            action = action.replace(/\\$([a-zA-Z][a-zA-Z0-9_]*)/g, function (str, pl) {\n              return names[pl] ? '$' + names[pl] : pl;\n            }).replace(/@([a-zA-Z][a-zA-Z0-9_]*)/g, function (str, pl) {\n              return names[pl] ? '@' + names[pl] : pl;\n            });\n          }\n\n          action = action.replace(/([^'\"])\\$\\$|^\\$\\$/g, '$1this.$').replace(/@[0$]/g, \"this._$\").replace(/\\$(\\d+)/g, function (_, n) {\n            return \"$$[$0\" + (n - rhs.length || '') + \"]\";\n          }).replace(/@(\\d+)/g, function (_, n) {\n            return \"_$[$0\" + (n - rhs.length || '') + \"]\";\n          });\n          actions.push(action);\n          r = new Production(symbol, rhs, productions.length + 1); // precedence specified also\n\n          if (handle[2] && operators[handle[2].prec]) {\n            r.precedence = operators[handle[2].prec].precedence;\n          }\n        } else {\n          // only precedence specified\n          r = new Production(symbol, rhs, productions.length + 1);\n\n          if (operators[handle[1].prec]) {\n            r.precedence = operators[handle[1].prec].precedence;\n          }\n        }\n      } else {\n        rhs = handle.trim().split(' ');\n\n        for (i = 0; i < rhs.length; i++) {\n          if (rhs[i] === 'error') her = true;\n\n          if (!symbols_[rhs[i]]) {\n            addSymbol(rhs[i]);\n          }\n        }\n\n        r = new Production(symbol, rhs, productions.length + 1);\n      }\n\n      if (r.precedence === 0) {\n        // set precedence\n        for (i = r.handle.length - 1; i >= 0; i--) {\n          if (!(r.handle[i] in nonterminals) && r.handle[i] in operators) {\n            r.precedence = operators[r.handle[i]].precedence;\n          }\n        }\n      }\n\n      productions.push(r);\n      productions_.push([symbols_[r.symbol], r.handle[0] === '' ? 0 : r.handle.length]);\n      nonterminals[symbol].productions.push(r);\n    }\n  };\n\n  generator.createParser = function createParser() {\n    throw new Error('Calling abstract method.');\n  }; // noop. implemented in debug mixin\n\n\n  generator.trace = function trace() {};\n\n  generator.warn = function warn() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    Jison.print.call(null, args.join(\"\"));\n  };\n\n  generator.error = function error(msg) {\n    throw new Error(msg);\n  }; // Generator debug mixin\n\n\n  var generatorDebug = {\n    trace: function trace() {\n      Jison.print.apply(null, arguments);\n    },\n    beforeprocessGrammar: function () {\n      this.trace(\"Processing grammar.\");\n    },\n    afteraugmentGrammar: function () {\n      var trace = this.trace;\n      each(this.symbols, function (sym, i) {\n        trace(sym + \"(\" + i + \")\");\n      });\n    }\n  };\n  /*\n   * Mixin for common behaviors of lookahead parsers\n   * */\n\n  var lookaheadMixin = {};\n\n  lookaheadMixin.computeLookaheads = function computeLookaheads() {\n    if (this.DEBUG) this.mix(lookaheadDebug); // mixin debug methods\n\n    this.computeLookaheads = function () {};\n\n    this.nullableSets();\n    this.firstSets();\n    this.followSets();\n  }; // calculate follow sets typald on first and nullable\n\n\n  lookaheadMixin.followSets = function followSets() {\n    var productions = this.productions,\n        nonterminals = this.nonterminals,\n        self = this,\n        cont = true; // loop until no further changes have been made\n\n    while (cont) {\n      cont = false;\n      productions.forEach(function Follow_prod_forEach(production, k) {\n        //self.trace(production.symbol,nonterminals[production.symbol].follows);\n        // q is used in Simple LALR algorithm determine follows in context\n        var q;\n        var ctx = !!self.go_;\n        var set = [],\n            oldcount;\n\n        for (var i = 0, t; t = production.handle[i]; ++i) {\n          if (!nonterminals[t]) continue; // for Simple LALR algorithm, self.go_ checks if\n\n          if (ctx) q = self.go_(production.symbol, production.handle.slice(0, i));\n          var bool = !ctx || q === parseInt(self.nterms_[t], 10);\n\n          if (i === production.handle.length + 1 && bool) {\n            set = nonterminals[production.symbol].follows;\n          } else {\n            var part = production.handle.slice(i + 1);\n            set = self.first(part);\n\n            if (self.nullable(part) && bool) {\n              set.push.apply(set, nonterminals[production.symbol].follows);\n            }\n          }\n\n          oldcount = nonterminals[t].follows.length;\n          Set.union(nonterminals[t].follows, set);\n\n          if (oldcount !== nonterminals[t].follows.length) {\n            cont = true;\n          }\n        }\n      });\n    }\n  }; // return the FIRST set of a symbol or series of symbols\n\n\n  lookaheadMixin.first = function first(symbol) {\n    // epsilon\n    if (symbol === '') {\n      return []; // RHS\n    } else if (symbol instanceof Array) {\n      var firsts = [];\n\n      for (var i = 0, t; t = symbol[i]; ++i) {\n        if (!this.nonterminals[t]) {\n          if (firsts.indexOf(t) === -1) firsts.push(t);\n        } else {\n          Set.union(firsts, this.nonterminals[t].first);\n        }\n\n        if (!this.nullable(t)) break;\n      }\n\n      return firsts; // terminal\n    } else if (!this.nonterminals[symbol]) {\n      return [symbol]; // nonterminal\n    } else {\n      return this.nonterminals[symbol].first;\n    }\n  }; // fixed-point calculation of FIRST sets\n\n\n  lookaheadMixin.firstSets = function firstSets() {\n    var productions = this.productions,\n        nonterminals = this.nonterminals,\n        self = this,\n        cont = true,\n        symbol,\n        firsts; // loop until no further changes have been made\n\n    while (cont) {\n      cont = false;\n      productions.forEach(function FirstSets_forEach(production, k) {\n        var firsts = self.first(production.handle);\n\n        if (firsts.length !== production.first.length) {\n          production.first = firsts;\n          cont = true;\n        }\n      });\n\n      for (symbol in nonterminals) {\n        firsts = [];\n        nonterminals[symbol].productions.forEach(function (production) {\n          Set.union(firsts, production.first);\n        });\n\n        if (firsts.length !== nonterminals[symbol].first.length) {\n          nonterminals[symbol].first = firsts;\n          cont = true;\n        }\n      }\n    }\n  }; // fixed-point calculation of NULLABLE\n\n\n  lookaheadMixin.nullableSets = function nullableSets() {\n    var firsts = this.firsts = {},\n        nonterminals = this.nonterminals,\n        self = this,\n        cont = true; // loop until no further changes have been made\n\n    while (cont) {\n      cont = false; // check if each production is nullable\n\n      this.productions.forEach(function (production, k) {\n        if (!production.nullable) {\n          for (var i = 0, n = 0, t; t = production.handle[i]; ++i) {\n            if (self.nullable(t)) n++;\n          }\n\n          if (n === i) {\n            // production is nullable if all tokens are nullable\n            production.nullable = cont = true;\n          }\n        }\n      }); //check if each symbol is nullable\n\n      for (var symbol in nonterminals) {\n        if (!this.nullable(symbol)) {\n          for (var i = 0, production; production = nonterminals[symbol].productions.item(i); i++) {\n            if (production.nullable) nonterminals[symbol].nullable = cont = true;\n          }\n        }\n      }\n    }\n  }; // check if a token or series of tokens is nullable\n\n\n  lookaheadMixin.nullable = function nullable(symbol) {\n    // epsilon\n    if (symbol === '') {\n      return true; // RHS\n    } else if (symbol instanceof Array) {\n      for (var i = 0, t; t = symbol[i]; ++i) {\n        if (!this.nullable(t)) return false;\n      }\n\n      return true; // terminal\n    } else if (!this.nonterminals[symbol]) {\n      return false; // nonterminal\n    } else {\n      return this.nonterminals[symbol].nullable;\n    }\n  }; // lookahead debug mixin\n\n\n  var lookaheadDebug = {\n    beforenullableSets: function () {\n      this.trace(\"Computing Nullable sets.\");\n    },\n    beforefirstSets: function () {\n      this.trace(\"Computing First sets.\");\n    },\n    beforefollowSets: function () {\n      this.trace(\"Computing Follow sets.\");\n    },\n    afterfollowSets: function () {\n      var trace = this.trace;\n      each(this.nonterminals, function (nt, t) {\n        trace(nt, '\\n');\n      });\n    }\n  };\n  /*\n   * Mixin for common LR parser behavior\n   * */\n\n  var lrGeneratorMixin = {};\n\n  lrGeneratorMixin.buildTable = function buildTable() {\n    if (this.DEBUG) this.mix(lrGeneratorDebug); // mixin debug methods\n\n    this.states = this.canonicalCollection();\n    this.table = this.parseTable(this.states);\n    this.defaultActions = findDefaults(this.table);\n  };\n\n  lrGeneratorMixin.Item = typal.construct({\n    constructor: function Item(production, dot, f, predecessor) {\n      this.production = production;\n      this.dotPosition = dot || 0;\n      this.follows = f || [];\n      this.predecessor = predecessor;\n      this.id = parseInt(production.id + 'a' + this.dotPosition, 36);\n      this.markedSymbol = this.production.handle[this.dotPosition];\n    },\n    remainingHandle: function () {\n      return this.production.handle.slice(this.dotPosition + 1);\n    },\n    eq: function (e) {\n      return e.id === this.id;\n    },\n    handleToString: function () {\n      var handle = this.production.handle.slice(0);\n      handle[this.dotPosition] = '.' + (handle[this.dotPosition] || '');\n      return handle.join(' ');\n    },\n    toString: function () {\n      var temp = this.production.handle.slice(0);\n      temp[this.dotPosition] = '.' + (temp[this.dotPosition] || '');\n      return this.production.symbol + \" -> \" + temp.join(' ') + (this.follows.length === 0 ? \"\" : \" #lookaheads= \" + this.follows.join(' '));\n    }\n  });\n  lrGeneratorMixin.ItemSet = Set.prototype.construct({\n    afterconstructor: function () {\n      this.reductions = [];\n      this.goes = {};\n      this.edges = {};\n      this.shifts = false;\n      this.inadequate = false;\n      this.hash_ = {};\n\n      for (var i = this._items.length - 1; i >= 0; i--) {\n        this.hash_[this._items[i].id] = true; //i;\n      }\n    },\n    concat: function concat(set) {\n      var a = set._items || set;\n\n      for (var i = a.length - 1; i >= 0; i--) {\n        this.hash_[a[i].id] = true; //i;\n      }\n\n      this._items.push.apply(this._items, a);\n\n      return this;\n    },\n    push: function (item) {\n      this.hash_[item.id] = true;\n      return this._items.push(item);\n    },\n    contains: function (item) {\n      return this.hash_[item.id];\n    },\n    valueOf: function toValue() {\n      var v = this._items.map(function (a) {\n        return a.id;\n      }).sort().join('|');\n\n      this.valueOf = function toValue_inner() {\n        return v;\n      };\n\n      return v;\n    }\n  });\n\n  lrGeneratorMixin.closureOperation = function closureOperation(itemSet\n  /*, closureSet*/\n  ) {\n    var closureSet = new this.ItemSet();\n    var self = this;\n    var set = itemSet,\n        itemQueue,\n        syms = {};\n\n    do {\n      itemQueue = new Set();\n      closureSet.concat(set);\n      set.forEach(function CO_set_forEach(item) {\n        var symbol = item.markedSymbol; // if token is a non-terminal, recursively add closures\n\n        if (symbol && self.nonterminals[symbol]) {\n          if (!syms[symbol]) {\n            self.nonterminals[symbol].productions.forEach(function CO_nt_forEach(production) {\n              var newItem = new self.Item(production, 0);\n              if (!closureSet.contains(newItem)) itemQueue.push(newItem);\n            });\n            syms[symbol] = true;\n          }\n        } else if (!symbol) {\n          // reduction\n          closureSet.reductions.push(item);\n          closureSet.inadequate = closureSet.reductions.length > 1 || closureSet.shifts;\n        } else {\n          // shift\n          closureSet.shifts = true;\n          closureSet.inadequate = closureSet.reductions.length > 0;\n        }\n      });\n      set = itemQueue;\n    } while (!itemQueue.isEmpty());\n\n    return closureSet;\n  };\n\n  lrGeneratorMixin.gotoOperation = function gotoOperation(itemSet, symbol) {\n    var gotoSet = new this.ItemSet(),\n        self = this;\n    itemSet.forEach(function goto_forEach(item, n) {\n      if (item.markedSymbol === symbol) {\n        gotoSet.push(new self.Item(item.production, item.dotPosition + 1, item.follows, n));\n      }\n    });\n    return gotoSet.isEmpty() ? gotoSet : this.closureOperation(gotoSet);\n  };\n  /* Create unique set of item sets\n   * */\n\n\n  lrGeneratorMixin.canonicalCollection = function canonicalCollection() {\n    var item1 = new this.Item(this.productions[0], 0, [this.EOF]);\n    var firstState = this.closureOperation(new this.ItemSet(item1)),\n        states = new Set(firstState),\n        marked = 0,\n        self = this,\n        itemSet;\n    states.has = {};\n    states.has[firstState] = 0;\n\n    while (marked !== states.size()) {\n      itemSet = states.item(marked);\n      marked++;\n      itemSet.forEach(function CC_itemSet_forEach(item) {\n        if (item.markedSymbol && item.markedSymbol !== self.EOF) self.canonicalCollectionInsert(item.markedSymbol, itemSet, states, marked - 1);\n      });\n    }\n\n    return states;\n  }; // Pushes a unique state into the que. Some parsing algorithms may perform additional operations\n\n\n  lrGeneratorMixin.canonicalCollectionInsert = function canonicalCollectionInsert(symbol, itemSet, states, stateNum) {\n    var g = this.gotoOperation(itemSet, symbol);\n    if (!g.predecessors) g.predecessors = {}; // add g to que if not empty or duplicate\n\n    if (!g.isEmpty()) {\n      var gv = g.valueOf(),\n          i = states.has[gv];\n\n      if (i === -1 || typeof i === 'undefined') {\n        states.has[gv] = states.size();\n        itemSet.edges[symbol] = states.size(); // store goto transition for table\n\n        states.push(g);\n        g.predecessors[symbol] = [stateNum];\n      } else {\n        itemSet.edges[symbol] = i; // store goto transition for table\n\n        states.item(i).predecessors[symbol].push(stateNum);\n      }\n    }\n  };\n\n  var NONASSOC = 0;\n\n  lrGeneratorMixin.parseTable = function parseTable(itemSets) {\n    var states = [],\n        nonterminals = this.nonterminals,\n        operators = this.operators,\n        conflictedStates = {},\n        // array of [state, token] tuples\n    self = this,\n        s = 1,\n        // shift\n    r = 2,\n        // reduce\n    a = 3; // accept\n    // for each item set\n\n    itemSets.forEach(function (itemSet, k) {\n      var state = states[k] = {};\n      var action, stackSymbol; // set shift and goto actions\n\n      for (stackSymbol in itemSet.edges) {\n        itemSet.forEach(function (item, j) {\n          // find shift and goto actions\n          if (item.markedSymbol == stackSymbol) {\n            var gotoState = itemSet.edges[stackSymbol];\n\n            if (nonterminals[stackSymbol]) {\n              // store state to go to after a reduce\n              //self.trace(k, stackSymbol, 'g'+gotoState);\n              state[self.symbols_[stackSymbol]] = gotoState;\n            } else {\n              //self.trace(k, stackSymbol, 's'+gotoState);\n              state[self.symbols_[stackSymbol]] = [s, gotoState];\n            }\n          }\n        });\n      } // set accept action\n\n\n      itemSet.forEach(function (item, j) {\n        if (item.markedSymbol == self.EOF) {\n          // accept\n          state[self.symbols_[self.EOF]] = [a]; //self.trace(k, self.EOF, state[self.EOF]);\n        }\n      });\n      var allterms = self.lookAheads ? false : self.terminals; // set reductions and resolve potential conflicts\n\n      itemSet.reductions.forEach(function (item, j) {\n        // if parser uses lookahead, only enumerate those terminals\n        var terminals = allterms || self.lookAheads(itemSet, item);\n        terminals.forEach(function (stackSymbol) {\n          action = state[self.symbols_[stackSymbol]];\n          var op = operators[stackSymbol]; // Reading a terminal and current position is at the end of a production, try to reduce\n\n          if (action || action && action.length) {\n            var sol = resolveConflict(item.production, op, [r, item.production.id], action[0] instanceof Array ? action[0] : action);\n            self.resolutions.push([k, stackSymbol, sol]);\n\n            if (sol.bydefault) {\n              self.conflicts++;\n\n              if (!self.DEBUG) {\n                self.warn('Conflict in grammar: multiple actions possible when lookahead token is ', stackSymbol, ' in state ', k, \"\\n- \", printAction(sol.r, self), \"\\n- \", printAction(sol.s, self));\n                conflictedStates[k] = true;\n              }\n\n              if (self.options.noDefaultResolve) {\n                if (!(action[0] instanceof Array)) action = [action];\n                action.push(sol.r);\n              }\n            } else {\n              action = sol.action;\n            }\n          } else {\n            action = [r, item.production.id];\n          }\n\n          if (action && action.length) {\n            state[self.symbols_[stackSymbol]] = action;\n          } else if (action === NONASSOC) {\n            state[self.symbols_[stackSymbol]] = undefined;\n          }\n        });\n      });\n    });\n\n    if (!self.DEBUG && self.conflicts > 0) {\n      self.warn(\"\\nStates with conflicts:\");\n      each(conflictedStates, function (val, state) {\n        self.warn('State ' + state);\n        self.warn('  ', itemSets.item(state).join(\"\\n  \"));\n      });\n    }\n\n    return states;\n  }; // find states with only one action, a reduction\n\n\n  function findDefaults(states) {\n    var defaults = {};\n    states.forEach(function (state, k) {\n      var i = 0;\n\n      for (var act in state) {\n        if ({}.hasOwnProperty.call(state, act)) i++;\n      }\n\n      if (i === 1 && state[act][0] === 2) {\n        // only one action in state and it's a reduction\n        defaults[k] = state[act];\n      }\n    });\n    return defaults;\n  } // resolves shift-reduce and reduce-reduce conflicts\n\n\n  function resolveConflict(production, op, reduce, shift) {\n    var sln = {\n      production: production,\n      operator: op,\n      r: reduce,\n      s: shift\n    },\n        s = 1,\n        // shift\n    r = 2,\n        // reduce\n    a = 3; // accept\n\n    if (shift[0] === r) {\n      sln.msg = \"Resolve R/R conflict (use first production declared in grammar.)\";\n      sln.action = shift[1] < reduce[1] ? shift : reduce;\n      if (shift[1] !== reduce[1]) sln.bydefault = true;\n      return sln;\n    }\n\n    if (production.precedence === 0 || !op) {\n      sln.msg = \"Resolve S/R conflict (shift by default.)\";\n      sln.bydefault = true;\n      sln.action = shift;\n    } else if (production.precedence < op.precedence) {\n      sln.msg = \"Resolve S/R conflict (shift for higher precedent operator.)\";\n      sln.action = shift;\n    } else if (production.precedence === op.precedence) {\n      if (op.assoc === \"right\") {\n        sln.msg = \"Resolve S/R conflict (shift for right associative operator.)\";\n        sln.action = shift;\n      } else if (op.assoc === \"left\") {\n        sln.msg = \"Resolve S/R conflict (reduce for left associative operator.)\";\n        sln.action = reduce;\n      } else if (op.assoc === \"nonassoc\") {\n        sln.msg = \"Resolve S/R conflict (no action for non-associative operator.)\";\n        sln.action = NONASSOC;\n      }\n    } else {\n      sln.msg = \"Resolve conflict (reduce for higher precedent production.)\";\n      sln.action = reduce;\n    }\n\n    return sln;\n  }\n\n  lrGeneratorMixin.generate = function parser_generate(opt) {\n    opt = typal.mix.call({}, this.options, opt);\n    var code = \"\"; // check for illegal identifier\n\n    if (!opt.moduleName || !opt.moduleName.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/)) {\n      opt.moduleName = \"parser\";\n    }\n\n    switch (opt.moduleType) {\n      case \"js\":\n        code = this.generateModule(opt);\n        break;\n\n      case \"amd\":\n        code = this.generateAMDModule(opt);\n        break;\n\n      default:\n        code = this.generateCommonJSModule(opt);\n        break;\n    }\n\n    return code;\n  };\n\n  lrGeneratorMixin.generateAMDModule = function generateAMDModule(opt) {\n    opt = typal.mix.call({}, this.options, opt);\n    var out = '\\n\\ndefine([], function(){' + '\\nvar parser = ' + this.generateModule_(opt) + (this.lexer && this.lexer.generateModule ? '\\n' + this.lexer.generateModule() + '\\nparser.lexer = lexer;' : '') + '\\nreturn parser;' + '\\n});';\n    return out;\n  };\n\n  lrGeneratorMixin.generateCommonJSModule = function generateCommonJSModule(opt) {\n    opt = typal.mix.call({}, this.options, opt);\n    var moduleName = opt.moduleName || \"parser\";\n    var out = this.generateModule(opt) + \"\\n\\n\\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\" + \"\\nexports.parser = \" + moduleName + \";\" + \"\\nexports.Parser = \" + moduleName + \".Parser;\" + \"\\nexports.parse = function () { return \" + moduleName + \".parse.apply(\" + moduleName + \", arguments); };\" + \"\\nexports.main = \" + String(opt.moduleMain || commonjsMain) + \";\" + \"\\nif (typeof module !== 'undefined' && require.main === module) {\\n\" + \"  exports.main(process.argv.slice(1));\\n}\" + \"\\n}\";\n    return out;\n  };\n\n  lrGeneratorMixin.generateModule = function generateModule(opt) {\n    opt = typal.mix.call({}, this.options, opt);\n    var moduleName = opt.moduleName || \"parser\";\n    var out = \"/* parser generated by jison \" + version + \" */\\n\" + \"/*\\n\" + \"  Returns a Parser object of the following structure:\\n\" + \"\\n\" + \"  Parser: {\\n\" + \"    yy: {}\\n\" + \"  }\\n\" + \"\\n\" + \"  Parser.prototype: {\\n\" + \"    yy: {},\\n\" + \"    trace: function(),\\n\" + \"    symbols_: {associative list: name ==> number},\\n\" + \"    terminals_: {associative list: number ==> name},\\n\" + \"    productions_: [...],\\n\" + \"    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\\n\" + \"    table: [...],\\n\" + \"    defaultActions: {...},\\n\" + \"    parseError: function(str, hash),\\n\" + \"    parse: function(input),\\n\" + \"\\n\" + \"    lexer: {\\n\" + \"        EOF: 1,\\n\" + \"        parseError: function(str, hash),\\n\" + \"        setInput: function(input),\\n\" + \"        input: function(),\\n\" + \"        unput: function(str),\\n\" + \"        more: function(),\\n\" + \"        less: function(n),\\n\" + \"        pastInput: function(),\\n\" + \"        upcomingInput: function(),\\n\" + \"        showPosition: function(),\\n\" + \"        test_match: function(regex_match_array, rule_index),\\n\" + \"        next: function(),\\n\" + \"        lex: function(),\\n\" + \"        begin: function(condition),\\n\" + \"        popState: function(),\\n\" + \"        _currentRules: function(),\\n\" + \"        topState: function(),\\n\" + \"        pushState: function(condition),\\n\" + \"\\n\" + \"        options: {\\n\" + \"            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\\n\" + \"            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\\n\" + \"            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\\n\" + \"        },\\n\" + \"\\n\" + \"        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\\n\" + \"        rules: [...],\\n\" + \"        conditions: {associative list: name ==> set},\\n\" + \"    }\\n\" + \"  }\\n\" + \"\\n\" + \"\\n\" + \"  token location info (@$, _$, etc.): {\\n\" + \"    first_line: n,\\n\" + \"    last_line: n,\\n\" + \"    first_column: n,\\n\" + \"    last_column: n,\\n\" + \"    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\\n\" + \"  }\\n\" + \"\\n\" + \"\\n\" + \"  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\\n\" + \"    text:        (matched text)\\n\" + \"    token:       (the produced terminal token, if any)\\n\" + \"    line:        (yylineno)\\n\" + \"  }\\n\" + \"  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\\n\" + \"    loc:         (yylloc)\\n\" + \"    expected:    (string describing the set of expected tokens)\\n\" + \"    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\\n\" + \"  }\\n\" + \"*/\\n\";\n    out += (moduleName.match(/\\./) ? moduleName : \"var \" + moduleName) + \" = (function(){\";\n    out += \"\\nvar parser = \" + this.generateModule_();\n    out += \"\\n\" + this.moduleInclude;\n\n    if (this.lexer && this.lexer.generateModule) {\n      out += this.lexer.generateModule();\n      out += \"\\nparser.lexer = lexer;\";\n    }\n\n    out += \"\\nfunction Parser () {\\n  this.yy = {};\\n}\\n\" + \"Parser.prototype = parser;\" + \"parser.Parser = Parser;\" + \"\\nreturn new Parser;\\n})();\";\n    return out;\n  }; // returns parse function without error recovery code\n\n\n  function removeErrorRecovery(fn) {\n    var parseFn = String(fn);\n\n    try {\n      var ast = esprima.parse(parseFn);\n      var labeled = JSONSelect.match(':has(:root > .label > .name:val(\"_handle_error\"))', ast);\n      var reduced_code = labeled[0].body.consequent.body[3].consequent.body;\n      reduced_code[0] = labeled[0].body.consequent.body[1]; // remove the line: error_rule_depth = locateNearestErrorRecoveryRule(state);\n\n      reduced_code[4].expression.arguments[1].properties.pop(); // remove the line: 'recoverable: error_rule_depth !== false'\n\n      labeled[0].body.consequent.body = reduced_code;\n      return escodegen.generate(ast).replace(/_handle_error:\\s?/, \"\").replace(/\\\\\\\\n/g, \"\\\\n\");\n    } catch (e) {\n      return parseFn;\n    }\n  }\n\n  lrGeneratorMixin.generateModule_ = function generateModule_() {\n    var parseFn = (this.hasErrorRecovery ? String : removeErrorRecovery)(parser.parse);\n    var out = \"{\";\n    out += [\"trace: \" + String(this.trace || parser.trace), \"yy: {}\", \"symbols_: \" + JSON.stringify(this.symbols_), \"terminals_: \" + JSON.stringify(this.terminals_).replace(/\"([0-9]+)\":/g, \"$1:\"), \"productions_: \" + JSON.stringify(this.productions_), \"performAction: \" + String(this.performAction), \"table: \" + JSON.stringify(this.table).replace(/\"([0-9]+)\":/g, \"$1:\"), \"defaultActions: \" + JSON.stringify(this.defaultActions).replace(/\"([0-9]+)\":/g, \"$1:\"), \"parseError: \" + String(this.parseError || (this.hasErrorRecovery ? traceParseError : parser.parseError)), \"parse: \" + parseFn].join(\",\\n\");\n    out += \"};\";\n    return out;\n  }; // default main method for generated commonjs modules\n\n\n  function commonjsMain(args) {\n    if (!args[1]) {\n      console.log('Usage: ' + args[0] + ' FILE');\n      process.exit(1);\n    }\n\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n\n    return exports.parser.parse(source);\n  } // debug mixin for LR parser generators\n\n\n  function printAction(a, gen) {\n    var s = a[0] == 1 ? 'shift token (then go to state ' + a[1] + ')' : a[0] == 2 ? 'reduce by rule: ' + gen.productions[a[1]] : 'accept';\n    return s;\n  }\n\n  var lrGeneratorDebug = {\n    beforeparseTable: function () {\n      this.trace(\"Building parse table.\");\n    },\n    afterparseTable: function () {\n      var self = this;\n\n      if (this.conflicts > 0) {\n        this.resolutions.forEach(function (r, i) {\n          if (r[2].bydefault) {\n            self.warn('Conflict at state: ', r[0], ', token: ', r[1], \"\\n  \", printAction(r[2].r, self), \"\\n  \", printAction(r[2].s, self));\n          }\n        });\n        this.trace(\"\\n\" + this.conflicts + \" Conflict(s) found in grammar.\");\n      }\n\n      this.trace(\"Done.\");\n    },\n    aftercanonicalCollection: function (states) {\n      var trace = this.trace;\n      trace(\"\\nItem sets\\n------\");\n      states.forEach(function (state, i) {\n        trace(\"\\nitem set\", i, \"\\n\" + state.join(\"\\n\"), '\\ntransitions -> ', JSON.stringify(state.edges));\n      });\n    }\n  };\n  var parser = typal.beget();\n\n  lrGeneratorMixin.createParser = function createParser() {\n    var p = parser.beget();\n    p.yy = {};\n    p.init({\n      table: this.table,\n      defaultActions: this.defaultActions,\n      productions_: this.productions_,\n      symbols_: this.symbols_,\n      terminals_: this.terminals_,\n      performAction: this.performAction\n    }); // don't throw if grammar recovers from errors\n\n    if (this.hasErrorRecovery) {\n      p.parseError = traceParseError;\n      p.recover = true;\n    } // for debugging\n\n\n    p.productions = this.productions; // backwards compatability\n\n    p.generate = this.generate;\n    p.lexer = this.lexer;\n    p.generateModule = this.generateModule;\n    p.generateCommonJSModule = this.generateCommonJSModule;\n    p.generateModule_ = this.generateModule_;\n    var gen = this;\n\n    p.Parser = function () {\n      return gen.createParser();\n    };\n\n    return p;\n  };\n\n  parser.trace = generator.trace;\n  parser.warn = generator.warn;\n  parser.error = generator.error;\n\n  function traceParseError(err, hash) {\n    this.trace(err);\n  }\n\n  function parseError(str, hash) {\n    if (hash.recoverable) {\n      this.trace(str);\n    } else {\n      throw new Error(str);\n    }\n  }\n\n  parser.parseError = lrGeneratorMixin.parseError = parseError;\n\n  parser.parse = function parse(input) {\n    var self = this,\n        stack = [0],\n        vstack = [null],\n        // semantic value stack\n    lstack = [],\n        // location stack\n    table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1; //this.reductionCount = this.shiftCount = 0;\n\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    this.yy.parser = this;\n\n    if (typeof this.lexer.yylloc == 'undefined') {\n      this.lexer.yylloc = {};\n    }\n\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = this.lexer.options && this.lexer.options.ranges;\n\n    if (typeof this.yy.parseError === 'function') {\n      this.parseError = this.yy.parseError;\n    } else {\n      this.parseError = Object.getPrototypeOf(this).parseError; // because in the generated code 'this.__proto__.parseError' doesn't work for everyone: http://javascriptweblog.wordpress.com/2010/06/07/understanding-javascript-prototypes/\n    }\n\n    function popStack(n) {\n      stack.length = stack.length - 2 * n;\n      vstack.length = vstack.length - n;\n      lstack.length = lstack.length - n;\n    }\n\n    function lex() {\n      var token;\n      token = self.lexer.lex() || EOF; // $end = 1\n      // if token isn't its numeric value, convert\n\n      if (typeof token !== 'number') {\n        token = self.symbols_[token] || token;\n      }\n\n      return token;\n    }\n\n    var symbol,\n        preErrorSymbol,\n        state,\n        action,\n        a,\n        r,\n        yyval = {},\n        p,\n        len,\n        newState,\n        expected;\n\n    while (true) {\n      // retreive state number from top of stack\n      state = stack[stack.length - 1]; // use default actions if available\n\n      if (this.defaultActions[state]) {\n        action = this.defaultActions[state];\n      } else {\n        if (symbol === null || typeof symbol == 'undefined') {\n          symbol = lex();\n        } // read action for current state and first input\n\n\n        action = table[state] && table[state][symbol];\n      }\n\n      _handle_error: // handle parse error\n      if (typeof action === 'undefined' || !action.length || !action[0]) {\n        var error_rule_depth;\n        var errStr = ''; // Return the rule stack depth where the nearest error rule can be found.\n        // Return FALSE when no error recovery rule was found.\n\n        function locateNearestErrorRecoveryRule(state) {\n          var stack_probe = stack.length - 1;\n          var depth = 0; // try to recover from error\n\n          for (;;) {\n            // check for error recovery rule in this state\n            if (TERROR.toString() in table[state]) {\n              return depth;\n            }\n\n            if (state === 0 || stack_probe < 2) {\n              return false; // No suitable error recovery rule available.\n            }\n\n            stack_probe -= 2; // popStack(1): [symbol, action]\n\n            state = stack[stack_probe];\n            ++depth;\n          }\n        }\n\n        if (!recovering) {\n          // first see if there's any chance at hitting an error recovery rule:\n          error_rule_depth = locateNearestErrorRecoveryRule(state); // Report error\n\n          expected = [];\n\n          for (p in table[state]) {\n            if (this.terminals_[p] && p > TERROR) {\n              expected.push(\"'\" + this.terminals_[p] + \"'\");\n            }\n          }\n\n          if (this.lexer.showPosition) {\n            errStr = 'Parse error on line ' + (yylineno + 1) + \":\\n\" + this.lexer.showPosition() + \"\\nExpecting \" + expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n          } else {\n            errStr = 'Parse error on line ' + (yylineno + 1) + \": Unexpected \" + (symbol == EOF ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n          }\n\n          this.parseError(errStr, {\n            text: this.lexer.match,\n            token: this.terminals_[symbol] || symbol,\n            line: this.lexer.yylineno,\n            loc: yyloc,\n            expected: expected,\n            recoverable: error_rule_depth !== false\n          });\n        } else if (preErrorSymbol !== EOF) {\n          error_rule_depth = locateNearestErrorRecoveryRule(state);\n        } // just recovered from another error\n\n\n        if (recovering == 3) {\n          if (symbol === EOF || preErrorSymbol === EOF) {\n            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\n          } // discard current lookahead and grab another\n\n\n          yyleng = this.lexer.yyleng;\n          yytext = this.lexer.yytext;\n          yylineno = this.lexer.yylineno;\n          yyloc = this.lexer.yylloc;\n          symbol = lex();\n        } // try to recover from error\n\n\n        if (error_rule_depth === false) {\n          throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\n        }\n\n        popStack(error_rule_depth);\n        preErrorSymbol = symbol == TERROR ? null : symbol; // save the lookahead token\n\n        symbol = TERROR; // insert generic error symbol as new lookahead\n\n        state = stack[stack.length - 1];\n        action = table[state] && table[state][TERROR];\n        recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n      } // this shouldn't happen, unless resolve defaults are off\n\n\n      if (action[0] instanceof Array && action.length > 1) {\n        throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n      }\n\n      switch (action[0]) {\n        case 1:\n          // shift\n          //this.shiftCount++;\n          stack.push(symbol);\n          vstack.push(this.lexer.yytext);\n          lstack.push(this.lexer.yylloc);\n          stack.push(action[1]); // push state\n\n          symbol = null;\n\n          if (!preErrorSymbol) {\n            // normal execution/no error\n            yyleng = this.lexer.yyleng;\n            yytext = this.lexer.yytext;\n            yylineno = this.lexer.yylineno;\n            yyloc = this.lexer.yylloc;\n\n            if (recovering > 0) {\n              recovering--;\n            }\n          } else {\n            // error just occurred, resume old lookahead f/ before error\n            symbol = preErrorSymbol;\n            preErrorSymbol = null;\n          }\n\n          break;\n\n        case 2:\n          // reduce\n          //this.reductionCount++;\n          len = this.productions_[action[1]][1]; // perform semantic action\n\n          yyval.$ = vstack[vstack.length - len]; // default to $$ = $1\n          // default location, uses first token for firsts, last for lasts\n\n          yyval._$ = {\n            first_line: lstack[lstack.length - (len || 1)].first_line,\n            last_line: lstack[lstack.length - 1].last_line,\n            first_column: lstack[lstack.length - (len || 1)].first_column,\n            last_column: lstack[lstack.length - 1].last_column\n          };\n\n          if (ranges) {\n            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\n          }\n\n          r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n          if (typeof r !== 'undefined') {\n            return r;\n          } // pop off stack\n\n\n          if (len) {\n            stack = stack.slice(0, -1 * len * 2);\n            vstack = vstack.slice(0, -1 * len);\n            lstack = lstack.slice(0, -1 * len);\n          }\n\n          stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)\n\n          vstack.push(yyval.$);\n          lstack.push(yyval._$); // goto new state = table[STATE][NONTERMINAL]\n\n          newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n          stack.push(newState);\n          break;\n\n        case 3:\n          // accept\n          return true;\n      }\n    }\n\n    return true;\n  };\n\n  parser.init = function parser_init(dict) {\n    this.table = dict.table;\n    this.defaultActions = dict.defaultActions;\n    this.performAction = dict.performAction;\n    this.productions_ = dict.productions_;\n    this.symbols_ = dict.symbols_;\n    this.terminals_ = dict.terminals_;\n  };\n  /*\n   * LR(0) Parser\n   * */\n\n\n  var lr0 = generator.beget(lookaheadMixin, lrGeneratorMixin, {\n    type: \"LR(0)\",\n    afterconstructor: function lr0_afterconstructor() {\n      this.buildTable();\n    }\n  });\n  var LR0Generator = exports.LR0Generator = lr0.construct();\n  /*\n   * Simple LALR(1)\n   * */\n\n  var lalr = generator.beget(lookaheadMixin, lrGeneratorMixin, {\n    type: \"LALR(1)\",\n    afterconstructor: function (grammar, options) {\n      if (this.DEBUG) this.mix(lrGeneratorDebug, lalrGeneratorDebug); // mixin debug methods\n\n      options = options || {};\n      this.states = this.canonicalCollection();\n      this.terms_ = {};\n      var newg = this.newg = typal.beget(lookaheadMixin, {\n        oldg: this,\n        trace: this.trace,\n        nterms_: {},\n        DEBUG: false,\n        go_: function (r, B) {\n          r = r.split(\":\")[0]; // grab state #\n\n          B = B.map(function (b) {\n            return b.slice(b.indexOf(\":\") + 1);\n          });\n          return this.oldg.go(r, B);\n        }\n      });\n      newg.nonterminals = {};\n      newg.productions = [];\n      this.inadequateStates = []; // if true, only lookaheads in inadequate states are computed (faster, larger table)\n      // if false, lookaheads for all reductions will be computed (slower, smaller table)\n\n      this.onDemandLookahead = options.onDemandLookahead || false;\n      this.buildNewGrammar();\n      newg.computeLookaheads();\n      this.unionLookaheads();\n      this.table = this.parseTable(this.states);\n      this.defaultActions = findDefaults(this.table);\n    },\n    lookAheads: function LALR_lookaheads(state, item) {\n      return !!this.onDemandLookahead && !state.inadequate ? this.terminals : item.follows;\n    },\n    go: function LALR_go(p, w) {\n      var q = parseInt(p, 10);\n\n      for (var i = 0; i < w.length; i++) {\n        q = this.states.item(q).edges[w[i]] || q;\n      }\n\n      return q;\n    },\n    goPath: function LALR_goPath(p, w) {\n      var q = parseInt(p, 10),\n          t,\n          path = [];\n\n      for (var i = 0; i < w.length; i++) {\n        t = w[i] ? q + \":\" + w[i] : '';\n        if (t) this.newg.nterms_[t] = q;\n        path.push(t);\n        q = this.states.item(q).edges[w[i]] || q;\n        this.terms_[t] = w[i];\n      }\n\n      return {\n        path: path,\n        endState: q\n      };\n    },\n    // every disjoint reduction of a nonterminal becomes a produciton in G'\n    buildNewGrammar: function LALR_buildNewGrammar() {\n      var self = this,\n          newg = this.newg;\n      this.states.forEach(function (state, i) {\n        state.forEach(function (item) {\n          if (item.dotPosition === 0) {\n            // new symbols are a combination of state and transition symbol\n            var symbol = i + \":\" + item.production.symbol;\n            self.terms_[symbol] = item.production.symbol;\n            newg.nterms_[symbol] = i;\n            if (!newg.nonterminals[symbol]) newg.nonterminals[symbol] = new Nonterminal(symbol);\n            var pathInfo = self.goPath(i, item.production.handle);\n            var p = new Production(symbol, pathInfo.path, newg.productions.length);\n            newg.productions.push(p);\n            newg.nonterminals[symbol].productions.push(p); // store the transition that get's 'backed up to' after reduction on path\n\n            var handle = item.production.handle.join(' ');\n            var goes = self.states.item(pathInfo.endState).goes;\n            if (!goes[handle]) goes[handle] = [];\n            goes[handle].push(symbol); //self.trace('new production:',p);\n          }\n        });\n        if (state.inadequate) self.inadequateStates.push(i);\n      });\n    },\n    unionLookaheads: function LALR_unionLookaheads() {\n      var self = this,\n          newg = this.newg,\n          states = !!this.onDemandLookahead ? this.inadequateStates : this.states;\n      states.forEach(function union_states_forEach(i) {\n        var state = typeof i === 'number' ? self.states.item(i) : i,\n            follows = [];\n        if (state.reductions.length) state.reductions.forEach(function union_reduction_forEach(item) {\n          var follows = {};\n\n          for (var k = 0; k < item.follows.length; k++) {\n            follows[item.follows[k]] = true;\n          }\n\n          state.goes[item.production.handle.join(' ')].forEach(function reduction_goes_forEach(symbol) {\n            newg.nonterminals[symbol].follows.forEach(function goes_follows_forEach(symbol) {\n              var terminal = self.terms_[symbol];\n\n              if (!follows[terminal]) {\n                follows[terminal] = true;\n                item.follows.push(terminal);\n              }\n            });\n          }); //self.trace('unioned item', item);\n        });\n      });\n    }\n  });\n  var LALRGenerator = exports.LALRGenerator = lalr.construct(); // LALR generator debug mixin\n\n  var lalrGeneratorDebug = {\n    trace: function trace() {\n      Jison.print.apply(null, arguments);\n    },\n    beforebuildNewGrammar: function () {\n      this.trace(this.states.size() + \" states.\");\n      this.trace(\"Building lookahead grammar.\");\n    },\n    beforeunionLookaheads: function () {\n      this.trace(\"Computing lookaheads.\");\n    }\n  };\n  /*\n   * Lookahead parser definitions\n   *\n   * Define base type\n   * */\n\n  var lrLookaheadGenerator = generator.beget(lookaheadMixin, lrGeneratorMixin, {\n    afterconstructor: function lr_aftercontructor() {\n      this.computeLookaheads();\n      this.buildTable();\n    }\n  });\n  /*\n   * SLR Parser\n   * */\n\n  var SLRGenerator = exports.SLRGenerator = lrLookaheadGenerator.construct({\n    type: \"SLR(1)\",\n    lookAheads: function SLR_lookAhead(state, item) {\n      return this.nonterminals[item.production.symbol].follows;\n    }\n  });\n  /*\n   * LR(1) Parser\n   * */\n\n  var lr1 = lrLookaheadGenerator.beget({\n    type: \"Canonical LR(1)\",\n    lookAheads: function LR_lookAheads(state, item) {\n      return item.follows;\n    },\n    Item: lrGeneratorMixin.Item.prototype.construct({\n      afterconstructor: function () {\n        this.id = this.production.id + 'a' + this.dotPosition + 'a' + this.follows.sort().join(',');\n      },\n      eq: function (e) {\n        return e.id === this.id;\n      }\n    }),\n    closureOperation: function LR_ClosureOperation(itemSet\n    /*, closureSet*/\n    ) {\n      var closureSet = new this.ItemSet();\n      var self = this;\n      var set = itemSet,\n          itemQueue,\n          syms = {};\n\n      do {\n        itemQueue = new Set();\n        closureSet.concat(set);\n        set.forEach(function (item) {\n          var symbol = item.markedSymbol;\n          var b; // if token is a nonterminal, recursively add closures\n\n          if (symbol && self.nonterminals[symbol]) {\n            b = self.first(item.remainingHandle());\n            if (b.length === 0 || item.production.nullable) b = b.concat(item.follows);\n            self.nonterminals[symbol].productions.forEach(function (production) {\n              var newItem = new self.Item(production, 0, b);\n\n              if (!closureSet.contains(newItem) && !itemQueue.contains(newItem)) {\n                itemQueue.push(newItem);\n              }\n            });\n          } else if (!symbol) {\n            // reduction\n            closureSet.reductions.push(item);\n          }\n        });\n        set = itemQueue;\n      } while (!itemQueue.isEmpty());\n\n      return closureSet;\n    }\n  });\n  var LR1Generator = exports.LR1Generator = lr1.construct();\n  /*\n   * LL Parser\n   * */\n\n  var ll = generator.beget(lookaheadMixin, {\n    type: \"LL(1)\",\n    afterconstructor: function ll_aftercontructor() {\n      this.computeLookaheads();\n      this.table = this.parseTable(this.productions);\n    },\n    parseTable: function llParseTable(productions) {\n      var table = {},\n          self = this;\n      productions.forEach(function (production, i) {\n        var row = table[production.symbol] || {};\n        var tokens = production.first;\n\n        if (self.nullable(production.handle)) {\n          Set.union(tokens, self.nonterminals[production.symbol].follows);\n        }\n\n        tokens.forEach(function (token) {\n          if (row[token]) {\n            row[token].push(i);\n            self.conflicts++;\n          } else {\n            row[token] = [i];\n          }\n        });\n        table[production.symbol] = row;\n      });\n      return table;\n    }\n  });\n  var LLGenerator = exports.LLGenerator = ll.construct();\n\n  Jison.Generator = function Jison_Generator(g, options) {\n    var opt = typal.mix.call({}, g.options, options);\n\n    switch (opt.type) {\n      case 'lr0':\n        return new LR0Generator(g, opt);\n\n      case 'slr':\n        return new SLRGenerator(g, opt);\n\n      case 'lr':\n        return new LR1Generator(g, opt);\n\n      case 'll':\n        return new LLGenerator(g, opt);\n\n      default:\n        return new LALRGenerator(g, opt);\n    }\n  };\n\n  return function Parser(g, options) {\n    var gen = Jison.Generator(g, options);\n    return gen.createParser();\n  };\n}();","map":{"version":3,"sources":["/home/elvis/Documents/GitHub/medbase/mern-auth/node_modules/jison/lib/jison.js"],"names":["typal","require","Set","Lexer","ebnfParser","JSONSelect","esprima","escodegen","version","Jison","exports","console","log","print","puts","join","call","arguments","Parser","each","obj","func","forEach","p","hasOwnProperty","Nonterminal","construct","constructor","symbol","productions","first","follows","nullable","toString","Nonterminal_toString","str","Production","handle","id","precedence","Production_toString","generator","beget","Jison_Generator","grammar","opt","parse","options","mix","terms","operators","conflicts","resolutions","yy","actionInclude","String","replace","moduleInclude","DEBUG","debug","generatorDebug","processGrammar","lex","lexer","terminals_","processGrammarDef","bnf","tokens","nonterminals","self","ebnf","transform","trim","split","slice","symbols","processOperators","buildProductions","terminals","length","trace","augmentGrammar","startSymbol","start","Error","EOF","acceptProduction","unshift","symbols_","$accept","push","ops","i","k","prec","assoc","actions","prods","productions_","symbolId","her","addSymbol","s","buildProduction","sym","terms_","hasErrorRecovery","performAction","Function","e","r","rhs","Array","action","match","count","names","pl","_","n","createParser","warn","args","prototype","error","msg","apply","beforeprocessGrammar","afteraugmentGrammar","lookaheadMixin","computeLookaheads","lookaheadDebug","nullableSets","firstSets","followSets","cont","Follow_prod_forEach","production","q","ctx","go_","set","oldcount","t","bool","parseInt","nterms_","part","union","firsts","indexOf","FirstSets_forEach","item","beforenullableSets","beforefirstSets","beforefollowSets","afterfollowSets","nt","lrGeneratorMixin","buildTable","lrGeneratorDebug","states","canonicalCollection","table","parseTable","defaultActions","findDefaults","Item","dot","f","predecessor","dotPosition","markedSymbol","remainingHandle","eq","handleToString","temp","ItemSet","afterconstructor","reductions","goes","edges","shifts","inadequate","hash_","_items","concat","a","contains","valueOf","toValue","v","map","sort","toValue_inner","closureOperation","itemSet","closureSet","itemQueue","syms","CO_set_forEach","CO_nt_forEach","newItem","isEmpty","gotoOperation","gotoSet","goto_forEach","item1","firstState","marked","has","size","CC_itemSet_forEach","canonicalCollectionInsert","stateNum","g","predecessors","gv","NONASSOC","itemSets","conflictedStates","state","stackSymbol","j","gotoState","allterms","lookAheads","op","sol","resolveConflict","bydefault","printAction","noDefaultResolve","undefined","val","defaults","act","reduce","shift","sln","operator","generate","parser_generate","code","moduleName","moduleType","generateModule","generateAMDModule","generateCommonJSModule","out","generateModule_","moduleMain","commonjsMain","removeErrorRecovery","fn","parseFn","ast","labeled","reduced_code","body","consequent","expression","properties","pop","parser","JSON","stringify","parseError","traceParseError","process","exit","source","readFileSync","normalize","gen","beforeparseTable","afterparseTable","aftercanonicalCollection","init","recover","err","hash","recoverable","input","stack","vstack","lstack","yytext","yylineno","yyleng","recovering","TERROR","setInput","yylloc","yyloc","ranges","Object","getPrototypeOf","popStack","token","preErrorSymbol","yyval","len","newState","expected","_handle_error","error_rule_depth","errStr","locateNearestErrorRecoveryRule","stack_probe","depth","showPosition","text","line","loc","$","_$","first_line","last_line","first_column","last_column","range","parser_init","dict","lr0","type","lr0_afterconstructor","LR0Generator","lalr","lalrGeneratorDebug","newg","oldg","B","b","go","inadequateStates","onDemandLookahead","buildNewGrammar","unionLookaheads","LALR_lookaheads","LALR_go","w","goPath","LALR_goPath","path","endState","LALR_buildNewGrammar","pathInfo","LALR_unionLookaheads","union_states_forEach","union_reduction_forEach","reduction_goes_forEach","goes_follows_forEach","terminal","LALRGenerator","beforebuildNewGrammar","beforeunionLookaheads","lrLookaheadGenerator","lr_aftercontructor","SLRGenerator","SLR_lookAhead","lr1","LR_lookAheads","LR_ClosureOperation","LR1Generator","ll","ll_aftercontructor","llParseTable","row","LLGenerator","Generator"],"mappings":"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","sourcesContent":["// Jison, an LR(0), SLR(1), LARL(1), LR(1) Parser Generator\n// Zachary Carter <zach@carter.name>\n// MIT X Licensed\n\nvar typal      = require('./util/typal').typal;\nvar Set        = require('./util/set').Set;\nvar Lexer      = require('jison-lex');\nvar ebnfParser = require('ebnf-parser');\nvar JSONSelect = require('JSONSelect');\nvar esprima    = require('esprima');\nvar escodegen  = require('escodegen');\n\n\nvar version = require('../package.json').version;\n\nvar Jison = exports.Jison = exports;\nJison.version = version;\n\n// detect print\nif (typeof console !== 'undefined' && console.log) {\n    Jison.print = console.log;\n} else if (typeof puts !== 'undefined') {\n    Jison.print = function print () { puts([].join.call(arguments, ' ')); };\n} else if (typeof print !== 'undefined') {\n    Jison.print = print;\n} else {\n    Jison.print = function print () {};\n}\n\nJison.Parser = (function () {\n\n// iterator utility\nfunction each (obj, func) {\n    if (obj.forEach) {\n        obj.forEach(func);\n    } else {\n        var p;\n        for (p in obj) {\n            if (obj.hasOwnProperty(p)) {\n                func.call(obj, obj[p], p, obj);\n            }\n        }\n    }\n}\n\nvar Nonterminal = typal.construct({\n    constructor: function Nonterminal (symbol) {\n        this.symbol = symbol;\n        this.productions = new Set();\n        this.first = [];\n        this.follows = [];\n        this.nullable = false;\n    },\n    toString: function Nonterminal_toString () {\n        var str = this.symbol+\"\\n\";\n        str += (this.nullable ? 'nullable' : 'not nullable');\n        str += \"\\nFirsts: \"+this.first.join(', ');\n        str += \"\\nFollows: \"+this.first.join(', ');\n        str += \"\\nProductions:\\n  \"+this.productions.join('\\n  ');\n\n        return str;\n    }\n});\n\nvar Production = typal.construct({\n    constructor: function Production (symbol, handle, id) {\n        this.symbol = symbol;\n        this.handle = handle;\n        this.nullable = false;\n        this.id = id;\n        this.first = [];\n        this.precedence = 0;\n    },\n    toString: function Production_toString () {\n        return this.symbol+\" -> \"+this.handle.join(' ');\n    }\n});\n\nvar generator = typal.beget();\n\ngenerator.constructor = function Jison_Generator (grammar, opt) {\n    if (typeof grammar === 'string') {\n        grammar = ebnfParser.parse(grammar);\n    }\n\n    var options = typal.mix.call({}, grammar.options, opt);\n    this.terms = {};\n    this.operators = {};\n    this.productions = [];\n    this.conflicts = 0;\n    this.resolutions = [];\n    this.options = options;\n    this.yy = {}; // accessed as yy free variable in the parser/lexer actions\n\n    // source included in semantic action execution scope\n    if (grammar.actionInclude) {\n        if (typeof grammar.actionInclude === 'function') {\n            grammar.actionInclude = String(grammar.actionInclude).replace(/^\\s*function \\(\\) \\{/, '').replace(/\\}\\s*$/, '');\n        }\n        this.actionInclude = grammar.actionInclude;\n    }\n    this.moduleInclude = grammar.moduleInclude || '';\n\n    this.DEBUG = options.debug || false;\n    if (this.DEBUG) this.mix(generatorDebug); // mixin debug methods\n\n    this.processGrammar(grammar);\n\n    if (grammar.lex) {\n        this.lexer = new Lexer(grammar.lex, null, this.terminals_);\n    }\n};\n\ngenerator.processGrammar = function processGrammarDef (grammar) {\n    var bnf = grammar.bnf,\n        tokens = grammar.tokens,\n        nonterminals = this.nonterminals = {},\n        productions = this.productions,\n        self = this;\n\n    if (!grammar.bnf && grammar.ebnf) {\n        bnf = grammar.bnf = ebnfParser.transform(grammar.ebnf);\n    }\n\n    if (tokens) {\n        if (typeof tokens === 'string') {\n            tokens = tokens.trim().split(' ');\n        } else {\n            tokens = tokens.slice(0);\n        }\n    }\n\n    var symbols = this.symbols = [];\n\n    // calculate precedence of operators\n    var operators = this.operators = processOperators(grammar.operators);\n\n    // build productions from cfg\n    this.buildProductions(grammar.bnf, productions, nonterminals, symbols, operators);\n\n    if (tokens && this.terminals.length !== tokens.length) {\n        self.trace(\"Warning: declared tokens differ from tokens found in rules.\");\n        self.trace(this.terminals);\n        self.trace(tokens);\n    }\n\n    // augment the grammar\n    this.augmentGrammar(grammar);\n};\n\ngenerator.augmentGrammar = function augmentGrammar (grammar) {\n    // use specified start symbol, or default to first user defined production\n    this.startSymbol = grammar.start || grammar.startSymbol || this.productions[0].symbol;\n    if (!this.nonterminals[this.startSymbol]) {\n        throw new Error(\"Grammar error: startSymbol must be a non-terminal found in your grammar.\");\n    }\n    this.EOF = \"$end\";\n\n    // augment the grammar\n    var acceptProduction = new Production('$accept', [this.startSymbol, '$end'], 0);\n    this.productions.unshift(acceptProduction);\n\n    // prepend parser tokens\n    this.symbols.unshift(\"$accept\",this.EOF);\n    this.symbols_.$accept = 0;\n    this.symbols_[this.EOF] = 1;\n    this.terminals.unshift(this.EOF);\n\n    this.nonterminals.$accept = new Nonterminal(\"$accept\");\n    this.nonterminals.$accept.productions.push(acceptProduction);\n\n    // add follow $ to start symbol\n    this.nonterminals[this.startSymbol].follows.push(this.EOF);\n};\n\n// set precedence and associativity of operators\nfunction processOperators (ops) {\n    if (!ops) return {};\n    var operators = {};\n    for (var i=0,k,prec;prec=ops[i]; i++) {\n        for (k=1;k < prec.length;k++) {\n            operators[prec[k]] = {precedence: i+1, assoc: prec[0]};\n        }\n    }\n    return operators;\n}\n\n\ngenerator.buildProductions = function buildProductions(bnf, productions, nonterminals, symbols, operators) {\n    var actions = [\n\t  '/* this == yyval */',\n      this.actionInclude || '',\n      'var $0 = $$.length - 1;',\n      'switch (yystate) {'\n    ];\n    var prods, symbol;\n    var productions_ = [0];\n    var symbolId = 1;\n    var symbols_ = {};\n\n    var her = false; // has error recovery\n\n    function addSymbol (s) {\n        if (s && !symbols_[s]) {\n            symbols_[s] = ++symbolId;\n            symbols.push(s);\n        }\n    }\n\n    // add error symbol; will be third symbol, or \"2\" ($accept, $end, error)\n    addSymbol(\"error\");\n\n    for (symbol in bnf) {\n        if (!bnf.hasOwnProperty(symbol)) continue;\n\n        addSymbol(symbol);\n        nonterminals[symbol] = new Nonterminal(symbol);\n\n        if (typeof bnf[symbol] === 'string') {\n            prods = bnf[symbol].split(/\\s*\\|\\s*/g);\n        } else {\n            prods = bnf[symbol].slice(0);\n        }\n\n        prods.forEach(buildProduction);\n    }\n\n    var sym, terms = [], terms_ = {};\n    each(symbols_, function (id, sym) {\n        if (!nonterminals[sym]) {\n            terms.push(sym);\n            terms_[id] = sym;\n        }\n    });\n\n    this.hasErrorRecovery = her;\n\n    this.terminals = terms;\n    this.terminals_ = terms_;\n    this.symbols_ = symbols_;\n\n    this.productions_ = productions_;\n    actions.push('}');\n    // first try to create the performAction function the old way,\n    // but this will break for some legal constructs in the user action code:\n    try {\n        this.performAction = Function(\"yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */\", actions.join(\"\\n\"));\n    } catch (e) {\n        this.performAction = \"function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\\n\" + actions.join(\"\\n\") + \"\\n}\";\n    }\n\n    function buildProduction (handle) {\n        var r, rhs, i;\n        if (handle.constructor === Array) {\n            rhs = (typeof handle[0] === 'string') ?\n                      handle[0].trim().split(' ') :\n                      handle[0].slice(0);\n\n            for (i=0; i<rhs.length; i++) {\n                if (rhs[i] === 'error') her = true;\n                if (!symbols_[rhs[i]]) {\n                    addSymbol(rhs[i]);\n                }\n            }\n\n            if (typeof handle[1] === 'string' || handle.length == 3) {\n                // semantic action specified\n                var action = 'case '+(productions.length+1)+':'+handle[1]+'\\nbreak;';\n\n                // replace named semantic values ($nonterminal)\n                if (action.match(/[$@][a-zA-Z][a-zA-Z0-9_]*/)) {\n                    var count = {},\n                        names = {};\n                    for (i=0;i<rhs.length;i++) {\n                        if (names[rhs[i]]) {\n                            names[rhs[i]+(++count[rhs[i]])] = i+1;\n                        } else {\n                            names[rhs[i]] = i+1;\n                            names[rhs[i]+\"1\"] = i+1;\n                            count[rhs[i]] = 1;\n                        }\n                    }\n                    action = action.replace(/\\$([a-zA-Z][a-zA-Z0-9_]*)/g, function (str, pl) {\n                            return names[pl] ? '$'+names[pl] : pl;\n                        }).replace(/@([a-zA-Z][a-zA-Z0-9_]*)/g, function (str, pl) {\n                            return names[pl] ? '@'+names[pl] : pl;\n                        });\n                }\n                action = action.replace(/([^'\"])\\$\\$|^\\$\\$/g, '$1this.$').replace(/@[0$]/g, \"this._$\")\n                    .replace(/\\$(\\d+)/g, function (_, n) {\n                        return \"$$[$0\" + (n - rhs.length || '') + \"]\";\n                    })\n                    .replace(/@(\\d+)/g, function (_, n) {\n                        return \"_$[$0\" + (n - rhs.length || '') + \"]\";\n                    });\n                actions.push(action);\n\n                r = new Production(symbol, rhs, productions.length+1);\n                // precedence specified also\n                if (handle[2] && operators[handle[2].prec]) {\n                    r.precedence = operators[handle[2].prec].precedence;\n                }\n            } else {\n                // only precedence specified\n                r = new Production(symbol, rhs, productions.length+1);\n                if (operators[handle[1].prec]) {\n                    r.precedence = operators[handle[1].prec].precedence;\n                }\n            }\n        } else {\n            rhs = handle.trim().split(' ');\n            for (i=0; i<rhs.length; i++) {\n                if (rhs[i] === 'error') her = true;\n                if (!symbols_[rhs[i]]) {\n                    addSymbol(rhs[i]);\n                }\n            }\n            r = new Production(symbol, rhs, productions.length+1);\n        }\n        if (r.precedence === 0) {\n            // set precedence\n            for (i=r.handle.length-1; i>=0; i--) {\n                if (!(r.handle[i] in nonterminals) && r.handle[i] in operators) {\n                    r.precedence = operators[r.handle[i]].precedence;\n                }\n            }\n        }\n\n        productions.push(r);\n        productions_.push([symbols_[r.symbol], r.handle[0] === '' ? 0 : r.handle.length]);\n        nonterminals[symbol].productions.push(r);\n    }\n};\n\n\n\ngenerator.createParser = function createParser () {\n    throw new Error('Calling abstract method.');\n};\n\n// noop. implemented in debug mixin\ngenerator.trace = function trace () { };\n\ngenerator.warn = function warn () {\n    var args = Array.prototype.slice.call(arguments,0);\n    Jison.print.call(null,args.join(\"\"));\n};\n\ngenerator.error = function error (msg) {\n    throw new Error(msg);\n};\n\n// Generator debug mixin\n\nvar generatorDebug = {\n    trace: function trace () {\n        Jison.print.apply(null, arguments);\n    },\n    beforeprocessGrammar: function () {\n        this.trace(\"Processing grammar.\");\n    },\n    afteraugmentGrammar: function () {\n        var trace = this.trace;\n        each(this.symbols, function (sym, i) {\n            trace(sym+\"(\"+i+\")\");\n        });\n    }\n};\n\n\n\n/*\n * Mixin for common behaviors of lookahead parsers\n * */\nvar lookaheadMixin = {};\n\nlookaheadMixin.computeLookaheads = function computeLookaheads () {\n    if (this.DEBUG) this.mix(lookaheadDebug); // mixin debug methods\n\n    this.computeLookaheads = function () {};\n    this.nullableSets();\n    this.firstSets();\n    this.followSets();\n};\n\n// calculate follow sets typald on first and nullable\nlookaheadMixin.followSets = function followSets () {\n    var productions = this.productions,\n        nonterminals = this.nonterminals,\n        self = this,\n        cont = true;\n\n    // loop until no further changes have been made\n    while(cont) {\n        cont = false;\n\n        productions.forEach(function Follow_prod_forEach (production, k) {\n            //self.trace(production.symbol,nonterminals[production.symbol].follows);\n            // q is used in Simple LALR algorithm determine follows in context\n            var q;\n            var ctx = !!self.go_;\n\n            var set = [],oldcount;\n            for (var i=0,t;t=production.handle[i];++i) {\n                if (!nonterminals[t]) continue;\n\n                // for Simple LALR algorithm, self.go_ checks if\n                if (ctx)\n                    q = self.go_(production.symbol, production.handle.slice(0, i));\n                var bool = !ctx || q === parseInt(self.nterms_[t], 10);\n\n                if (i === production.handle.length+1 && bool) {\n                    set = nonterminals[production.symbol].follows;\n                } else {\n                    var part = production.handle.slice(i+1);\n\n                    set = self.first(part);\n                    if (self.nullable(part) && bool) {\n                        set.push.apply(set, nonterminals[production.symbol].follows);\n                    }\n                }\n                oldcount = nonterminals[t].follows.length;\n                Set.union(nonterminals[t].follows, set);\n                if (oldcount !== nonterminals[t].follows.length) {\n                    cont = true;\n                }\n            }\n        });\n    }\n};\n\n// return the FIRST set of a symbol or series of symbols\nlookaheadMixin.first = function first (symbol) {\n    // epsilon\n    if (symbol === '') {\n        return [];\n    // RHS\n    } else if (symbol instanceof Array) {\n        var firsts = [];\n        for (var i=0,t;t=symbol[i];++i) {\n            if (!this.nonterminals[t]) {\n                if (firsts.indexOf(t) === -1)\n                    firsts.push(t);\n            } else {\n                Set.union(firsts, this.nonterminals[t].first);\n            }\n            if (!this.nullable(t))\n                break;\n        }\n        return firsts;\n    // terminal\n    } else if (!this.nonterminals[symbol]) {\n        return [symbol];\n    // nonterminal\n    } else {\n        return this.nonterminals[symbol].first;\n    }\n};\n\n// fixed-point calculation of FIRST sets\nlookaheadMixin.firstSets = function firstSets () {\n    var productions = this.productions,\n        nonterminals = this.nonterminals,\n        self = this,\n        cont = true,\n        symbol,firsts;\n\n    // loop until no further changes have been made\n    while(cont) {\n        cont = false;\n\n        productions.forEach(function FirstSets_forEach (production, k) {\n            var firsts = self.first(production.handle);\n            if (firsts.length !== production.first.length) {\n                production.first = firsts;\n                cont=true;\n            }\n        });\n\n        for (symbol in nonterminals) {\n            firsts = [];\n            nonterminals[symbol].productions.forEach(function (production) {\n                Set.union(firsts, production.first);\n            });\n            if (firsts.length !== nonterminals[symbol].first.length) {\n                nonterminals[symbol].first = firsts;\n                cont=true;\n            }\n        }\n    }\n};\n\n// fixed-point calculation of NULLABLE\nlookaheadMixin.nullableSets = function nullableSets () {\n    var firsts = this.firsts = {},\n        nonterminals = this.nonterminals,\n        self = this,\n        cont = true;\n\n    // loop until no further changes have been made\n    while(cont) {\n        cont = false;\n\n        // check if each production is nullable\n        this.productions.forEach(function (production, k) {\n            if (!production.nullable) {\n                for (var i=0,n=0,t;t=production.handle[i];++i) {\n                    if (self.nullable(t)) n++;\n                }\n                if (n===i) { // production is nullable if all tokens are nullable\n                    production.nullable = cont = true;\n                }\n            }\n        });\n\n        //check if each symbol is nullable\n        for (var symbol in nonterminals) {\n            if (!this.nullable(symbol)) {\n                for (var i=0,production;production=nonterminals[symbol].productions.item(i);i++) {\n                    if (production.nullable)\n                        nonterminals[symbol].nullable = cont = true;\n                }\n            }\n        }\n    }\n};\n\n// check if a token or series of tokens is nullable\nlookaheadMixin.nullable = function nullable (symbol) {\n    // epsilon\n    if (symbol === '') {\n        return true;\n    // RHS\n    } else if (symbol instanceof Array) {\n        for (var i=0,t;t=symbol[i];++i) {\n            if (!this.nullable(t))\n                return false;\n        }\n        return true;\n    // terminal\n    } else if (!this.nonterminals[symbol]) {\n        return false;\n    // nonterminal\n    } else {\n        return this.nonterminals[symbol].nullable;\n    }\n};\n\n\n// lookahead debug mixin\nvar lookaheadDebug = {\n    beforenullableSets: function () {\n        this.trace(\"Computing Nullable sets.\");\n    },\n    beforefirstSets: function () {\n        this.trace(\"Computing First sets.\");\n    },\n    beforefollowSets: function () {\n        this.trace(\"Computing Follow sets.\");\n    },\n    afterfollowSets: function () {\n        var trace = this.trace;\n        each(this.nonterminals, function (nt, t) {\n            trace(nt, '\\n');\n        });\n    }\n};\n\n/*\n * Mixin for common LR parser behavior\n * */\nvar lrGeneratorMixin = {};\n\nlrGeneratorMixin.buildTable = function buildTable () {\n    if (this.DEBUG) this.mix(lrGeneratorDebug); // mixin debug methods\n\n    this.states = this.canonicalCollection();\n    this.table = this.parseTable(this.states);\n    this.defaultActions = findDefaults(this.table);\n};\n\nlrGeneratorMixin.Item = typal.construct({\n    constructor: function Item(production, dot, f, predecessor) {\n        this.production = production;\n        this.dotPosition = dot || 0;\n        this.follows = f || [];\n        this.predecessor = predecessor;\n        this.id = parseInt(production.id+'a'+this.dotPosition, 36);\n        this.markedSymbol = this.production.handle[this.dotPosition];\n    },\n    remainingHandle: function () {\n        return this.production.handle.slice(this.dotPosition+1);\n    },\n    eq: function (e) {\n        return e.id === this.id;\n    },\n    handleToString: function () {\n        var handle = this.production.handle.slice(0);\n        handle[this.dotPosition] = '.'+(handle[this.dotPosition]||'');\n        return handle.join(' ');\n    },\n    toString: function () {\n        var temp = this.production.handle.slice(0);\n        temp[this.dotPosition] = '.'+(temp[this.dotPosition]||'');\n        return this.production.symbol+\" -> \"+temp.join(' ') +\n            (this.follows.length === 0 ? \"\" : \" #lookaheads= \"+this.follows.join(' '));\n    }\n});\n\nlrGeneratorMixin.ItemSet = Set.prototype.construct({\n    afterconstructor: function () {\n        this.reductions = [];\n        this.goes = {};\n        this.edges = {};\n        this.shifts = false;\n        this.inadequate = false;\n        this.hash_ = {};\n        for (var i=this._items.length-1;i >=0;i--) {\n            this.hash_[this._items[i].id] = true; //i;\n        }\n    },\n    concat: function concat (set) {\n        var a = set._items || set;\n        for (var i=a.length-1;i >=0;i--) {\n            this.hash_[a[i].id] = true; //i;\n        }\n        this._items.push.apply(this._items, a);\n        return this;\n    },\n    push: function (item) {\n        this.hash_[item.id] = true;\n        return this._items.push(item);\n    },\n    contains: function (item) {\n        return this.hash_[item.id];\n    },\n    valueOf: function toValue () {\n        var v = this._items.map(function (a) {return a.id;}).sort().join('|');\n        this.valueOf = function toValue_inner() {return v;};\n        return v;\n    }\n});\n\nlrGeneratorMixin.closureOperation = function closureOperation (itemSet /*, closureSet*/) {\n    var closureSet = new this.ItemSet();\n    var self = this;\n\n    var set = itemSet,\n        itemQueue, syms = {};\n\n    do {\n    itemQueue = new Set();\n    closureSet.concat(set);\n    set.forEach(function CO_set_forEach (item) {\n        var symbol = item.markedSymbol;\n\n        // if token is a non-terminal, recursively add closures\n        if (symbol && self.nonterminals[symbol]) {\n            if(!syms[symbol]) {\n                self.nonterminals[symbol].productions.forEach(function CO_nt_forEach (production) {\n                    var newItem = new self.Item(production, 0);\n                    if(!closureSet.contains(newItem))\n                        itemQueue.push(newItem);\n                });\n                syms[symbol] = true;\n            }\n        } else if (!symbol) {\n            // reduction\n            closureSet.reductions.push(item);\n            closureSet.inadequate = closureSet.reductions.length > 1 || closureSet.shifts;\n        } else {\n            // shift\n            closureSet.shifts = true;\n            closureSet.inadequate = closureSet.reductions.length > 0;\n        }\n    });\n\n    set = itemQueue;\n\n    } while (!itemQueue.isEmpty());\n\n    return closureSet;\n};\n\nlrGeneratorMixin.gotoOperation = function gotoOperation (itemSet, symbol) {\n    var gotoSet = new this.ItemSet(),\n        self = this;\n\n    itemSet.forEach(function goto_forEach(item, n) {\n        if (item.markedSymbol === symbol) {\n            gotoSet.push(new self.Item(item.production, item.dotPosition+1, item.follows, n));\n        }\n    });\n\n    return gotoSet.isEmpty() ? gotoSet : this.closureOperation(gotoSet);\n};\n\n/* Create unique set of item sets\n * */\nlrGeneratorMixin.canonicalCollection = function canonicalCollection () {\n    var item1 = new this.Item(this.productions[0], 0, [this.EOF]);\n    var firstState = this.closureOperation(new this.ItemSet(item1)),\n        states = new Set(firstState),\n        marked = 0,\n        self = this,\n        itemSet;\n\n    states.has = {};\n    states.has[firstState] = 0;\n\n    while (marked !== states.size()) {\n        itemSet = states.item(marked); marked++;\n        itemSet.forEach(function CC_itemSet_forEach (item) {\n            if (item.markedSymbol && item.markedSymbol !== self.EOF)\n                self.canonicalCollectionInsert(item.markedSymbol, itemSet, states, marked-1);\n        });\n    }\n\n    return states;\n};\n\n// Pushes a unique state into the que. Some parsing algorithms may perform additional operations\nlrGeneratorMixin.canonicalCollectionInsert = function canonicalCollectionInsert (symbol, itemSet, states, stateNum) {\n    var g = this.gotoOperation(itemSet, symbol);\n    if (!g.predecessors)\n        g.predecessors = {};\n    // add g to que if not empty or duplicate\n    if (!g.isEmpty()) {\n        var gv = g.valueOf(),\n            i = states.has[gv];\n        if (i === -1 || typeof i === 'undefined') {\n            states.has[gv] = states.size();\n            itemSet.edges[symbol] = states.size(); // store goto transition for table\n            states.push(g);\n            g.predecessors[symbol] = [stateNum];\n        } else {\n            itemSet.edges[symbol] = i; // store goto transition for table\n            states.item(i).predecessors[symbol].push(stateNum);\n        }\n    }\n};\n\nvar NONASSOC = 0;\nlrGeneratorMixin.parseTable = function parseTable (itemSets) {\n    var states = [],\n        nonterminals = this.nonterminals,\n        operators = this.operators,\n        conflictedStates = {}, // array of [state, token] tuples\n        self = this,\n        s = 1, // shift\n        r = 2, // reduce\n        a = 3; // accept\n\n    // for each item set\n    itemSets.forEach(function (itemSet, k) {\n        var state = states[k] = {};\n        var action, stackSymbol;\n\n        // set shift and goto actions\n        for (stackSymbol in itemSet.edges) {\n            itemSet.forEach(function (item, j) {\n                // find shift and goto actions\n                if (item.markedSymbol == stackSymbol) {\n                    var gotoState = itemSet.edges[stackSymbol];\n                    if (nonterminals[stackSymbol]) {\n                        // store state to go to after a reduce\n                        //self.trace(k, stackSymbol, 'g'+gotoState);\n                        state[self.symbols_[stackSymbol]] = gotoState;\n                    } else {\n                        //self.trace(k, stackSymbol, 's'+gotoState);\n                        state[self.symbols_[stackSymbol]] = [s,gotoState];\n                    }\n                }\n            });\n        }\n\n        // set accept action\n        itemSet.forEach(function (item, j) {\n            if (item.markedSymbol == self.EOF) {\n                // accept\n                state[self.symbols_[self.EOF]] = [a];\n                //self.trace(k, self.EOF, state[self.EOF]);\n            }\n        });\n\n        var allterms = self.lookAheads ? false : self.terminals;\n\n        // set reductions and resolve potential conflicts\n        itemSet.reductions.forEach(function (item, j) {\n            // if parser uses lookahead, only enumerate those terminals\n            var terminals = allterms || self.lookAheads(itemSet, item);\n\n            terminals.forEach(function (stackSymbol) {\n                action = state[self.symbols_[stackSymbol]];\n                var op = operators[stackSymbol];\n\n                // Reading a terminal and current position is at the end of a production, try to reduce\n                if (action || action && action.length) {\n                    var sol = resolveConflict(item.production, op, [r,item.production.id], action[0] instanceof Array ? action[0] : action);\n                    self.resolutions.push([k,stackSymbol,sol]);\n                    if (sol.bydefault) {\n                        self.conflicts++;\n                        if (!self.DEBUG) {\n                            self.warn('Conflict in grammar: multiple actions possible when lookahead token is ',stackSymbol,' in state ',k, \"\\n- \", printAction(sol.r, self), \"\\n- \", printAction(sol.s, self));\n                            conflictedStates[k] = true;\n                        }\n                        if (self.options.noDefaultResolve) {\n                            if (!(action[0] instanceof Array))\n                                action = [action];\n                            action.push(sol.r);\n                        }\n                    } else {\n                        action = sol.action;\n                    }\n                } else {\n                    action = [r,item.production.id];\n                }\n                if (action && action.length) {\n                    state[self.symbols_[stackSymbol]] = action;\n                } else if (action === NONASSOC) {\n                    state[self.symbols_[stackSymbol]] = undefined;\n                }\n            });\n        });\n\n    });\n\n    if (!self.DEBUG && self.conflicts > 0) {\n        self.warn(\"\\nStates with conflicts:\");\n        each(conflictedStates, function (val, state) {\n            self.warn('State '+state);\n            self.warn('  ',itemSets.item(state).join(\"\\n  \"));\n        });\n    }\n\n    return states;\n};\n\n// find states with only one action, a reduction\nfunction findDefaults (states) {\n    var defaults = {};\n    states.forEach(function (state, k) {\n        var i = 0;\n        for (var act in state) {\n             if ({}.hasOwnProperty.call(state, act)) i++;\n        }\n\n        if (i === 1 && state[act][0] === 2) {\n            // only one action in state and it's a reduction\n            defaults[k] = state[act];\n        }\n    });\n\n    return defaults;\n}\n\n// resolves shift-reduce and reduce-reduce conflicts\nfunction resolveConflict (production, op, reduce, shift) {\n    var sln = {production: production, operator: op, r: reduce, s: shift},\n        s = 1, // shift\n        r = 2, // reduce\n        a = 3; // accept\n\n    if (shift[0] === r) {\n        sln.msg = \"Resolve R/R conflict (use first production declared in grammar.)\";\n        sln.action = shift[1] < reduce[1] ? shift : reduce;\n        if (shift[1] !== reduce[1]) sln.bydefault = true;\n        return sln;\n    }\n\n    if (production.precedence === 0 || !op) {\n        sln.msg = \"Resolve S/R conflict (shift by default.)\";\n        sln.bydefault = true;\n        sln.action = shift;\n    } else if (production.precedence < op.precedence ) {\n        sln.msg = \"Resolve S/R conflict (shift for higher precedent operator.)\";\n        sln.action = shift;\n    } else if (production.precedence === op.precedence) {\n        if (op.assoc === \"right\" ) {\n            sln.msg = \"Resolve S/R conflict (shift for right associative operator.)\";\n            sln.action = shift;\n        } else if (op.assoc === \"left\" ) {\n            sln.msg = \"Resolve S/R conflict (reduce for left associative operator.)\";\n            sln.action = reduce;\n        } else if (op.assoc === \"nonassoc\" ) {\n            sln.msg = \"Resolve S/R conflict (no action for non-associative operator.)\";\n            sln.action = NONASSOC;\n        }\n    } else {\n        sln.msg = \"Resolve conflict (reduce for higher precedent production.)\";\n        sln.action = reduce;\n    }\n\n    return sln;\n}\n\nlrGeneratorMixin.generate = function parser_generate (opt) {\n    opt = typal.mix.call({}, this.options, opt);\n    var code = \"\";\n\n    // check for illegal identifier\n    if (!opt.moduleName || !opt.moduleName.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/)) {\n        opt.moduleName = \"parser\";\n    }\n    switch (opt.moduleType) {\n        case \"js\":\n            code = this.generateModule(opt);\n            break;\n        case \"amd\":\n            code = this.generateAMDModule(opt);\n            break;\n        default:\n            code = this.generateCommonJSModule(opt);\n            break;\n    }\n\n    return code;\n};\n\nlrGeneratorMixin.generateAMDModule = function generateAMDModule(opt){\n    opt = typal.mix.call({}, this.options, opt);\n    var out = '\\n\\ndefine([], function(){'\n        + '\\nvar parser = '+ this.generateModule_(opt)\n        + (this.lexer && this.lexer.generateModule ?\n          '\\n' + this.lexer.generateModule() +\n          '\\nparser.lexer = lexer;' : '')\n        + '\\nreturn parser;'\n        + '\\n});'\n    return out;\n};\n\nlrGeneratorMixin.generateCommonJSModule = function generateCommonJSModule (opt) {\n    opt = typal.mix.call({}, this.options, opt);\n    var moduleName = opt.moduleName || \"parser\";\n    var out = this.generateModule(opt)\n        + \"\\n\\n\\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\"\n        + \"\\nexports.parser = \"+moduleName+\";\"\n        + \"\\nexports.Parser = \"+moduleName+\".Parser;\"\n        + \"\\nexports.parse = function () { return \"+moduleName+\".parse.apply(\"+moduleName+\", arguments); };\"\n        + \"\\nexports.main = \"+ String(opt.moduleMain || commonjsMain) + \";\"\n        + \"\\nif (typeof module !== 'undefined' && require.main === module) {\\n\"\n        + \"  exports.main(process.argv.slice(1));\\n}\"\n        + \"\\n}\";\n\n    return out;\n};\n\nlrGeneratorMixin.generateModule = function generateModule (opt) {\n    opt = typal.mix.call({}, this.options, opt);\n    var moduleName = opt.moduleName || \"parser\";\n    var out = \"/* parser generated by jison \" + version + \" */\\n\"\n        + \"/*\\n\"\n        + \"  Returns a Parser object of the following structure:\\n\"\n        + \"\\n\"\n        + \"  Parser: {\\n\"\n        + \"    yy: {}\\n\"\n        + \"  }\\n\"\n        + \"\\n\"\n        + \"  Parser.prototype: {\\n\"\n        + \"    yy: {},\\n\"\n        + \"    trace: function(),\\n\"\n        + \"    symbols_: {associative list: name ==> number},\\n\"\n        + \"    terminals_: {associative list: number ==> name},\\n\"\n        + \"    productions_: [...],\\n\"\n        + \"    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\\n\"\n        + \"    table: [...],\\n\"\n        + \"    defaultActions: {...},\\n\"\n        + \"    parseError: function(str, hash),\\n\"\n        + \"    parse: function(input),\\n\"\n        + \"\\n\"\n        + \"    lexer: {\\n\"\n        + \"        EOF: 1,\\n\"\n        + \"        parseError: function(str, hash),\\n\"\n        + \"        setInput: function(input),\\n\"\n        + \"        input: function(),\\n\"\n        + \"        unput: function(str),\\n\"\n        + \"        more: function(),\\n\"\n        + \"        less: function(n),\\n\"\n        + \"        pastInput: function(),\\n\"\n        + \"        upcomingInput: function(),\\n\"\n        + \"        showPosition: function(),\\n\"\n        + \"        test_match: function(regex_match_array, rule_index),\\n\"\n        + \"        next: function(),\\n\"\n        + \"        lex: function(),\\n\"\n        + \"        begin: function(condition),\\n\"\n        + \"        popState: function(),\\n\"\n        + \"        _currentRules: function(),\\n\"\n        + \"        topState: function(),\\n\"\n        + \"        pushState: function(condition),\\n\"\n        + \"\\n\"\n        + \"        options: {\\n\"\n        + \"            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\\n\"\n        + \"            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\\n\"\n        + \"            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\\n\"\n        + \"        },\\n\"\n        + \"\\n\"\n        + \"        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\\n\"\n        + \"        rules: [...],\\n\"\n        + \"        conditions: {associative list: name ==> set},\\n\"\n        + \"    }\\n\"\n        + \"  }\\n\"\n        + \"\\n\"\n        + \"\\n\"\n        + \"  token location info (@$, _$, etc.): {\\n\"\n        + \"    first_line: n,\\n\"\n        + \"    last_line: n,\\n\"\n        + \"    first_column: n,\\n\"\n        + \"    last_column: n,\\n\"\n        + \"    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\\n\"\n        + \"  }\\n\"\n        + \"\\n\"\n        + \"\\n\"\n        + \"  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\\n\"\n        + \"    text:        (matched text)\\n\"\n        + \"    token:       (the produced terminal token, if any)\\n\"\n        + \"    line:        (yylineno)\\n\"\n        + \"  }\\n\"\n        + \"  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\\n\"\n        + \"    loc:         (yylloc)\\n\"\n        + \"    expected:    (string describing the set of expected tokens)\\n\"\n        + \"    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\\n\"\n        + \"  }\\n\"\n        + \"*/\\n\";\n    out += (moduleName.match(/\\./) ? moduleName : \"var \"+moduleName)+\" = (function(){\";\n    out += \"\\nvar parser = \"+this.generateModule_();\n    out += \"\\n\"+this.moduleInclude;\n    if (this.lexer && this.lexer.generateModule) {\n        out += this.lexer.generateModule();\n        out += \"\\nparser.lexer = lexer;\";\n    }\n    out += \"\\nfunction Parser () {\\n  this.yy = {};\\n}\\n\"\n        + \"Parser.prototype = parser;\"\n        + \"parser.Parser = Parser;\"\n        + \"\\nreturn new Parser;\\n})();\";\n\n    return out;\n};\n\n// returns parse function without error recovery code\nfunction removeErrorRecovery (fn) {\n    var parseFn = String(fn);\n    try {\n        var ast = esprima.parse(parseFn);\n\n        var labeled = JSONSelect.match(':has(:root > .label > .name:val(\"_handle_error\"))', ast);\n        var reduced_code = labeled[0].body.consequent.body[3].consequent.body;\n        reduced_code[0] = labeled[0].body.consequent.body[1];     // remove the line: error_rule_depth = locateNearestErrorRecoveryRule(state);\n        reduced_code[4].expression.arguments[1].properties.pop(); // remove the line: 'recoverable: error_rule_depth !== false'\n        labeled[0].body.consequent.body = reduced_code;\n\n        return escodegen.generate(ast).replace(/_handle_error:\\s?/,\"\").replace(/\\\\\\\\n/g,\"\\\\n\");\n    } catch (e) {\n        return parseFn;\n    }\n}\n\nlrGeneratorMixin.generateModule_ = function generateModule_ () {\n    var parseFn = (this.hasErrorRecovery ? String : removeErrorRecovery)(parser.parse);\n\n    var out = \"{\";\n    out += [\n        \"trace: \" + String(this.trace || parser.trace),\n        \"yy: {}\",\n        \"symbols_: \" + JSON.stringify(this.symbols_),\n        \"terminals_: \" + JSON.stringify(this.terminals_).replace(/\"([0-9]+)\":/g,\"$1:\"),\n        \"productions_: \" + JSON.stringify(this.productions_),\n        \"performAction: \" + String(this.performAction),\n        \"table: \" + JSON.stringify(this.table).replace(/\"([0-9]+)\":/g,\"$1:\"),\n        \"defaultActions: \" + JSON.stringify(this.defaultActions).replace(/\"([0-9]+)\":/g,\"$1:\"),\n        \"parseError: \" + String(this.parseError || (this.hasErrorRecovery ? traceParseError : parser.parseError)),\n        \"parse: \" + parseFn\n        ].join(\",\\n\");\n    out += \"};\";\n\n    return out;\n};\n\n// default main method for generated commonjs modules\nfunction commonjsMain (args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n}\n\n// debug mixin for LR parser generators\n\nfunction printAction (a, gen) {\n    var s = a[0] == 1 ? 'shift token (then go to state '+a[1]+')' :\n        a[0] == 2 ? 'reduce by rule: '+gen.productions[a[1]] :\n                    'accept' ;\n\n    return s;\n}\n\nvar lrGeneratorDebug = {\n    beforeparseTable: function () {\n        this.trace(\"Building parse table.\");\n    },\n    afterparseTable: function () {\n        var self = this;\n        if (this.conflicts > 0) {\n            this.resolutions.forEach(function (r, i) {\n                if (r[2].bydefault) {\n                    self.warn('Conflict at state: ',r[0], ', token: ',r[1], \"\\n  \", printAction(r[2].r, self), \"\\n  \", printAction(r[2].s, self));\n                }\n            });\n            this.trace(\"\\n\"+this.conflicts+\" Conflict(s) found in grammar.\");\n        }\n        this.trace(\"Done.\");\n    },\n    aftercanonicalCollection: function (states) {\n        var trace = this.trace;\n        trace(\"\\nItem sets\\n------\");\n\n        states.forEach(function (state, i) {\n            trace(\"\\nitem set\",i,\"\\n\"+state.join(\"\\n\"), '\\ntransitions -> ', JSON.stringify(state.edges));\n        });\n    }\n};\n\nvar parser = typal.beget();\n\nlrGeneratorMixin.createParser = function createParser () {\n    var p = parser.beget();\n    p.yy = {};\n\n    p.init({\n        table: this.table,\n        defaultActions: this.defaultActions,\n        productions_: this.productions_,\n        symbols_: this.symbols_,\n        terminals_: this.terminals_,\n        performAction: this.performAction\n    });\n\n    // don't throw if grammar recovers from errors\n    if (this.hasErrorRecovery) {\n        p.parseError = traceParseError;\n        p.recover = true;\n    }\n\n    // for debugging\n    p.productions = this.productions;\n\n    // backwards compatability\n    p.generate = this.generate;\n    p.lexer = this.lexer;\n    p.generateModule = this.generateModule;\n    p.generateCommonJSModule = this.generateCommonJSModule;\n    p.generateModule_ = this.generateModule_;\n\n    var gen = this;\n\n    p.Parser = function () {\n      return gen.createParser();\n    };\n\n    return p;\n};\n\nparser.trace = generator.trace;\nparser.warn = generator.warn;\nparser.error = generator.error;\n\nfunction traceParseError (err, hash) {\n    this.trace(err);\n}\n\nfunction parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        throw new Error(str);\n    }\n}\n\nparser.parseError = lrGeneratorMixin.parseError = parseError;\n\nparser.parse = function parse (input) {\n    var self = this,\n        stack = [0],\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    this.yy.parser = this;\n    if (typeof this.lexer.yylloc == 'undefined') {\n        this.lexer.yylloc = {};\n    }\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n\n    var ranges = this.lexer.options && this.lexer.options.ranges;\n\n    if (typeof this.yy.parseError === 'function') {\n        this.parseError = this.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError; // because in the generated code 'this.__proto__.parseError' doesn't work for everyone: http://javascriptweblog.wordpress.com/2010/06/07/understanding-javascript-prototypes/\n    }\n\n    function popStack (n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n    function lex() {\n        var token;\n        token = self.lexer.lex() || EOF; // $end = 1\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length - 1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n_handle_error:\n        // handle parse error\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n            var error_rule_depth;\n            var errStr = '';\n\n            // Return the rule stack depth where the nearest error rule can be found.\n            // Return FALSE when no error recovery rule was found.\n            function locateNearestErrorRecoveryRule(state) {\n                var stack_probe = stack.length - 1;\n                var depth = 0;\n\n                // try to recover from error\n                for(;;) {\n                    // check for error recovery rule in this state\n                    if ((TERROR.toString()) in table[state]) {\n                        return depth;\n                    }\n                    if (state === 0 || stack_probe < 2) {\n                        return false; // No suitable error recovery rule available.\n                    }\n                    stack_probe -= 2; // popStack(1): [symbol, action]\n                    state = stack[stack_probe];\n                    ++depth;\n                }\n            }\n\n            if (!recovering) {\n                // first see if there's any chance at hitting an error recovery rule:\n                error_rule_depth = locateNearestErrorRecoveryRule(state);\n\n                // Report error\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push(\"'\"+this.terminals_[p]+\"'\");\n                    }\n                }\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol)+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == EOF ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr, {\n\t\t\t\t\t\ttext: this.lexer.match,\n\t\t\t\t\t\ttoken: this.terminals_[symbol] || symbol,\n\t\t\t\t\t\tline: this.lexer.yylineno,\n\t\t\t\t\t\tloc: yyloc,\n\t\t\t\t\t\texpected: expected,\n                        recoverable: (error_rule_depth !== false)\n\t\t\t\t});\n            } else if (preErrorSymbol !== EOF) {\n                error_rule_depth = locateNearestErrorRecoveryRule(state);\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol === EOF || preErrorSymbol === EOF) {\n                    throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            if (error_rule_depth === false) {\n                throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\n            }\n            popStack(error_rule_depth);\n\n            preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(this.lexer.yytext);\n                lstack.push(this.lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    if (recovering > 0) {\n                        recovering--;\n                    }\n                } else {\n                    // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2:\n                // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                if (ranges) {\n                  yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];\n                }\n                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3:\n                // accept\n                return true;\n        }\n\n    }\n\n    return true;\n};\n\nparser.init = function parser_init (dict) {\n    this.table = dict.table;\n    this.defaultActions = dict.defaultActions;\n    this.performAction = dict.performAction;\n    this.productions_ = dict.productions_;\n    this.symbols_ = dict.symbols_;\n    this.terminals_ = dict.terminals_;\n};\n\n/*\n * LR(0) Parser\n * */\n\nvar lr0 = generator.beget(lookaheadMixin, lrGeneratorMixin, {\n    type: \"LR(0)\",\n    afterconstructor: function lr0_afterconstructor () {\n        this.buildTable();\n    }\n});\n\nvar LR0Generator = exports.LR0Generator = lr0.construct();\n\n/*\n * Simple LALR(1)\n * */\n\nvar lalr = generator.beget(lookaheadMixin, lrGeneratorMixin, {\n    type: \"LALR(1)\",\n\n    afterconstructor: function (grammar, options) {\n        if (this.DEBUG) this.mix(lrGeneratorDebug, lalrGeneratorDebug); // mixin debug methods\n\n        options = options || {};\n        this.states = this.canonicalCollection();\n        this.terms_ = {};\n\n        var newg = this.newg = typal.beget(lookaheadMixin,{\n            oldg: this,\n            trace: this.trace,\n            nterms_: {},\n            DEBUG: false,\n            go_: function (r, B) {\n                r = r.split(\":\")[0]; // grab state #\n                B = B.map(function (b) { return b.slice(b.indexOf(\":\")+1); });\n                return this.oldg.go(r, B);\n            }\n        });\n        newg.nonterminals = {};\n        newg.productions = [];\n\n        this.inadequateStates = [];\n\n        // if true, only lookaheads in inadequate states are computed (faster, larger table)\n        // if false, lookaheads for all reductions will be computed (slower, smaller table)\n        this.onDemandLookahead = options.onDemandLookahead || false;\n\n        this.buildNewGrammar();\n        newg.computeLookaheads();\n        this.unionLookaheads();\n\n        this.table = this.parseTable(this.states);\n        this.defaultActions = findDefaults(this.table);\n    },\n\n    lookAheads: function LALR_lookaheads (state, item) {\n        return (!!this.onDemandLookahead && !state.inadequate) ? this.terminals : item.follows;\n    },\n    go: function LALR_go (p, w) {\n        var q = parseInt(p, 10);\n        for (var i=0;i<w.length;i++) {\n            q = this.states.item(q).edges[w[i]] || q;\n        }\n        return q;\n    },\n    goPath: function LALR_goPath (p, w) {\n        var q = parseInt(p, 10),t,\n            path = [];\n        for (var i=0;i<w.length;i++) {\n            t = w[i] ? q+\":\"+w[i] : '';\n            if (t) this.newg.nterms_[t] = q;\n            path.push(t);\n            q = this.states.item(q).edges[w[i]] || q;\n            this.terms_[t] = w[i];\n        }\n        return {path: path, endState: q};\n    },\n    // every disjoint reduction of a nonterminal becomes a produciton in G'\n    buildNewGrammar: function LALR_buildNewGrammar () {\n        var self = this,\n            newg = this.newg;\n\n        this.states.forEach(function (state, i) {\n            state.forEach(function (item) {\n                if (item.dotPosition === 0) {\n                    // new symbols are a combination of state and transition symbol\n                    var symbol = i+\":\"+item.production.symbol;\n                    self.terms_[symbol] = item.production.symbol;\n                    newg.nterms_[symbol] = i;\n                    if (!newg.nonterminals[symbol])\n                        newg.nonterminals[symbol] = new Nonterminal(symbol);\n                    var pathInfo = self.goPath(i, item.production.handle);\n                    var p = new Production(symbol, pathInfo.path, newg.productions.length);\n                    newg.productions.push(p);\n                    newg.nonterminals[symbol].productions.push(p);\n\n                    // store the transition that get's 'backed up to' after reduction on path\n                    var handle = item.production.handle.join(' ');\n                    var goes = self.states.item(pathInfo.endState).goes;\n                    if (!goes[handle])\n                        goes[handle] = [];\n                    goes[handle].push(symbol);\n\n                    //self.trace('new production:',p);\n                }\n            });\n            if (state.inadequate)\n                self.inadequateStates.push(i);\n        });\n    },\n    unionLookaheads: function LALR_unionLookaheads () {\n        var self = this,\n            newg = this.newg,\n            states = !!this.onDemandLookahead ? this.inadequateStates : this.states;\n\n        states.forEach(function union_states_forEach (i) {\n            var state = typeof i === 'number' ? self.states.item(i) : i,\n                follows = [];\n            if (state.reductions.length)\n            state.reductions.forEach(function union_reduction_forEach (item) {\n                var follows = {};\n                for (var k=0;k<item.follows.length;k++) {\n                    follows[item.follows[k]] = true;\n                }\n                state.goes[item.production.handle.join(' ')].forEach(function reduction_goes_forEach (symbol) {\n                    newg.nonterminals[symbol].follows.forEach(function goes_follows_forEach (symbol) {\n                        var terminal = self.terms_[symbol];\n                        if (!follows[terminal]) {\n                            follows[terminal]=true;\n                            item.follows.push(terminal);\n                        }\n                    });\n                });\n                //self.trace('unioned item', item);\n            });\n        });\n    }\n});\n\nvar LALRGenerator = exports.LALRGenerator = lalr.construct();\n\n// LALR generator debug mixin\n\nvar lalrGeneratorDebug = {\n    trace: function trace () {\n        Jison.print.apply(null, arguments);\n    },\n    beforebuildNewGrammar: function () {\n        this.trace(this.states.size()+\" states.\");\n        this.trace(\"Building lookahead grammar.\");\n    },\n    beforeunionLookaheads: function () {\n        this.trace(\"Computing lookaheads.\");\n    }\n};\n\n/*\n * Lookahead parser definitions\n *\n * Define base type\n * */\nvar lrLookaheadGenerator = generator.beget(lookaheadMixin, lrGeneratorMixin, {\n    afterconstructor: function lr_aftercontructor () {\n        this.computeLookaheads();\n        this.buildTable();\n    }\n});\n\n/*\n * SLR Parser\n * */\nvar SLRGenerator = exports.SLRGenerator = lrLookaheadGenerator.construct({\n    type: \"SLR(1)\",\n\n    lookAheads: function SLR_lookAhead (state, item) {\n        return this.nonterminals[item.production.symbol].follows;\n    }\n});\n\n\n/*\n * LR(1) Parser\n * */\nvar lr1 = lrLookaheadGenerator.beget({\n    type: \"Canonical LR(1)\",\n\n    lookAheads: function LR_lookAheads (state, item) {\n        return item.follows;\n    },\n    Item: lrGeneratorMixin.Item.prototype.construct({\n        afterconstructor: function () {\n            this.id = this.production.id+'a'+this.dotPosition+'a'+this.follows.sort().join(',');\n        },\n        eq: function (e) {\n            return e.id === this.id;\n        }\n    }),\n\n    closureOperation: function LR_ClosureOperation (itemSet /*, closureSet*/) {\n        var closureSet = new this.ItemSet();\n        var self = this;\n\n        var set = itemSet,\n            itemQueue, syms = {};\n\n        do {\n        itemQueue = new Set();\n        closureSet.concat(set);\n        set.forEach(function (item) {\n            var symbol = item.markedSymbol;\n            var b;\n\n            // if token is a nonterminal, recursively add closures\n            if (symbol && self.nonterminals[symbol]) {\n                b = self.first(item.remainingHandle());\n                if (b.length === 0 || item.production.nullable) b = b.concat(item.follows);\n                self.nonterminals[symbol].productions.forEach(function (production) {\n                    var newItem = new self.Item(production, 0, b);\n                    if(!closureSet.contains(newItem) && !itemQueue.contains(newItem)) {\n                        itemQueue.push(newItem);\n                    }\n                });\n            } else if (!symbol) {\n                // reduction\n                closureSet.reductions.push(item);\n            }\n        });\n\n        set = itemQueue;\n        } while (!itemQueue.isEmpty());\n\n        return closureSet;\n    }\n});\n\nvar LR1Generator = exports.LR1Generator = lr1.construct();\n\n/*\n * LL Parser\n * */\nvar ll = generator.beget(lookaheadMixin, {\n    type: \"LL(1)\",\n\n    afterconstructor: function ll_aftercontructor () {\n        this.computeLookaheads();\n        this.table = this.parseTable(this.productions);\n    },\n    parseTable: function llParseTable (productions) {\n        var table = {},\n            self = this;\n        productions.forEach(function (production, i) {\n            var row = table[production.symbol] || {};\n            var tokens = production.first;\n            if (self.nullable(production.handle)) {\n                Set.union(tokens, self.nonterminals[production.symbol].follows);\n            }\n            tokens.forEach(function (token) {\n                if (row[token]) {\n                    row[token].push(i);\n                    self.conflicts++;\n                } else {\n                    row[token] = [i];\n                }\n            });\n            table[production.symbol] = row;\n        });\n\n        return table;\n    }\n});\n\nvar LLGenerator = exports.LLGenerator = ll.construct();\n\nJison.Generator = function Jison_Generator (g, options) {\n    var opt = typal.mix.call({}, g.options, options);\n    switch (opt.type) {\n        case 'lr0':\n            return new LR0Generator(g, opt);\n        case 'slr':\n            return new SLRGenerator(g, opt);\n        case 'lr':\n            return new LR1Generator(g, opt);\n        case 'll':\n            return new LLGenerator(g, opt);\n        default:\n            return new LALRGenerator(g, opt);\n    }\n};\n\nreturn function Parser (g, options) {\n        var gen = Jison.Generator(g, options);\n        return gen.createParser();\n    };\n\n})();\n\n"]},"metadata":{},"sourceType":"script"}