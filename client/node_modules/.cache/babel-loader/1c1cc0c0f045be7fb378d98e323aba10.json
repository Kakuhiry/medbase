{"ast":null,"code":"/*\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n\n/*global esprima:true, define:true, exports:true, window: true,\nthrowError: true, createLiteral: true, generateStatement: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseStatement: true, parseSourceElement: true */\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(root.esprima = {});\n  }\n})(this, function (exports) {\n  'use strict';\n\n  var Token, TokenName, Syntax, PropertyKind, Messages, Regex, source, strict, index, lineNumber, lineStart, length, buffer, state, extra;\n  Token = {\n    BooleanLiteral: 1,\n    EOF: 2,\n    Identifier: 3,\n    Keyword: 4,\n    NullLiteral: 5,\n    NumericLiteral: 6,\n    Punctuator: 7,\n    StringLiteral: 8\n  };\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    ArrayExpression: 'ArrayExpression',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    Program: 'Program',\n    Property: 'Property',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SwitchStatement: 'SwitchStatement',\n    SwitchCase: 'SwitchCase',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement'\n  };\n  PropertyKind = {\n    Data: 1,\n    Get: 2,\n    Set: 4\n  }; // Error messages should be identical to V8.\n\n  Messages = {\n    UnexpectedToken: 'Unexpected token %0',\n    UnexpectedNumber: 'Unexpected number',\n    UnexpectedString: 'Unexpected string',\n    UnexpectedIdentifier: 'Unexpected identifier',\n    UnexpectedReserved: 'Unexpected reserved word',\n    UnexpectedEOS: 'Unexpected end of input',\n    NewlineAfterThrow: 'Illegal newline after throw',\n    InvalidRegExp: 'Invalid regular expression',\n    UnterminatedRegExp: 'Invalid regular expression: missing /',\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n    NoCatchOrFinally: 'Missing catch or finally after try',\n    UnknownLabel: 'Undefined label \\'%0\\'',\n    Redeclaration: '%0 \\'%1\\' has already been declared',\n    IllegalContinue: 'Illegal continue statement',\n    IllegalBreak: 'Illegal break statement',\n    IllegalReturn: 'Illegal return statement',\n    StrictModeWith: 'Strict mode code may not include a with statement',\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n    StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\n    AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\n    AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictReservedWord: 'Use of future reserved word in strict mode'\n  }; // See also tools/generate-unicode-regex.py.\n\n  Regex = {\n    NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n    NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n  }; // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n    if (!condition) {\n      throw new Error('ASSERT: ' + message);\n    }\n  }\n\n  function sliceSource(from, to) {\n    return source.slice(from, to);\n  }\n\n  if (typeof 'esprima'[0] === 'undefined') {\n    sliceSource = function sliceArraySource(from, to) {\n      return source.slice(from, to).join('');\n    };\n  }\n\n  function isDecimalDigit(ch) {\n    return '0123456789'.indexOf(ch) >= 0;\n  }\n\n  function isHexDigit(ch) {\n    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n    return '01234567'.indexOf(ch) >= 0;\n  } // 7.2 White Space\n\n\n  function isWhiteSpace(ch) {\n    return ch === ' ' || ch === '\\u0009' || ch === '\\u000B' || ch === '\\u000C' || ch === '\\u00A0' || ch.charCodeAt(0) >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(ch) >= 0;\n  } // 7.3 Line Terminators\n\n\n  function isLineTerminator(ch) {\n    return ch === '\\n' || ch === '\\r' || ch === '\\u2028' || ch === '\\u2029';\n  } // 7.6 Identifier Names and Identifiers\n\n\n  function isIdentifierStart(ch) {\n    return ch === '$' || ch === '_' || ch === '\\\\' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch.charCodeAt(0) >= 0x80 && Regex.NonAsciiIdentifierStart.test(ch);\n  }\n\n  function isIdentifierPart(ch) {\n    return ch === '$' || ch === '_' || ch === '\\\\' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch.charCodeAt(0) >= 0x80 && Regex.NonAsciiIdentifierPart.test(ch);\n  } // 7.6.1.2 Future Reserved Words\n\n\n  function isFutureReservedWord(id) {\n    switch (id) {\n      // Future reserved words.\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n        return true;\n    }\n\n    return false;\n  }\n\n  function isStrictModeReservedWord(id) {\n    switch (id) {\n      // Strict Mode reserved words.\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n        return true;\n    }\n\n    return false;\n  }\n\n  function isRestrictedWord(id) {\n    return id === 'eval' || id === 'arguments';\n  } // 7.6.1.1 Keywords\n\n\n  function isKeyword(id) {\n    var keyword = false;\n\n    switch (id.length) {\n      case 2:\n        keyword = id === 'if' || id === 'in' || id === 'do';\n        break;\n\n      case 3:\n        keyword = id === 'var' || id === 'for' || id === 'new' || id === 'try';\n        break;\n\n      case 4:\n        keyword = id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with';\n        break;\n\n      case 5:\n        keyword = id === 'while' || id === 'break' || id === 'catch' || id === 'throw';\n        break;\n\n      case 6:\n        keyword = id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch';\n        break;\n\n      case 7:\n        keyword = id === 'default' || id === 'finally';\n        break;\n\n      case 8:\n        keyword = id === 'function' || id === 'continue' || id === 'debugger';\n        break;\n\n      case 10:\n        keyword = id === 'instanceof';\n        break;\n    }\n\n    if (keyword) {\n      return true;\n    }\n\n    switch (id) {\n      // Future reserved words.\n      // 'const' is specialized as Keyword in V8.\n      case 'const':\n        return true;\n      // For compatiblity to SpiderMonkey and ES.next\n\n      case 'yield':\n      case 'let':\n        return true;\n    }\n\n    if (strict && isStrictModeReservedWord(id)) {\n      return true;\n    }\n\n    return isFutureReservedWord(id);\n  } // 7.4 Comments\n\n\n  function skipComment() {\n    var ch, blockComment, lineComment;\n    blockComment = false;\n    lineComment = false;\n\n    while (index < length) {\n      ch = source[index];\n\n      if (lineComment) {\n        ch = source[index++];\n\n        if (isLineTerminator(ch)) {\n          lineComment = false;\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n\n          ++lineNumber;\n          lineStart = index;\n        }\n      } else if (blockComment) {\n        if (isLineTerminator(ch)) {\n          if (ch === '\\r' && source[index + 1] === '\\n') {\n            ++index;\n          }\n\n          ++lineNumber;\n          ++index;\n          lineStart = index;\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n        } else {\n          ch = source[index++];\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n\n          if (ch === '*') {\n            ch = source[index];\n\n            if (ch === '/') {\n              ++index;\n              blockComment = false;\n            }\n          }\n        }\n      } else if (ch === '/') {\n        ch = source[index + 1];\n\n        if (ch === '/') {\n          index += 2;\n          lineComment = true;\n        } else if (ch === '*') {\n          index += 2;\n          blockComment = true;\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n        } else {\n          break;\n        }\n      } else if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        ++index;\n\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n\n        ++lineNumber;\n        lineStart = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  function scanHexEscape(prefix) {\n    var i,\n        len,\n        ch,\n        code = 0;\n    len = prefix === 'u' ? 4 : 2;\n\n    for (i = 0; i < len; ++i) {\n      if (index < length && isHexDigit(source[index])) {\n        ch = source[index++];\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n\n    return String.fromCharCode(code);\n  }\n\n  function scanIdentifier() {\n    var ch, start, id, restore;\n    ch = source[index];\n\n    if (!isIdentifierStart(ch)) {\n      return;\n    }\n\n    start = index;\n\n    if (ch === '\\\\') {\n      ++index;\n\n      if (source[index] !== 'u') {\n        return;\n      }\n\n      ++index;\n      restore = index;\n      ch = scanHexEscape('u');\n\n      if (ch) {\n        if (ch === '\\\\' || !isIdentifierStart(ch)) {\n          return;\n        }\n\n        id = ch;\n      } else {\n        index = restore;\n        id = 'u';\n      }\n    } else {\n      id = source[index++];\n    }\n\n    while (index < length) {\n      ch = source[index];\n\n      if (!isIdentifierPart(ch)) {\n        break;\n      }\n\n      if (ch === '\\\\') {\n        ++index;\n\n        if (source[index] !== 'u') {\n          return;\n        }\n\n        ++index;\n        restore = index;\n        ch = scanHexEscape('u');\n\n        if (ch) {\n          if (ch === '\\\\' || !isIdentifierPart(ch)) {\n            return;\n          }\n\n          id += ch;\n        } else {\n          index = restore;\n          id += 'u';\n        }\n      } else {\n        id += source[index++];\n      }\n    } // There is no keyword or literal with only one character.\n    // Thus, it must be an identifier.\n\n\n    if (id.length === 1) {\n      return {\n        type: Token.Identifier,\n        value: id,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (isKeyword(id)) {\n      return {\n        type: Token.Keyword,\n        value: id,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    } // 7.8.1 Null Literals\n\n\n    if (id === 'null') {\n      return {\n        type: Token.NullLiteral,\n        value: id,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    } // 7.8.2 Boolean Literals\n\n\n    if (id === 'true' || id === 'false') {\n      return {\n        type: Token.BooleanLiteral,\n        value: id,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    return {\n      type: Token.Identifier,\n      value: id,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  } // 7.7 Punctuators\n\n\n  function scanPunctuator() {\n    var start = index,\n        ch1 = source[index],\n        ch2,\n        ch3,\n        ch4; // Check for most common single-character punctuators.\n\n    if (ch1 === ';' || ch1 === '{' || ch1 === '}') {\n      ++index;\n      return {\n        type: Token.Punctuator,\n        value: ch1,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (ch1 === ',' || ch1 === '(' || ch1 === ')') {\n      ++index;\n      return {\n        type: Token.Punctuator,\n        value: ch1,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    } // Dot (.) can also start a floating-point number, hence the need\n    // to check the next character.\n\n\n    ch2 = source[index + 1];\n\n    if (ch1 === '.' && !isDecimalDigit(ch2)) {\n      return {\n        type: Token.Punctuator,\n        value: source[index++],\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    } // Peek more characters.\n\n\n    ch3 = source[index + 2];\n    ch4 = source[index + 3]; // 4-character punctuator: >>>=\n\n    if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n      if (ch4 === '=') {\n        index += 4;\n        return {\n          type: Token.Punctuator,\n          value: '>>>=',\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          range: [start, index]\n        };\n      }\n    } // 3-character punctuators: === !== >>> <<= >>=\n\n\n    if (ch1 === '=' && ch2 === '=' && ch3 === '=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '===',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (ch1 === '!' && ch2 === '=' && ch3 === '=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '!==',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '>>>',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '<<=',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '>>=',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    } // 2-character punctuators: <= >= == != ++ -- << >> && ||\n    // += -= *= %= &= |= ^= /=\n\n\n    if (ch2 === '=') {\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n        index += 2;\n        return {\n          type: Token.Punctuator,\n          value: ch1 + ch2,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          range: [start, index]\n        };\n      }\n    }\n\n    if (ch1 === ch2 && '+-<>&|'.indexOf(ch1) >= 0) {\n      if ('+-<>&|'.indexOf(ch2) >= 0) {\n        index += 2;\n        return {\n          type: Token.Punctuator,\n          value: ch1 + ch2,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          range: [start, index]\n        };\n      }\n    } // The remaining 1-character punctuators.\n\n\n    if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {\n      return {\n        type: Token.Punctuator,\n        value: source[index++],\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n  } // 7.8.3 Numeric Literals\n\n\n  function scanNumericLiteral() {\n    var number, start, ch;\n    ch = source[index];\n    assert(isDecimalDigit(ch) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n    start = index;\n    number = '';\n\n    if (ch !== '.') {\n      number = source[index++];\n      ch = source[index]; // Hex number starts with '0x'.\n      // Octal number starts with '0'.\n\n      if (number === '0') {\n        if (ch === 'x' || ch === 'X') {\n          number += source[index++];\n\n          while (index < length) {\n            ch = source[index];\n\n            if (!isHexDigit(ch)) {\n              break;\n            }\n\n            number += source[index++];\n          }\n\n          if (number.length <= 2) {\n            // only 0x\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n\n          if (index < length) {\n            ch = source[index];\n\n            if (isIdentifierStart(ch)) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n          }\n\n          return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n          };\n        } else if (isOctalDigit(ch)) {\n          number += source[index++];\n\n          while (index < length) {\n            ch = source[index];\n\n            if (!isOctalDigit(ch)) {\n              break;\n            }\n\n            number += source[index++];\n          }\n\n          if (index < length) {\n            ch = source[index];\n\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n          }\n\n          return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: true,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n          };\n        } // decimal number starts with '0' such as '09' is illegal.\n\n\n        if (isDecimalDigit(ch)) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n      }\n\n      while (index < length) {\n        ch = source[index];\n\n        if (!isDecimalDigit(ch)) {\n          break;\n        }\n\n        number += source[index++];\n      }\n    }\n\n    if (ch === '.') {\n      number += source[index++];\n\n      while (index < length) {\n        ch = source[index];\n\n        if (!isDecimalDigit(ch)) {\n          break;\n        }\n\n        number += source[index++];\n      }\n    }\n\n    if (ch === 'e' || ch === 'E') {\n      number += source[index++];\n      ch = source[index];\n\n      if (ch === '+' || ch === '-') {\n        number += source[index++];\n      }\n\n      ch = source[index];\n\n      if (isDecimalDigit(ch)) {\n        number += source[index++];\n\n        while (index < length) {\n          ch = source[index];\n\n          if (!isDecimalDigit(ch)) {\n            break;\n          }\n\n          number += source[index++];\n        }\n      } else {\n        ch = 'character ' + ch;\n\n        if (index >= length) {\n          ch = '<end>';\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n    }\n\n    if (index < length) {\n      ch = source[index];\n\n      if (isIdentifierStart(ch)) {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseFloat(number),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  } // 7.8.4 String Literals\n\n\n  function scanStringLiteral() {\n    var str = '',\n        quote,\n        start,\n        ch,\n        code,\n        unescaped,\n        restore,\n        octal = false;\n    quote = source[index];\n    assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n    start = index;\n    ++index;\n\n    while (index < length) {\n      ch = source[index++];\n\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n\n        if (!isLineTerminator(ch)) {\n          switch (ch) {\n            case 'n':\n              str += '\\n';\n              break;\n\n            case 'r':\n              str += '\\r';\n              break;\n\n            case 't':\n              str += '\\t';\n              break;\n\n            case 'u':\n            case 'x':\n              restore = index;\n              unescaped = scanHexEscape(ch);\n\n              if (unescaped) {\n                str += unescaped;\n              } else {\n                index = restore;\n                str += ch;\n              }\n\n              break;\n\n            case 'b':\n              str += '\\b';\n              break;\n\n            case 'f':\n              str += '\\f';\n              break;\n\n            case 'v':\n              str += '\\x0B';\n              break;\n\n            default:\n              if (isOctalDigit(ch)) {\n                code = '01234567'.indexOf(ch); // \\0 is not octal escape sequence\n\n                if (code !== 0) {\n                  octal = true;\n                }\n\n                if (index < length && isOctalDigit(source[index])) {\n                  octal = true;\n                  code = code * 8 + '01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts\n                  // with 0, 1, 2, 3\n\n                  if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                  }\n                }\n\n                str += String.fromCharCode(code);\n              } else {\n                str += ch;\n              }\n\n              break;\n          }\n        } else {\n          ++lineNumber;\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n        }\n      } else if (isLineTerminator(ch)) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (quote !== '') {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    return {\n      type: Token.StringLiteral,\n      value: str,\n      octal: octal,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n\n  function scanRegExp() {\n    var str,\n        ch,\n        start,\n        pattern,\n        flags,\n        value,\n        classMarker = false,\n        restore,\n        terminated = false;\n    buffer = null;\n    skipComment();\n    start = index;\n    ch = source[index];\n    assert(ch === '/', 'Regular expression literal must start with a slash');\n    str = source[index++];\n\n    while (index < length) {\n      ch = source[index++];\n      str += ch;\n\n      if (ch === '\\\\') {\n        ch = source[index++]; // ECMA-262 7.8.5\n\n        if (isLineTerminator(ch)) {\n          throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        str += ch;\n      } else if (classMarker) {\n        if (ch === ']') {\n          classMarker = false;\n        }\n      } else {\n        if (ch === '/') {\n          terminated = true;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        } else if (isLineTerminator(ch)) {\n          throwError({}, Messages.UnterminatedRegExp);\n        }\n      }\n    }\n\n    if (!terminated) {\n      throwError({}, Messages.UnterminatedRegExp);\n    } // Exclude leading and trailing slash.\n\n\n    pattern = str.substr(1, str.length - 2);\n    flags = '';\n\n    while (index < length) {\n      ch = source[index];\n\n      if (!isIdentifierPart(ch)) {\n        break;\n      }\n\n      ++index;\n\n      if (ch === '\\\\' && index < length) {\n        ch = source[index];\n\n        if (ch === 'u') {\n          ++index;\n          restore = index;\n          ch = scanHexEscape('u');\n\n          if (ch) {\n            flags += ch;\n            str += '\\\\u';\n\n            for (; restore < index; ++restore) {\n              str += source[restore];\n            }\n          } else {\n            index = restore;\n            flags += 'u';\n            str += '\\\\u';\n          }\n        } else {\n          str += '\\\\';\n        }\n      } else {\n        flags += ch;\n        str += ch;\n      }\n    }\n\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      throwError({}, Messages.InvalidRegExp);\n    }\n\n    return {\n      literal: str,\n      value: value,\n      range: [start, index]\n    };\n  }\n\n  function isIdentifierName(token) {\n    return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;\n  }\n\n  function advance() {\n    var ch, token;\n    skipComment();\n\n    if (index >= length) {\n      return {\n        type: Token.EOF,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [index, index]\n      };\n    }\n\n    token = scanPunctuator();\n\n    if (typeof token !== 'undefined') {\n      return token;\n    }\n\n    ch = source[index];\n\n    if (ch === '\\'' || ch === '\"') {\n      return scanStringLiteral();\n    }\n\n    if (ch === '.' || isDecimalDigit(ch)) {\n      return scanNumericLiteral();\n    }\n\n    token = scanIdentifier();\n\n    if (typeof token !== 'undefined') {\n      return token;\n    }\n\n    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  function lex() {\n    var token;\n\n    if (buffer) {\n      index = buffer.range[1];\n      lineNumber = buffer.lineNumber;\n      lineStart = buffer.lineStart;\n      token = buffer;\n      buffer = null;\n      return token;\n    }\n\n    buffer = null;\n    return advance();\n  }\n\n  function lookahead() {\n    var pos, line, start;\n\n    if (buffer !== null) {\n      return buffer;\n    }\n\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n    buffer = advance();\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n    return buffer;\n  } // Return true if there is a line terminator before the next token.\n\n\n  function peekLineTerminator() {\n    var pos, line, start, found;\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n    skipComment();\n    found = lineNumber !== line;\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n    return found;\n  } // Throw an exception\n\n\n  function throwError(token, messageFormat) {\n    var error,\n        args = Array.prototype.slice.call(arguments, 2),\n        msg = messageFormat.replace(/%(\\d)/g, function (whole, index) {\n      return args[index] || '';\n    });\n\n    if (typeof token.lineNumber === 'number') {\n      error = new Error('Line ' + token.lineNumber + ': ' + msg);\n      error.index = token.range[0];\n      error.lineNumber = token.lineNumber;\n      error.column = token.range[0] - lineStart + 1;\n    } else {\n      error = new Error('Line ' + lineNumber + ': ' + msg);\n      error.index = index;\n      error.lineNumber = lineNumber;\n      error.column = index - lineStart + 1;\n    }\n\n    throw error;\n  }\n\n  function throwErrorTolerant() {\n    try {\n      throwError.apply(null, arguments);\n    } catch (e) {\n      if (extra.errors) {\n        extra.errors.push(e);\n      } else {\n        throw e;\n      }\n    }\n  } // Throw an exception because of the token.\n\n\n  function throwUnexpected(token) {\n    if (token.type === Token.EOF) {\n      throwError(token, Messages.UnexpectedEOS);\n    }\n\n    if (token.type === Token.NumericLiteral) {\n      throwError(token, Messages.UnexpectedNumber);\n    }\n\n    if (token.type === Token.StringLiteral) {\n      throwError(token, Messages.UnexpectedString);\n    }\n\n    if (token.type === Token.Identifier) {\n      throwError(token, Messages.UnexpectedIdentifier);\n    }\n\n    if (token.type === Token.Keyword) {\n      if (isFutureReservedWord(token.value)) {\n        throwError(token, Messages.UnexpectedReserved);\n      } else if (strict && isStrictModeReservedWord(token.value)) {\n        throwErrorTolerant(token, Messages.StrictReservedWord);\n        return;\n      }\n\n      throwError(token, Messages.UnexpectedToken, token.value);\n    } // BooleanLiteral, NullLiteral, or Punctuator.\n\n\n    throwError(token, Messages.UnexpectedToken, token.value);\n  } // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n\n  function expect(value) {\n    var token = lex();\n\n    if (token.type !== Token.Punctuator || token.value !== value) {\n      throwUnexpected(token);\n    }\n  } // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n\n  function expectKeyword(keyword) {\n    var token = lex();\n\n    if (token.type !== Token.Keyword || token.value !== keyword) {\n      throwUnexpected(token);\n    }\n  } // Return true if the next token matches the specified punctuator.\n\n\n  function match(value) {\n    var token = lookahead();\n    return token.type === Token.Punctuator && token.value === value;\n  } // Return true if the next token matches the specified keyword\n\n\n  function matchKeyword(keyword) {\n    var token = lookahead();\n    return token.type === Token.Keyword && token.value === keyword;\n  } // Return true if the next token is an assignment operator\n\n\n  function matchAssign() {\n    var token = lookahead(),\n        op = token.value;\n\n    if (token.type !== Token.Punctuator) {\n      return false;\n    }\n\n    return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';\n  }\n\n  function consumeSemicolon() {\n    var token, line; // Catch the very common case first.\n\n    if (source[index] === ';') {\n      lex();\n      return;\n    }\n\n    line = lineNumber;\n    skipComment();\n\n    if (lineNumber !== line) {\n      return;\n    }\n\n    if (match(';')) {\n      lex();\n      return;\n    }\n\n    token = lookahead();\n\n    if (token.type !== Token.EOF && !match('}')) {\n      throwUnexpected(token);\n    }\n  } // Return true if provided expression is LeftHandSideExpression\n\n\n  function isLeftHandSide(expr) {\n    return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  } // 11.1.4 Array Initialiser\n\n\n  function parseArrayInitialiser() {\n    var elements = [];\n    expect('[');\n\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else {\n        elements.push(parseAssignmentExpression());\n\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n\n    expect(']');\n    return {\n      type: Syntax.ArrayExpression,\n      elements: elements\n    };\n  } // 11.1.5 Object Initialiser\n\n\n  function parsePropertyFunction(param, first) {\n    var previousStrict, body;\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (first && strict && isRestrictedWord(param[0].name)) {\n      throwErrorTolerant(first, Messages.StrictParamName);\n    }\n\n    strict = previousStrict;\n    return {\n      type: Syntax.FunctionExpression,\n      id: null,\n      params: param,\n      defaults: [],\n      body: body,\n      rest: null,\n      generator: false,\n      expression: false\n    };\n  }\n\n  function parseObjectPropertyKey() {\n    var token = lex(); // Note: This function is called only from parseObjectProperty(), where\n    // EOF and Punctuator tokens are already filtered out.\n\n    if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n      if (strict && token.octal) {\n        throwErrorTolerant(token, Messages.StrictOctalLiteral);\n      }\n\n      return createLiteral(token);\n    }\n\n    return {\n      type: Syntax.Identifier,\n      name: token.value\n    };\n  }\n\n  function parseObjectProperty() {\n    var token, key, id, param;\n    token = lookahead();\n\n    if (token.type === Token.Identifier) {\n      id = parseObjectPropertyKey(); // Property Assignment: Getter and Setter.\n\n      if (token.value === 'get' && !match(':')) {\n        key = parseObjectPropertyKey();\n        expect('(');\n        expect(')');\n        return {\n          type: Syntax.Property,\n          key: key,\n          value: parsePropertyFunction([]),\n          kind: 'get'\n        };\n      } else if (token.value === 'set' && !match(':')) {\n        key = parseObjectPropertyKey();\n        expect('(');\n        token = lookahead();\n\n        if (token.type !== Token.Identifier) {\n          expect(')');\n          throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          return {\n            type: Syntax.Property,\n            key: key,\n            value: parsePropertyFunction([]),\n            kind: 'set'\n          };\n        } else {\n          param = [parseVariableIdentifier()];\n          expect(')');\n          return {\n            type: Syntax.Property,\n            key: key,\n            value: parsePropertyFunction(param, token),\n            kind: 'set'\n          };\n        }\n      } else {\n        expect(':');\n        return {\n          type: Syntax.Property,\n          key: id,\n          value: parseAssignmentExpression(),\n          kind: 'init'\n        };\n      }\n    } else if (token.type === Token.EOF || token.type === Token.Punctuator) {\n      throwUnexpected(token);\n    } else {\n      key = parseObjectPropertyKey();\n      expect(':');\n      return {\n        type: Syntax.Property,\n        key: key,\n        value: parseAssignmentExpression(),\n        kind: 'init'\n      };\n    }\n  }\n\n  function parseObjectInitialiser() {\n    var properties = [],\n        property,\n        name,\n        kind,\n        map = {},\n        toString = String;\n    expect('{');\n\n    while (!match('}')) {\n      property = parseObjectProperty();\n\n      if (property.key.type === Syntax.Identifier) {\n        name = property.key.name;\n      } else {\n        name = toString(property.key.value);\n      }\n\n      kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;\n\n      if (Object.prototype.hasOwnProperty.call(map, name)) {\n        if (map[name] === PropertyKind.Data) {\n          if (strict && kind === PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n          } else if (kind !== PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.AccessorDataProperty);\n          }\n        } else {\n          if (kind === PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.AccessorDataProperty);\n          } else if (map[name] & kind) {\n            throwErrorTolerant({}, Messages.AccessorGetSet);\n          }\n        }\n\n        map[name] |= kind;\n      } else {\n        map[name] = kind;\n      }\n\n      properties.push(property);\n\n      if (!match('}')) {\n        expect(',');\n      }\n    }\n\n    expect('}');\n    return {\n      type: Syntax.ObjectExpression,\n      properties: properties\n    };\n  } // 11.1.6 The Grouping Operator\n\n\n  function parseGroupExpression() {\n    var expr;\n    expect('(');\n    expr = parseExpression();\n    expect(')');\n    return expr;\n  } // 11.1 Primary Expressions\n\n\n  function parsePrimaryExpression() {\n    var token = lookahead(),\n        type = token.type;\n\n    if (type === Token.Identifier) {\n      return {\n        type: Syntax.Identifier,\n        name: lex().value\n      };\n    }\n\n    if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n      if (strict && token.octal) {\n        throwErrorTolerant(token, Messages.StrictOctalLiteral);\n      }\n\n      return createLiteral(lex());\n    }\n\n    if (type === Token.Keyword) {\n      if (matchKeyword('this')) {\n        lex();\n        return {\n          type: Syntax.ThisExpression\n        };\n      }\n\n      if (matchKeyword('function')) {\n        return parseFunctionExpression();\n      }\n    }\n\n    if (type === Token.BooleanLiteral) {\n      lex();\n      token.value = token.value === 'true';\n      return createLiteral(token);\n    }\n\n    if (type === Token.NullLiteral) {\n      lex();\n      token.value = null;\n      return createLiteral(token);\n    }\n\n    if (match('[')) {\n      return parseArrayInitialiser();\n    }\n\n    if (match('{')) {\n      return parseObjectInitialiser();\n    }\n\n    if (match('(')) {\n      return parseGroupExpression();\n    }\n\n    if (match('/') || match('/=')) {\n      return createLiteral(scanRegExp());\n    }\n\n    return throwUnexpected(lex());\n  } // 11.2 Left-Hand-Side Expressions\n\n\n  function parseArguments() {\n    var args = [];\n    expect('(');\n\n    if (!match(')')) {\n      while (index < length) {\n        args.push(parseAssignmentExpression());\n\n        if (match(')')) {\n          break;\n        }\n\n        expect(',');\n      }\n    }\n\n    expect(')');\n    return args;\n  }\n\n  function parseNonComputedProperty() {\n    var token = lex();\n\n    if (!isIdentifierName(token)) {\n      throwUnexpected(token);\n    }\n\n    return {\n      type: Syntax.Identifier,\n      name: token.value\n    };\n  }\n\n  function parseNonComputedMember() {\n    expect('.');\n    return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n    var expr;\n    expect('[');\n    expr = parseExpression();\n    expect(']');\n    return expr;\n  }\n\n  function parseNewExpression() {\n    var expr;\n    expectKeyword('new');\n    expr = {\n      type: Syntax.NewExpression,\n      callee: parseLeftHandSideExpression(),\n      'arguments': []\n    };\n\n    if (match('(')) {\n      expr['arguments'] = parseArguments();\n    }\n\n    return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n    var expr;\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n    while (match('.') || match('[') || match('(')) {\n      if (match('(')) {\n        expr = {\n          type: Syntax.CallExpression,\n          callee: expr,\n          'arguments': parseArguments()\n        };\n      } else if (match('[')) {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: true,\n          object: expr,\n          property: parseComputedMember()\n        };\n      } else {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: false,\n          object: expr,\n          property: parseNonComputedMember()\n        };\n      }\n    }\n\n    return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n    var expr;\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n    while (match('.') || match('[')) {\n      if (match('[')) {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: true,\n          object: expr,\n          property: parseComputedMember()\n        };\n      } else {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: false,\n          object: expr,\n          property: parseNonComputedMember()\n        };\n      }\n    }\n\n    return expr;\n  } // 11.3 Postfix Expressions\n\n\n  function parsePostfixExpression() {\n    var expr = parseLeftHandSideExpressionAllowCall(),\n        token;\n    token = lookahead();\n\n    if (token.type !== Token.Punctuator) {\n      return expr;\n    }\n\n    if ((match('++') || match('--')) && !peekLineTerminator()) {\n      // 11.3.1, 11.3.2\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant({}, Messages.StrictLHSPostfix);\n      }\n\n      if (!isLeftHandSide(expr)) {\n        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n      }\n\n      expr = {\n        type: Syntax.UpdateExpression,\n        operator: lex().value,\n        argument: expr,\n        prefix: false\n      };\n    }\n\n    return expr;\n  } // 11.4 Unary Operators\n\n\n  function parseUnaryExpression() {\n    var token, expr;\n    token = lookahead();\n\n    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n      return parsePostfixExpression();\n    }\n\n    if (match('++') || match('--')) {\n      token = lex();\n      expr = parseUnaryExpression(); // 11.4.4, 11.4.5\n\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant({}, Messages.StrictLHSPrefix);\n      }\n\n      if (!isLeftHandSide(expr)) {\n        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n      }\n\n      expr = {\n        type: Syntax.UpdateExpression,\n        operator: token.value,\n        argument: expr,\n        prefix: true\n      };\n      return expr;\n    }\n\n    if (match('+') || match('-') || match('~') || match('!')) {\n      expr = {\n        type: Syntax.UnaryExpression,\n        operator: lex().value,\n        argument: parseUnaryExpression(),\n        prefix: true\n      };\n      return expr;\n    }\n\n    if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n      expr = {\n        type: Syntax.UnaryExpression,\n        operator: lex().value,\n        argument: parseUnaryExpression(),\n        prefix: true\n      };\n\n      if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n        throwErrorTolerant({}, Messages.StrictDelete);\n      }\n\n      return expr;\n    }\n\n    return parsePostfixExpression();\n  } // 11.5 Multiplicative Operators\n\n\n  function parseMultiplicativeExpression() {\n    var expr = parseUnaryExpression();\n\n    while (match('*') || match('/') || match('%')) {\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseUnaryExpression()\n      };\n    }\n\n    return expr;\n  } // 11.6 Additive Operators\n\n\n  function parseAdditiveExpression() {\n    var expr = parseMultiplicativeExpression();\n\n    while (match('+') || match('-')) {\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseMultiplicativeExpression()\n      };\n    }\n\n    return expr;\n  } // 11.7 Bitwise Shift Operators\n\n\n  function parseShiftExpression() {\n    var expr = parseAdditiveExpression();\n\n    while (match('<<') || match('>>') || match('>>>')) {\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseAdditiveExpression()\n      };\n    }\n\n    return expr;\n  } // 11.8 Relational Operators\n\n\n  function parseRelationalExpression() {\n    var expr, previousAllowIn;\n    previousAllowIn = state.allowIn;\n    state.allowIn = true;\n    expr = parseShiftExpression();\n\n    while (match('<') || match('>') || match('<=') || match('>=') || previousAllowIn && matchKeyword('in') || matchKeyword('instanceof')) {\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseShiftExpression()\n      };\n    }\n\n    state.allowIn = previousAllowIn;\n    return expr;\n  } // 11.9 Equality Operators\n\n\n  function parseEqualityExpression() {\n    var expr = parseRelationalExpression();\n\n    while (match('==') || match('!=') || match('===') || match('!==')) {\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseRelationalExpression()\n      };\n    }\n\n    return expr;\n  } // 11.10 Binary Bitwise Operators\n\n\n  function parseBitwiseANDExpression() {\n    var expr = parseEqualityExpression();\n\n    while (match('&')) {\n      lex();\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: '&',\n        left: expr,\n        right: parseEqualityExpression()\n      };\n    }\n\n    return expr;\n  }\n\n  function parseBitwiseXORExpression() {\n    var expr = parseBitwiseANDExpression();\n\n    while (match('^')) {\n      lex();\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: '^',\n        left: expr,\n        right: parseBitwiseANDExpression()\n      };\n    }\n\n    return expr;\n  }\n\n  function parseBitwiseORExpression() {\n    var expr = parseBitwiseXORExpression();\n\n    while (match('|')) {\n      lex();\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: '|',\n        left: expr,\n        right: parseBitwiseXORExpression()\n      };\n    }\n\n    return expr;\n  } // 11.11 Binary Logical Operators\n\n\n  function parseLogicalANDExpression() {\n    var expr = parseBitwiseORExpression();\n\n    while (match('&&')) {\n      lex();\n      expr = {\n        type: Syntax.LogicalExpression,\n        operator: '&&',\n        left: expr,\n        right: parseBitwiseORExpression()\n      };\n    }\n\n    return expr;\n  }\n\n  function parseLogicalORExpression() {\n    var expr = parseLogicalANDExpression();\n\n    while (match('||')) {\n      lex();\n      expr = {\n        type: Syntax.LogicalExpression,\n        operator: '||',\n        left: expr,\n        right: parseLogicalANDExpression()\n      };\n    }\n\n    return expr;\n  } // 11.12 Conditional Operator\n\n\n  function parseConditionalExpression() {\n    var expr, previousAllowIn, consequent;\n    expr = parseLogicalORExpression();\n\n    if (match('?')) {\n      lex();\n      previousAllowIn = state.allowIn;\n      state.allowIn = true;\n      consequent = parseAssignmentExpression();\n      state.allowIn = previousAllowIn;\n      expect(':');\n      expr = {\n        type: Syntax.ConditionalExpression,\n        test: expr,\n        consequent: consequent,\n        alternate: parseAssignmentExpression()\n      };\n    }\n\n    return expr;\n  } // 11.13 Assignment Operators\n\n\n  function parseAssignmentExpression() {\n    var token, expr;\n    token = lookahead();\n    expr = parseConditionalExpression();\n\n    if (matchAssign()) {\n      // LeftHandSideExpression\n      if (!isLeftHandSide(expr)) {\n        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n      } // 11.13.1\n\n\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant(token, Messages.StrictLHSAssignment);\n      }\n\n      expr = {\n        type: Syntax.AssignmentExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseAssignmentExpression()\n      };\n    }\n\n    return expr;\n  } // 11.14 Comma Operator\n\n\n  function parseExpression() {\n    var expr = parseAssignmentExpression();\n\n    if (match(',')) {\n      expr = {\n        type: Syntax.SequenceExpression,\n        expressions: [expr]\n      };\n\n      while (index < length) {\n        if (!match(',')) {\n          break;\n        }\n\n        lex();\n        expr.expressions.push(parseAssignmentExpression());\n      }\n    }\n\n    return expr;\n  } // 12.1 Block\n\n\n  function parseStatementList() {\n    var list = [],\n        statement;\n\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n\n      statement = parseSourceElement();\n\n      if (typeof statement === 'undefined') {\n        break;\n      }\n\n      list.push(statement);\n    }\n\n    return list;\n  }\n\n  function parseBlock() {\n    var block;\n    expect('{');\n    block = parseStatementList();\n    expect('}');\n    return {\n      type: Syntax.BlockStatement,\n      body: block\n    };\n  } // 12.2 Variable Statement\n\n\n  function parseVariableIdentifier() {\n    var token = lex();\n\n    if (token.type !== Token.Identifier) {\n      throwUnexpected(token);\n    }\n\n    return {\n      type: Syntax.Identifier,\n      name: token.value\n    };\n  }\n\n  function parseVariableDeclaration(kind) {\n    var id = parseVariableIdentifier(),\n        init = null; // 12.2.1\n\n    if (strict && isRestrictedWord(id.name)) {\n      throwErrorTolerant({}, Messages.StrictVarName);\n    }\n\n    if (kind === 'const') {\n      expect('=');\n      init = parseAssignmentExpression();\n    } else if (match('=')) {\n      lex();\n      init = parseAssignmentExpression();\n    }\n\n    return {\n      type: Syntax.VariableDeclarator,\n      id: id,\n      init: init\n    };\n  }\n\n  function parseVariableDeclarationList(kind) {\n    var list = [];\n\n    do {\n      list.push(parseVariableDeclaration(kind));\n\n      if (!match(',')) {\n        break;\n      }\n\n      lex();\n    } while (index < length);\n\n    return list;\n  }\n\n  function parseVariableStatement() {\n    var declarations;\n    expectKeyword('var');\n    declarations = parseVariableDeclarationList();\n    consumeSemicolon();\n    return {\n      type: Syntax.VariableDeclaration,\n      declarations: declarations,\n      kind: 'var'\n    };\n  } // kind may be `const` or `let`\n  // Both are experimental and not in the specification yet.\n  // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n  // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n\n\n  function parseConstLetDeclaration(kind) {\n    var declarations;\n    expectKeyword(kind);\n    declarations = parseVariableDeclarationList(kind);\n    consumeSemicolon();\n    return {\n      type: Syntax.VariableDeclaration,\n      declarations: declarations,\n      kind: kind\n    };\n  } // 12.3 Empty Statement\n\n\n  function parseEmptyStatement() {\n    expect(';');\n    return {\n      type: Syntax.EmptyStatement\n    };\n  } // 12.4 Expression Statement\n\n\n  function parseExpressionStatement() {\n    var expr = parseExpression();\n    consumeSemicolon();\n    return {\n      type: Syntax.ExpressionStatement,\n      expression: expr\n    };\n  } // 12.5 If statement\n\n\n  function parseIfStatement() {\n    var test, consequent, alternate;\n    expectKeyword('if');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    consequent = parseStatement();\n\n    if (matchKeyword('else')) {\n      lex();\n      alternate = parseStatement();\n    } else {\n      alternate = null;\n    }\n\n    return {\n      type: Syntax.IfStatement,\n      test: test,\n      consequent: consequent,\n      alternate: alternate\n    };\n  } // 12.6 Iteration Statements\n\n\n  function parseDoWhileStatement() {\n    var body, test, oldInIteration;\n    expectKeyword('do');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n\n    if (match(';')) {\n      lex();\n    }\n\n    return {\n      type: Syntax.DoWhileStatement,\n      body: body,\n      test: test\n    };\n  }\n\n  function parseWhileStatement() {\n    var test, body, oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return {\n      type: Syntax.WhileStatement,\n      test: test,\n      body: body\n    };\n  }\n\n  function parseForVariableDeclaration() {\n    var token = lex();\n    return {\n      type: Syntax.VariableDeclaration,\n      declarations: parseVariableDeclarationList(),\n      kind: token.value\n    };\n  }\n\n  function parseForStatement() {\n    var init, test, update, left, right, body, oldInIteration;\n    init = test = update = null;\n    expectKeyword('for');\n    expect('(');\n\n    if (match(';')) {\n      lex();\n    } else {\n      if (matchKeyword('var') || matchKeyword('let')) {\n        state.allowIn = false;\n        init = parseForVariableDeclaration();\n        state.allowIn = true;\n\n        if (init.declarations.length === 1 && matchKeyword('in')) {\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        }\n      } else {\n        state.allowIn = false;\n        init = parseExpression();\n        state.allowIn = true;\n\n        if (matchKeyword('in')) {\n          // LeftHandSideExpression\n          if (!isLeftHandSide(init)) {\n            throwErrorTolerant({}, Messages.InvalidLHSInForIn);\n          }\n\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        }\n      }\n\n      if (typeof left === 'undefined') {\n        expect(';');\n      }\n    }\n\n    if (typeof left === 'undefined') {\n      if (!match(';')) {\n        test = parseExpression();\n      }\n\n      expect(';');\n\n      if (!match(')')) {\n        update = parseExpression();\n      }\n    }\n\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n\n    if (typeof left === 'undefined') {\n      return {\n        type: Syntax.ForStatement,\n        init: init,\n        test: test,\n        update: update,\n        body: body\n      };\n    }\n\n    return {\n      type: Syntax.ForInStatement,\n      left: left,\n      right: right,\n      body: body,\n      each: false\n    };\n  } // 12.7 The continue statement\n\n\n  function parseContinueStatement() {\n    var token,\n        label = null;\n    expectKeyword('continue'); // Optimize the most common form: 'continue;'.\n\n    if (source[index] === ';') {\n      lex();\n\n      if (!state.inIteration) {\n        throwError({}, Messages.IllegalContinue);\n      }\n\n      return {\n        type: Syntax.ContinueStatement,\n        label: null\n      };\n    }\n\n    if (peekLineTerminator()) {\n      if (!state.inIteration) {\n        throwError({}, Messages.IllegalContinue);\n      }\n\n      return {\n        type: Syntax.ContinueStatement,\n        label: null\n      };\n    }\n\n    token = lookahead();\n\n    if (token.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n        throwError({}, Messages.UnknownLabel, label.name);\n      }\n    }\n\n    consumeSemicolon();\n\n    if (label === null && !state.inIteration) {\n      throwError({}, Messages.IllegalContinue);\n    }\n\n    return {\n      type: Syntax.ContinueStatement,\n      label: label\n    };\n  } // 12.8 The break statement\n\n\n  function parseBreakStatement() {\n    var token,\n        label = null;\n    expectKeyword('break'); // Optimize the most common form: 'break;'.\n\n    if (source[index] === ';') {\n      lex();\n\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError({}, Messages.IllegalBreak);\n      }\n\n      return {\n        type: Syntax.BreakStatement,\n        label: null\n      };\n    }\n\n    if (peekLineTerminator()) {\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError({}, Messages.IllegalBreak);\n      }\n\n      return {\n        type: Syntax.BreakStatement,\n        label: null\n      };\n    }\n\n    token = lookahead();\n\n    if (token.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n        throwError({}, Messages.UnknownLabel, label.name);\n      }\n    }\n\n    consumeSemicolon();\n\n    if (label === null && !(state.inIteration || state.inSwitch)) {\n      throwError({}, Messages.IllegalBreak);\n    }\n\n    return {\n      type: Syntax.BreakStatement,\n      label: label\n    };\n  } // 12.9 The return statement\n\n\n  function parseReturnStatement() {\n    var token,\n        argument = null;\n    expectKeyword('return');\n\n    if (!state.inFunctionBody) {\n      throwErrorTolerant({}, Messages.IllegalReturn);\n    } // 'return' followed by a space and an identifier is very common.\n\n\n    if (source[index] === ' ') {\n      if (isIdentifierStart(source[index + 1])) {\n        argument = parseExpression();\n        consumeSemicolon();\n        return {\n          type: Syntax.ReturnStatement,\n          argument: argument\n        };\n      }\n    }\n\n    if (peekLineTerminator()) {\n      return {\n        type: Syntax.ReturnStatement,\n        argument: null\n      };\n    }\n\n    if (!match(';')) {\n      token = lookahead();\n\n      if (!match('}') && token.type !== Token.EOF) {\n        argument = parseExpression();\n      }\n    }\n\n    consumeSemicolon();\n    return {\n      type: Syntax.ReturnStatement,\n      argument: argument\n    };\n  } // 12.10 The with statement\n\n\n  function parseWithStatement() {\n    var object, body;\n\n    if (strict) {\n      throwErrorTolerant({}, Messages.StrictModeWith);\n    }\n\n    expectKeyword('with');\n    expect('(');\n    object = parseExpression();\n    expect(')');\n    body = parseStatement();\n    return {\n      type: Syntax.WithStatement,\n      object: object,\n      body: body\n    };\n  } // 12.10 The swith statement\n\n\n  function parseSwitchCase() {\n    var test,\n        consequent = [],\n        statement;\n\n    if (matchKeyword('default')) {\n      lex();\n      test = null;\n    } else {\n      expectKeyword('case');\n      test = parseExpression();\n    }\n\n    expect(':');\n\n    while (index < length) {\n      if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n        break;\n      }\n\n      statement = parseStatement();\n\n      if (typeof statement === 'undefined') {\n        break;\n      }\n\n      consequent.push(statement);\n    }\n\n    return {\n      type: Syntax.SwitchCase,\n      test: test,\n      consequent: consequent\n    };\n  }\n\n  function parseSwitchStatement() {\n    var discriminant, cases, clause, oldInSwitch, defaultFound;\n    expectKeyword('switch');\n    expect('(');\n    discriminant = parseExpression();\n    expect(')');\n    expect('{');\n    cases = [];\n\n    if (match('}')) {\n      lex();\n      return {\n        type: Syntax.SwitchStatement,\n        discriminant: discriminant,\n        cases: cases\n      };\n    }\n\n    oldInSwitch = state.inSwitch;\n    state.inSwitch = true;\n    defaultFound = false;\n\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n\n      clause = parseSwitchCase();\n\n      if (clause.test === null) {\n        if (defaultFound) {\n          throwError({}, Messages.MultipleDefaultsInSwitch);\n        }\n\n        defaultFound = true;\n      }\n\n      cases.push(clause);\n    }\n\n    state.inSwitch = oldInSwitch;\n    expect('}');\n    return {\n      type: Syntax.SwitchStatement,\n      discriminant: discriminant,\n      cases: cases\n    };\n  } // 12.13 The throw statement\n\n\n  function parseThrowStatement() {\n    var argument;\n    expectKeyword('throw');\n\n    if (peekLineTerminator()) {\n      throwError({}, Messages.NewlineAfterThrow);\n    }\n\n    argument = parseExpression();\n    consumeSemicolon();\n    return {\n      type: Syntax.ThrowStatement,\n      argument: argument\n    };\n  } // 12.14 The try statement\n\n\n  function parseCatchClause() {\n    var param;\n    expectKeyword('catch');\n    expect('(');\n\n    if (match(')')) {\n      throwUnexpected(lookahead());\n    }\n\n    param = parseVariableIdentifier(); // 12.14.1\n\n    if (strict && isRestrictedWord(param.name)) {\n      throwErrorTolerant({}, Messages.StrictCatchVariable);\n    }\n\n    expect(')');\n    return {\n      type: Syntax.CatchClause,\n      param: param,\n      body: parseBlock()\n    };\n  }\n\n  function parseTryStatement() {\n    var block,\n        handlers = [],\n        finalizer = null;\n    expectKeyword('try');\n    block = parseBlock();\n\n    if (matchKeyword('catch')) {\n      handlers.push(parseCatchClause());\n    }\n\n    if (matchKeyword('finally')) {\n      lex();\n      finalizer = parseBlock();\n    }\n\n    if (handlers.length === 0 && !finalizer) {\n      throwError({}, Messages.NoCatchOrFinally);\n    }\n\n    return {\n      type: Syntax.TryStatement,\n      block: block,\n      guardedHandlers: [],\n      handlers: handlers,\n      finalizer: finalizer\n    };\n  } // 12.15 The debugger statement\n\n\n  function parseDebuggerStatement() {\n    expectKeyword('debugger');\n    consumeSemicolon();\n    return {\n      type: Syntax.DebuggerStatement\n    };\n  } // 12 Statements\n\n\n  function parseStatement() {\n    var token = lookahead(),\n        expr,\n        labeledBody;\n\n    if (token.type === Token.EOF) {\n      throwUnexpected(token);\n    }\n\n    if (token.type === Token.Punctuator) {\n      switch (token.value) {\n        case ';':\n          return parseEmptyStatement();\n\n        case '{':\n          return parseBlock();\n\n        case '(':\n          return parseExpressionStatement();\n\n        default:\n          break;\n      }\n    }\n\n    if (token.type === Token.Keyword) {\n      switch (token.value) {\n        case 'break':\n          return parseBreakStatement();\n\n        case 'continue':\n          return parseContinueStatement();\n\n        case 'debugger':\n          return parseDebuggerStatement();\n\n        case 'do':\n          return parseDoWhileStatement();\n\n        case 'for':\n          return parseForStatement();\n\n        case 'function':\n          return parseFunctionDeclaration();\n\n        case 'if':\n          return parseIfStatement();\n\n        case 'return':\n          return parseReturnStatement();\n\n        case 'switch':\n          return parseSwitchStatement();\n\n        case 'throw':\n          return parseThrowStatement();\n\n        case 'try':\n          return parseTryStatement();\n\n        case 'var':\n          return parseVariableStatement();\n\n        case 'while':\n          return parseWhileStatement();\n\n        case 'with':\n          return parseWithStatement();\n\n        default:\n          break;\n      }\n    }\n\n    expr = parseExpression(); // 12.12 Labelled Statements\n\n    if (expr.type === Syntax.Identifier && match(':')) {\n      lex();\n\n      if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {\n        throwError({}, Messages.Redeclaration, 'Label', expr.name);\n      }\n\n      state.labelSet[expr.name] = true;\n      labeledBody = parseStatement();\n      delete state.labelSet[expr.name];\n      return {\n        type: Syntax.LabeledStatement,\n        label: expr,\n        body: labeledBody\n      };\n    }\n\n    consumeSemicolon();\n    return {\n      type: Syntax.ExpressionStatement,\n      expression: expr\n    };\n  } // 13 Function Definition\n\n\n  function parseFunctionSourceElements() {\n    var sourceElement,\n        sourceElements = [],\n        token,\n        directive,\n        firstRestricted,\n        oldLabelSet,\n        oldInIteration,\n        oldInSwitch,\n        oldInFunctionBody;\n    expect('{');\n\n    while (index < length) {\n      token = lookahead();\n\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n\n      sourceElement = parseSourceElement();\n      sourceElements.push(sourceElement);\n\n      if (sourceElement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n\n      directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n\n      if (directive === 'use strict') {\n        strict = true;\n\n        if (firstRestricted) {\n          throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n\n    oldLabelSet = state.labelSet;\n    oldInIteration = state.inIteration;\n    oldInSwitch = state.inSwitch;\n    oldInFunctionBody = state.inFunctionBody;\n    state.labelSet = {};\n    state.inIteration = false;\n    state.inSwitch = false;\n    state.inFunctionBody = true;\n\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n\n      sourceElement = parseSourceElement();\n\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n\n      sourceElements.push(sourceElement);\n    }\n\n    expect('}');\n    state.labelSet = oldLabelSet;\n    state.inIteration = oldInIteration;\n    state.inSwitch = oldInSwitch;\n    state.inFunctionBody = oldInFunctionBody;\n    return {\n      type: Syntax.BlockStatement,\n      body: sourceElements\n    };\n  }\n\n  function parseFunctionDeclaration() {\n    var id,\n        param,\n        params = [],\n        body,\n        token,\n        stricted,\n        firstRestricted,\n        message,\n        previousStrict,\n        paramSet;\n    expectKeyword('function');\n    token = lookahead();\n    id = parseVariableIdentifier();\n\n    if (strict) {\n      if (isRestrictedWord(token.value)) {\n        throwErrorTolerant(token, Messages.StrictFunctionName);\n      }\n    } else {\n      if (isRestrictedWord(token.value)) {\n        firstRestricted = token;\n        message = Messages.StrictFunctionName;\n      } else if (isStrictModeReservedWord(token.value)) {\n        firstRestricted = token;\n        message = Messages.StrictReservedWord;\n      }\n    }\n\n    expect('(');\n\n    if (!match(')')) {\n      paramSet = {};\n\n      while (index < length) {\n        token = lookahead();\n        param = parseVariableIdentifier();\n\n        if (strict) {\n          if (isRestrictedWord(token.value)) {\n            stricted = token;\n            message = Messages.StrictParamName;\n          }\n\n          if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n            stricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        } else if (!firstRestricted) {\n          if (isRestrictedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictParamName;\n          } else if (isStrictModeReservedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictReservedWord;\n          } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        }\n\n        params.push(param);\n        paramSet[param.name] = true;\n\n        if (match(')')) {\n          break;\n        }\n\n        expect(',');\n      }\n    }\n\n    expect(')');\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (strict && firstRestricted) {\n      throwError(firstRestricted, message);\n    }\n\n    if (strict && stricted) {\n      throwErrorTolerant(stricted, message);\n    }\n\n    strict = previousStrict;\n    return {\n      type: Syntax.FunctionDeclaration,\n      id: id,\n      params: params,\n      defaults: [],\n      body: body,\n      rest: null,\n      generator: false,\n      expression: false\n    };\n  }\n\n  function parseFunctionExpression() {\n    var token,\n        id = null,\n        stricted,\n        firstRestricted,\n        message,\n        param,\n        params = [],\n        body,\n        previousStrict,\n        paramSet;\n    expectKeyword('function');\n\n    if (!match('(')) {\n      token = lookahead();\n      id = parseVariableIdentifier();\n\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          throwErrorTolerant(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n\n    expect('(');\n\n    if (!match(')')) {\n      paramSet = {};\n\n      while (index < length) {\n        token = lookahead();\n        param = parseVariableIdentifier();\n\n        if (strict) {\n          if (isRestrictedWord(token.value)) {\n            stricted = token;\n            message = Messages.StrictParamName;\n          }\n\n          if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n            stricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        } else if (!firstRestricted) {\n          if (isRestrictedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictParamName;\n          } else if (isStrictModeReservedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictReservedWord;\n          } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        }\n\n        params.push(param);\n        paramSet[param.name] = true;\n\n        if (match(')')) {\n          break;\n        }\n\n        expect(',');\n      }\n    }\n\n    expect(')');\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (strict && firstRestricted) {\n      throwError(firstRestricted, message);\n    }\n\n    if (strict && stricted) {\n      throwErrorTolerant(stricted, message);\n    }\n\n    strict = previousStrict;\n    return {\n      type: Syntax.FunctionExpression,\n      id: id,\n      params: params,\n      defaults: [],\n      body: body,\n      rest: null,\n      generator: false,\n      expression: false\n    };\n  } // 14 Program\n\n\n  function parseSourceElement() {\n    var token = lookahead();\n\n    if (token.type === Token.Keyword) {\n      switch (token.value) {\n        case 'const':\n        case 'let':\n          return parseConstLetDeclaration(token.value);\n\n        case 'function':\n          return parseFunctionDeclaration();\n\n        default:\n          return parseStatement();\n      }\n    }\n\n    if (token.type !== Token.EOF) {\n      return parseStatement();\n    }\n  }\n\n  function parseSourceElements() {\n    var sourceElement,\n        sourceElements = [],\n        token,\n        directive,\n        firstRestricted;\n\n    while (index < length) {\n      token = lookahead();\n\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n\n      sourceElement = parseSourceElement();\n      sourceElements.push(sourceElement);\n\n      if (sourceElement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n\n      directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n\n      if (directive === 'use strict') {\n        strict = true;\n\n        if (firstRestricted) {\n          throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n\n    while (index < length) {\n      sourceElement = parseSourceElement();\n\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n\n      sourceElements.push(sourceElement);\n    }\n\n    return sourceElements;\n  }\n\n  function parseProgram() {\n    var program;\n    strict = false;\n    program = {\n      type: Syntax.Program,\n      body: parseSourceElements()\n    };\n    return program;\n  } // The following functions are needed only when the option to preserve\n  // the comments is active.\n\n\n  function addComment(type, value, start, end, loc) {\n    assert(typeof start === 'number', 'Comment must have valid position'); // Because the way the actual token is scanned, often the comments\n    // (if any) are skipped twice during the lexical analysis.\n    // Thus, we need to skip adding a comment if the comment array already\n    // handled it.\n\n    if (extra.comments.length > 0) {\n      if (extra.comments[extra.comments.length - 1].range[1] > start) {\n        return;\n      }\n    }\n\n    extra.comments.push({\n      type: type,\n      value: value,\n      range: [start, end],\n      loc: loc\n    });\n  }\n\n  function scanComment() {\n    var comment, ch, loc, start, blockComment, lineComment;\n    comment = '';\n    blockComment = false;\n    lineComment = false;\n\n    while (index < length) {\n      ch = source[index];\n\n      if (lineComment) {\n        ch = source[index++];\n\n        if (isLineTerminator(ch)) {\n          loc.end = {\n            line: lineNumber,\n            column: index - lineStart - 1\n          };\n          lineComment = false;\n          addComment('Line', comment, start, index - 1, loc);\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n\n          ++lineNumber;\n          lineStart = index;\n          comment = '';\n        } else if (index >= length) {\n          lineComment = false;\n          comment += ch;\n          loc.end = {\n            line: lineNumber,\n            column: length - lineStart\n          };\n          addComment('Line', comment, start, length, loc);\n        } else {\n          comment += ch;\n        }\n      } else if (blockComment) {\n        if (isLineTerminator(ch)) {\n          if (ch === '\\r' && source[index + 1] === '\\n') {\n            ++index;\n            comment += '\\r\\n';\n          } else {\n            comment += ch;\n          }\n\n          ++lineNumber;\n          ++index;\n          lineStart = index;\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n        } else {\n          ch = source[index++];\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n\n          comment += ch;\n\n          if (ch === '*') {\n            ch = source[index];\n\n            if (ch === '/') {\n              comment = comment.substr(0, comment.length - 1);\n              blockComment = false;\n              ++index;\n              loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n              };\n              addComment('Block', comment, start, index, loc);\n              comment = '';\n            }\n          }\n        }\n      } else if (ch === '/') {\n        ch = source[index + 1];\n\n        if (ch === '/') {\n          loc = {\n            start: {\n              line: lineNumber,\n              column: index - lineStart\n            }\n          };\n          start = index;\n          index += 2;\n          lineComment = true;\n\n          if (index >= length) {\n            loc.end = {\n              line: lineNumber,\n              column: index - lineStart\n            };\n            lineComment = false;\n            addComment('Line', comment, start, index, loc);\n          }\n        } else if (ch === '*') {\n          start = index;\n          index += 2;\n          blockComment = true;\n          loc = {\n            start: {\n              line: lineNumber,\n              column: index - lineStart - 2\n            }\n          };\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n        } else {\n          break;\n        }\n      } else if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        ++index;\n\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n\n        ++lineNumber;\n        lineStart = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  function filterCommentLocation() {\n    var i,\n        entry,\n        comment,\n        comments = [];\n\n    for (i = 0; i < extra.comments.length; ++i) {\n      entry = extra.comments[i];\n      comment = {\n        type: entry.type,\n        value: entry.value\n      };\n\n      if (extra.range) {\n        comment.range = entry.range;\n      }\n\n      if (extra.loc) {\n        comment.loc = entry.loc;\n      }\n\n      comments.push(comment);\n    }\n\n    extra.comments = comments;\n  }\n\n  function collectToken() {\n    var start, loc, token, range, value;\n    skipComment();\n    start = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    token = extra.advance();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n\n    if (token.type !== Token.EOF) {\n      range = [token.range[0], token.range[1]];\n      value = sliceSource(token.range[0], token.range[1]);\n      extra.tokens.push({\n        type: TokenName[token.type],\n        value: value,\n        range: range,\n        loc: loc\n      });\n    }\n\n    return token;\n  }\n\n  function collectRegex() {\n    var pos, loc, regex, token;\n    skipComment();\n    pos = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    regex = extra.scanRegExp();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    }; // Pop the previous token, which is likely '/' or '/='\n\n    if (extra.tokens.length > 0) {\n      token = extra.tokens[extra.tokens.length - 1];\n\n      if (token.range[0] === pos && token.type === 'Punctuator') {\n        if (token.value === '/' || token.value === '/=') {\n          extra.tokens.pop();\n        }\n      }\n    }\n\n    extra.tokens.push({\n      type: 'RegularExpression',\n      value: regex.literal,\n      range: [pos, index],\n      loc: loc\n    });\n    return regex;\n  }\n\n  function filterTokenLocation() {\n    var i,\n        entry,\n        token,\n        tokens = [];\n\n    for (i = 0; i < extra.tokens.length; ++i) {\n      entry = extra.tokens[i];\n      token = {\n        type: entry.type,\n        value: entry.value\n      };\n\n      if (extra.range) {\n        token.range = entry.range;\n      }\n\n      if (extra.loc) {\n        token.loc = entry.loc;\n      }\n\n      tokens.push(token);\n    }\n\n    extra.tokens = tokens;\n  }\n\n  function createLiteral(token) {\n    return {\n      type: Syntax.Literal,\n      value: token.value\n    };\n  }\n\n  function createRawLiteral(token) {\n    return {\n      type: Syntax.Literal,\n      value: token.value,\n      raw: sliceSource(token.range[0], token.range[1])\n    };\n  }\n\n  function createLocationMarker() {\n    var marker = {};\n    marker.range = [index, index];\n    marker.loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      },\n      end: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n\n    marker.end = function () {\n      this.range[1] = index;\n      this.loc.end.line = lineNumber;\n      this.loc.end.column = index - lineStart;\n    };\n\n    marker.applyGroup = function (node) {\n      if (extra.range) {\n        node.groupRange = [this.range[0], this.range[1]];\n      }\n\n      if (extra.loc) {\n        node.groupLoc = {\n          start: {\n            line: this.loc.start.line,\n            column: this.loc.start.column\n          },\n          end: {\n            line: this.loc.end.line,\n            column: this.loc.end.column\n          }\n        };\n      }\n    };\n\n    marker.apply = function (node) {\n      if (extra.range) {\n        node.range = [this.range[0], this.range[1]];\n      }\n\n      if (extra.loc) {\n        node.loc = {\n          start: {\n            line: this.loc.start.line,\n            column: this.loc.start.column\n          },\n          end: {\n            line: this.loc.end.line,\n            column: this.loc.end.column\n          }\n        };\n      }\n    };\n\n    return marker;\n  }\n\n  function trackGroupExpression() {\n    var marker, expr;\n    skipComment();\n    marker = createLocationMarker();\n    expect('(');\n    expr = parseExpression();\n    expect(')');\n    marker.end();\n    marker.applyGroup(expr);\n    return expr;\n  }\n\n  function trackLeftHandSideExpression() {\n    var marker, expr;\n    skipComment();\n    marker = createLocationMarker();\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n    while (match('.') || match('[')) {\n      if (match('[')) {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: true,\n          object: expr,\n          property: parseComputedMember()\n        };\n        marker.end();\n        marker.apply(expr);\n      } else {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: false,\n          object: expr,\n          property: parseNonComputedMember()\n        };\n        marker.end();\n        marker.apply(expr);\n      }\n    }\n\n    return expr;\n  }\n\n  function trackLeftHandSideExpressionAllowCall() {\n    var marker, expr;\n    skipComment();\n    marker = createLocationMarker();\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n    while (match('.') || match('[') || match('(')) {\n      if (match('(')) {\n        expr = {\n          type: Syntax.CallExpression,\n          callee: expr,\n          'arguments': parseArguments()\n        };\n        marker.end();\n        marker.apply(expr);\n      } else if (match('[')) {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: true,\n          object: expr,\n          property: parseComputedMember()\n        };\n        marker.end();\n        marker.apply(expr);\n      } else {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: false,\n          object: expr,\n          property: parseNonComputedMember()\n        };\n        marker.end();\n        marker.apply(expr);\n      }\n    }\n\n    return expr;\n  }\n\n  function filterGroup(node) {\n    var n, i, entry;\n    n = Object.prototype.toString.apply(node) === '[object Array]' ? [] : {};\n\n    for (i in node) {\n      if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {\n        entry = node[i];\n\n        if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {\n          n[i] = entry;\n        } else {\n          n[i] = filterGroup(entry);\n        }\n      }\n    }\n\n    return n;\n  }\n\n  function wrapTrackingFunction(range, loc) {\n    return function (parseFunction) {\n      function isBinary(node) {\n        return node.type === Syntax.LogicalExpression || node.type === Syntax.BinaryExpression;\n      }\n\n      function visit(node) {\n        var start, end;\n\n        if (isBinary(node.left)) {\n          visit(node.left);\n        }\n\n        if (isBinary(node.right)) {\n          visit(node.right);\n        }\n\n        if (range) {\n          if (node.left.groupRange || node.right.groupRange) {\n            start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];\n            end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];\n            node.range = [start, end];\n          } else if (typeof node.range === 'undefined') {\n            start = node.left.range[0];\n            end = node.right.range[1];\n            node.range = [start, end];\n          }\n        }\n\n        if (loc) {\n          if (node.left.groupLoc || node.right.groupLoc) {\n            start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;\n            end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;\n            node.loc = {\n              start: start,\n              end: end\n            };\n          } else if (typeof node.loc === 'undefined') {\n            node.loc = {\n              start: node.left.loc.start,\n              end: node.right.loc.end\n            };\n          }\n        }\n      }\n\n      return function () {\n        var marker, node;\n        skipComment();\n        marker = createLocationMarker();\n        node = parseFunction.apply(null, arguments);\n        marker.end();\n\n        if (range && typeof node.range === 'undefined') {\n          marker.apply(node);\n        }\n\n        if (loc && typeof node.loc === 'undefined') {\n          marker.apply(node);\n        }\n\n        if (isBinary(node)) {\n          visit(node);\n        }\n\n        return node;\n      };\n    };\n  }\n\n  function patch() {\n    var wrapTracking;\n\n    if (extra.comments) {\n      extra.skipComment = skipComment;\n      skipComment = scanComment;\n    }\n\n    if (extra.raw) {\n      extra.createLiteral = createLiteral;\n      createLiteral = createRawLiteral;\n    }\n\n    if (extra.range || extra.loc) {\n      extra.parseGroupExpression = parseGroupExpression;\n      extra.parseLeftHandSideExpression = parseLeftHandSideExpression;\n      extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;\n      parseGroupExpression = trackGroupExpression;\n      parseLeftHandSideExpression = trackLeftHandSideExpression;\n      parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;\n      wrapTracking = wrapTrackingFunction(extra.range, extra.loc);\n      extra.parseAdditiveExpression = parseAdditiveExpression;\n      extra.parseAssignmentExpression = parseAssignmentExpression;\n      extra.parseBitwiseANDExpression = parseBitwiseANDExpression;\n      extra.parseBitwiseORExpression = parseBitwiseORExpression;\n      extra.parseBitwiseXORExpression = parseBitwiseXORExpression;\n      extra.parseBlock = parseBlock;\n      extra.parseFunctionSourceElements = parseFunctionSourceElements;\n      extra.parseCatchClause = parseCatchClause;\n      extra.parseComputedMember = parseComputedMember;\n      extra.parseConditionalExpression = parseConditionalExpression;\n      extra.parseConstLetDeclaration = parseConstLetDeclaration;\n      extra.parseEqualityExpression = parseEqualityExpression;\n      extra.parseExpression = parseExpression;\n      extra.parseForVariableDeclaration = parseForVariableDeclaration;\n      extra.parseFunctionDeclaration = parseFunctionDeclaration;\n      extra.parseFunctionExpression = parseFunctionExpression;\n      extra.parseLogicalANDExpression = parseLogicalANDExpression;\n      extra.parseLogicalORExpression = parseLogicalORExpression;\n      extra.parseMultiplicativeExpression = parseMultiplicativeExpression;\n      extra.parseNewExpression = parseNewExpression;\n      extra.parseNonComputedProperty = parseNonComputedProperty;\n      extra.parseObjectProperty = parseObjectProperty;\n      extra.parseObjectPropertyKey = parseObjectPropertyKey;\n      extra.parsePostfixExpression = parsePostfixExpression;\n      extra.parsePrimaryExpression = parsePrimaryExpression;\n      extra.parseProgram = parseProgram;\n      extra.parsePropertyFunction = parsePropertyFunction;\n      extra.parseRelationalExpression = parseRelationalExpression;\n      extra.parseStatement = parseStatement;\n      extra.parseShiftExpression = parseShiftExpression;\n      extra.parseSwitchCase = parseSwitchCase;\n      extra.parseUnaryExpression = parseUnaryExpression;\n      extra.parseVariableDeclaration = parseVariableDeclaration;\n      extra.parseVariableIdentifier = parseVariableIdentifier;\n      parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);\n      parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);\n      parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);\n      parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);\n      parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);\n      parseBlock = wrapTracking(extra.parseBlock);\n      parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);\n      parseCatchClause = wrapTracking(extra.parseCatchClause);\n      parseComputedMember = wrapTracking(extra.parseComputedMember);\n      parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);\n      parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);\n      parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);\n      parseExpression = wrapTracking(extra.parseExpression);\n      parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);\n      parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);\n      parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);\n      parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);\n      parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);\n      parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);\n      parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);\n      parseNewExpression = wrapTracking(extra.parseNewExpression);\n      parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);\n      parseObjectProperty = wrapTracking(extra.parseObjectProperty);\n      parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);\n      parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);\n      parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);\n      parseProgram = wrapTracking(extra.parseProgram);\n      parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);\n      parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);\n      parseStatement = wrapTracking(extra.parseStatement);\n      parseShiftExpression = wrapTracking(extra.parseShiftExpression);\n      parseSwitchCase = wrapTracking(extra.parseSwitchCase);\n      parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);\n      parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);\n      parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);\n    }\n\n    if (typeof extra.tokens !== 'undefined') {\n      extra.advance = advance;\n      extra.scanRegExp = scanRegExp;\n      advance = collectToken;\n      scanRegExp = collectRegex;\n    }\n  }\n\n  function unpatch() {\n    if (typeof extra.skipComment === 'function') {\n      skipComment = extra.skipComment;\n    }\n\n    if (extra.raw) {\n      createLiteral = extra.createLiteral;\n    }\n\n    if (extra.range || extra.loc) {\n      parseAdditiveExpression = extra.parseAdditiveExpression;\n      parseAssignmentExpression = extra.parseAssignmentExpression;\n      parseBitwiseANDExpression = extra.parseBitwiseANDExpression;\n      parseBitwiseORExpression = extra.parseBitwiseORExpression;\n      parseBitwiseXORExpression = extra.parseBitwiseXORExpression;\n      parseBlock = extra.parseBlock;\n      parseFunctionSourceElements = extra.parseFunctionSourceElements;\n      parseCatchClause = extra.parseCatchClause;\n      parseComputedMember = extra.parseComputedMember;\n      parseConditionalExpression = extra.parseConditionalExpression;\n      parseConstLetDeclaration = extra.parseConstLetDeclaration;\n      parseEqualityExpression = extra.parseEqualityExpression;\n      parseExpression = extra.parseExpression;\n      parseForVariableDeclaration = extra.parseForVariableDeclaration;\n      parseFunctionDeclaration = extra.parseFunctionDeclaration;\n      parseFunctionExpression = extra.parseFunctionExpression;\n      parseGroupExpression = extra.parseGroupExpression;\n      parseLeftHandSideExpression = extra.parseLeftHandSideExpression;\n      parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;\n      parseLogicalANDExpression = extra.parseLogicalANDExpression;\n      parseLogicalORExpression = extra.parseLogicalORExpression;\n      parseMultiplicativeExpression = extra.parseMultiplicativeExpression;\n      parseNewExpression = extra.parseNewExpression;\n      parseNonComputedProperty = extra.parseNonComputedProperty;\n      parseObjectProperty = extra.parseObjectProperty;\n      parseObjectPropertyKey = extra.parseObjectPropertyKey;\n      parsePrimaryExpression = extra.parsePrimaryExpression;\n      parsePostfixExpression = extra.parsePostfixExpression;\n      parseProgram = extra.parseProgram;\n      parsePropertyFunction = extra.parsePropertyFunction;\n      parseRelationalExpression = extra.parseRelationalExpression;\n      parseStatement = extra.parseStatement;\n      parseShiftExpression = extra.parseShiftExpression;\n      parseSwitchCase = extra.parseSwitchCase;\n      parseUnaryExpression = extra.parseUnaryExpression;\n      parseVariableDeclaration = extra.parseVariableDeclaration;\n      parseVariableIdentifier = extra.parseVariableIdentifier;\n    }\n\n    if (typeof extra.scanRegExp === 'function') {\n      advance = extra.advance;\n      scanRegExp = extra.scanRegExp;\n    }\n  }\n\n  function stringToArray(str) {\n    var length = str.length,\n        result = [],\n        i;\n\n    for (i = 0; i < length; ++i) {\n      result[i] = str.charAt(i);\n    }\n\n    return result;\n  }\n\n  function parse(code, options) {\n    var program, toString;\n    toString = String;\n\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    length = source.length;\n    buffer = null;\n    state = {\n      allowIn: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false\n    };\n    extra = {};\n\n    if (typeof options !== 'undefined') {\n      extra.range = typeof options.range === 'boolean' && options.range;\n      extra.loc = typeof options.loc === 'boolean' && options.loc;\n      extra.raw = typeof options.raw === 'boolean' && options.raw;\n\n      if (typeof options.tokens === 'boolean' && options.tokens) {\n        extra.tokens = [];\n      }\n\n      if (typeof options.comment === 'boolean' && options.comment) {\n        extra.comments = [];\n      }\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n        extra.errors = [];\n      }\n    }\n\n    if (length > 0) {\n      if (typeof source[0] === 'undefined') {\n        // Try first to convert to a string. This is good as fast path\n        // for old IE which understands string indexing for string\n        // literals only and not for string object.\n        if (code instanceof String) {\n          source = code.valueOf();\n        } // Force accessing the characters via an array.\n\n\n        if (typeof source[0] === 'undefined') {\n          source = stringToArray(code);\n        }\n      }\n    }\n\n    patch();\n\n    try {\n      program = parseProgram();\n\n      if (typeof extra.comments !== 'undefined') {\n        filterCommentLocation();\n        program.comments = extra.comments;\n      }\n\n      if (typeof extra.tokens !== 'undefined') {\n        filterTokenLocation();\n        program.tokens = extra.tokens;\n      }\n\n      if (typeof extra.errors !== 'undefined') {\n        program.errors = extra.errors;\n      }\n\n      if (extra.range || extra.loc) {\n        program.body = filterGroup(program.body);\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      unpatch();\n      extra = {};\n    }\n\n    return program;\n  } // Sync with package.json.\n\n\n  exports.version = '1.0.4';\n  exports.parse = parse; // Deep copy.\n\n  exports.Syntax = function () {\n    var name,\n        types = {};\n\n    if (typeof Object.create === 'function') {\n      types = Object.create(null);\n    }\n\n    for (name in Syntax) {\n      if (Syntax.hasOwnProperty(name)) {\n        types[name] = Syntax[name];\n      }\n    }\n\n    if (typeof Object.freeze === 'function') {\n      Object.freeze(types);\n    }\n\n    return types;\n  }();\n});\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"sources":["/home/elvis/Documents/GitHub/medbase/mern-auth/node_modules/esprima/esprima.js"],"names":["root","factory","define","amd","exports","esprima","Token","TokenName","Syntax","PropertyKind","Messages","Regex","source","strict","index","lineNumber","lineStart","length","buffer","state","extra","BooleanLiteral","EOF","Identifier","Keyword","NullLiteral","NumericLiteral","Punctuator","StringLiteral","AssignmentExpression","ArrayExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ConditionalExpression","ContinueStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExpressionStatement","ForStatement","ForInStatement","FunctionDeclaration","FunctionExpression","IfStatement","Literal","LabeledStatement","LogicalExpression","MemberExpression","NewExpression","ObjectExpression","Program","Property","ReturnStatement","SequenceExpression","SwitchStatement","SwitchCase","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","Data","Get","Set","UnexpectedToken","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","UnexpectedEOS","NewlineAfterThrow","InvalidRegExp","UnterminatedRegExp","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictOctalLiteral","StrictDelete","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","StrictReservedWord","NonAsciiIdentifierStart","RegExp","NonAsciiIdentifierPart","assert","condition","message","Error","sliceSource","from","to","slice","sliceArraySource","join","isDecimalDigit","ch","indexOf","isHexDigit","isOctalDigit","isWhiteSpace","charCodeAt","isLineTerminator","isIdentifierStart","test","isIdentifierPart","isFutureReservedWord","id","isStrictModeReservedWord","isRestrictedWord","isKeyword","keyword","skipComment","blockComment","lineComment","throwError","scanHexEscape","prefix","i","len","code","toLowerCase","String","fromCharCode","scanIdentifier","start","restore","type","value","range","scanPunctuator","ch1","ch2","ch3","ch4","scanNumericLiteral","number","parseInt","octal","parseFloat","scanStringLiteral","str","quote","unescaped","scanRegExp","pattern","flags","classMarker","terminated","substr","e","literal","isIdentifierName","token","advance","lex","lookahead","pos","line","peekLineTerminator","found","messageFormat","error","args","Array","prototype","call","arguments","msg","replace","whole","column","throwErrorTolerant","apply","errors","push","throwUnexpected","expect","expectKeyword","match","matchKeyword","matchAssign","op","consumeSemicolon","isLeftHandSide","expr","parseArrayInitialiser","elements","parseAssignmentExpression","parsePropertyFunction","param","first","previousStrict","body","parseFunctionSourceElements","name","params","defaults","rest","generator","expression","parseObjectPropertyKey","createLiteral","parseObjectProperty","key","kind","parseVariableIdentifier","parseObjectInitialiser","properties","property","map","toString","Object","hasOwnProperty","parseGroupExpression","parseExpression","parsePrimaryExpression","parseFunctionExpression","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseNewExpression","callee","parseLeftHandSideExpression","parseLeftHandSideExpressionAllowCall","computed","object","parsePostfixExpression","operator","argument","parseUnaryExpression","parseMultiplicativeExpression","left","right","parseAdditiveExpression","parseShiftExpression","parseRelationalExpression","previousAllowIn","allowIn","parseEqualityExpression","parseBitwiseANDExpression","parseBitwiseXORExpression","parseBitwiseORExpression","parseLogicalANDExpression","parseLogicalORExpression","parseConditionalExpression","consequent","alternate","expressions","parseStatementList","list","statement","parseSourceElement","parseBlock","block","parseVariableDeclaration","init","parseVariableDeclarationList","parseVariableStatement","declarations","parseConstLetDeclaration","parseEmptyStatement","parseExpressionStatement","parseIfStatement","parseStatement","parseDoWhileStatement","oldInIteration","inIteration","parseWhileStatement","parseForVariableDeclaration","parseForStatement","update","each","parseContinueStatement","label","labelSet","parseBreakStatement","inSwitch","parseReturnStatement","inFunctionBody","parseWithStatement","parseSwitchCase","parseSwitchStatement","discriminant","cases","clause","oldInSwitch","defaultFound","parseThrowStatement","parseCatchClause","parseTryStatement","handlers","finalizer","guardedHandlers","parseDebuggerStatement","labeledBody","parseFunctionDeclaration","sourceElement","sourceElements","directive","firstRestricted","oldLabelSet","oldInFunctionBody","stricted","paramSet","parseSourceElements","parseProgram","program","addComment","end","loc","comments","scanComment","comment","filterCommentLocation","entry","collectToken","tokens","collectRegex","regex","pop","filterTokenLocation","createRawLiteral","raw","createLocationMarker","marker","applyGroup","node","groupRange","groupLoc","trackGroupExpression","trackLeftHandSideExpression","trackLeftHandSideExpressionAllowCall","filterGroup","n","wrapTrackingFunction","parseFunction","isBinary","visit","patch","wrapTracking","unpatch","stringToArray","result","charAt","parse","options","tolerant","valueOf","version","types","create","freeze"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;AACA;;;;;;;AAQC,WAAUA,IAAV,EAAgBC,OAAhB,EAAyB;AACtB,eADsB,CAGtB;AACA;;AACA,MAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACC,GAA3C,EAAgD;AAC5CD,IAAAA,MAAM,CAAC,CAAC,SAAD,CAAD,EAAcD,OAAd,CAAN;AACH,GAFD,MAEO,IAAI,OAAOG,OAAP,KAAmB,WAAvB,EAAoC;AACvCH,IAAAA,OAAO,CAACG,OAAD,CAAP;AACH,GAFM,MAEA;AACHH,IAAAA,OAAO,CAAED,IAAI,CAACK,OAAL,GAAe,EAAjB,CAAP;AACH;AACJ,CAZA,EAYC,IAZD,EAYO,UAAUD,OAAV,EAAmB;AACvB;;AAEA,MAAIE,KAAJ,EACIC,SADJ,EAEIC,MAFJ,EAGIC,YAHJ,EAIIC,QAJJ,EAKIC,KALJ,EAMIC,MANJ,EAOIC,MAPJ,EAQIC,KARJ,EASIC,UATJ,EAUIC,SAVJ,EAWIC,MAXJ,EAYIC,MAZJ,EAaIC,KAbJ,EAcIC,KAdJ;AAgBAd,EAAAA,KAAK,GAAG;AACJe,IAAAA,cAAc,EAAE,CADZ;AAEJC,IAAAA,GAAG,EAAE,CAFD;AAGJC,IAAAA,UAAU,EAAE,CAHR;AAIJC,IAAAA,OAAO,EAAE,CAJL;AAKJC,IAAAA,WAAW,EAAE,CALT;AAMJC,IAAAA,cAAc,EAAE,CANZ;AAOJC,IAAAA,UAAU,EAAE,CAPR;AAQJC,IAAAA,aAAa,EAAE;AARX,GAAR;AAWArB,EAAAA,SAAS,GAAG,EAAZ;AACAA,EAAAA,SAAS,CAACD,KAAK,CAACe,cAAP,CAAT,GAAkC,SAAlC;AACAd,EAAAA,SAAS,CAACD,KAAK,CAACgB,GAAP,CAAT,GAAuB,OAAvB;AACAf,EAAAA,SAAS,CAACD,KAAK,CAACiB,UAAP,CAAT,GAA8B,YAA9B;AACAhB,EAAAA,SAAS,CAACD,KAAK,CAACkB,OAAP,CAAT,GAA2B,SAA3B;AACAjB,EAAAA,SAAS,CAACD,KAAK,CAACmB,WAAP,CAAT,GAA+B,MAA/B;AACAlB,EAAAA,SAAS,CAACD,KAAK,CAACoB,cAAP,CAAT,GAAkC,SAAlC;AACAnB,EAAAA,SAAS,CAACD,KAAK,CAACqB,UAAP,CAAT,GAA8B,YAA9B;AACApB,EAAAA,SAAS,CAACD,KAAK,CAACsB,aAAP,CAAT,GAAiC,QAAjC;AAEApB,EAAAA,MAAM,GAAG;AACLqB,IAAAA,oBAAoB,EAAE,sBADjB;AAELC,IAAAA,eAAe,EAAE,iBAFZ;AAGLC,IAAAA,cAAc,EAAE,gBAHX;AAILC,IAAAA,gBAAgB,EAAE,kBAJb;AAKLC,IAAAA,cAAc,EAAE,gBALX;AAMLC,IAAAA,cAAc,EAAE,gBANX;AAOLC,IAAAA,WAAW,EAAE,aAPR;AAQLC,IAAAA,qBAAqB,EAAE,uBARlB;AASLC,IAAAA,iBAAiB,EAAE,mBATd;AAULC,IAAAA,gBAAgB,EAAE,kBAVb;AAWLC,IAAAA,iBAAiB,EAAE,mBAXd;AAYLC,IAAAA,cAAc,EAAE,gBAZX;AAaLC,IAAAA,mBAAmB,EAAE,qBAbhB;AAcLC,IAAAA,YAAY,EAAE,cAdT;AAeLC,IAAAA,cAAc,EAAE,gBAfX;AAgBLC,IAAAA,mBAAmB,EAAE,qBAhBhB;AAiBLC,IAAAA,kBAAkB,EAAE,oBAjBf;AAkBLtB,IAAAA,UAAU,EAAE,YAlBP;AAmBLuB,IAAAA,WAAW,EAAE,aAnBR;AAoBLC,IAAAA,OAAO,EAAE,SApBJ;AAqBLC,IAAAA,gBAAgB,EAAE,kBArBb;AAsBLC,IAAAA,iBAAiB,EAAE,mBAtBd;AAuBLC,IAAAA,gBAAgB,EAAE,kBAvBb;AAwBLC,IAAAA,aAAa,EAAE,eAxBV;AAyBLC,IAAAA,gBAAgB,EAAE,kBAzBb;AA0BLC,IAAAA,OAAO,EAAE,SA1BJ;AA2BLC,IAAAA,QAAQ,EAAE,UA3BL;AA4BLC,IAAAA,eAAe,EAAE,iBA5BZ;AA6BLC,IAAAA,kBAAkB,EAAE,oBA7Bf;AA8BLC,IAAAA,eAAe,EAAE,iBA9BZ;AA+BLC,IAAAA,UAAU,EAAE,YA/BP;AAgCLC,IAAAA,cAAc,EAAE,gBAhCX;AAiCLC,IAAAA,cAAc,EAAE,gBAjCX;AAkCLC,IAAAA,YAAY,EAAE,cAlCT;AAmCLC,IAAAA,eAAe,EAAE,iBAnCZ;AAoCLC,IAAAA,gBAAgB,EAAE,kBApCb;AAqCLC,IAAAA,mBAAmB,EAAE,qBArChB;AAsCLC,IAAAA,kBAAkB,EAAE,oBAtCf;AAuCLC,IAAAA,cAAc,EAAE,gBAvCX;AAwCLC,IAAAA,aAAa,EAAE;AAxCV,GAAT;AA2CA1D,EAAAA,YAAY,GAAG;AACX2D,IAAAA,IAAI,EAAE,CADK;AAEXC,IAAAA,GAAG,EAAE,CAFM;AAGXC,IAAAA,GAAG,EAAE;AAHM,GAAf,CAnFuB,CAyFvB;;AACA5D,EAAAA,QAAQ,GAAG;AACP6D,IAAAA,eAAe,EAAG,qBADX;AAEPC,IAAAA,gBAAgB,EAAG,mBAFZ;AAGPC,IAAAA,gBAAgB,EAAG,mBAHZ;AAIPC,IAAAA,oBAAoB,EAAG,uBAJhB;AAKPC,IAAAA,kBAAkB,EAAG,0BALd;AAMPC,IAAAA,aAAa,EAAG,yBANT;AAOPC,IAAAA,iBAAiB,EAAG,6BAPb;AAQPC,IAAAA,aAAa,EAAE,4BARR;AASPC,IAAAA,kBAAkB,EAAG,uCATd;AAUPC,IAAAA,sBAAsB,EAAG,sCAVlB;AAWPC,IAAAA,iBAAiB,EAAG,kCAXb;AAYPC,IAAAA,wBAAwB,EAAE,kDAZnB;AAaPC,IAAAA,gBAAgB,EAAG,oCAbZ;AAcPC,IAAAA,YAAY,EAAE,wBAdP;AAePC,IAAAA,aAAa,EAAE,qCAfR;AAgBPC,IAAAA,eAAe,EAAE,4BAhBV;AAiBPC,IAAAA,YAAY,EAAE,yBAjBP;AAkBPC,IAAAA,aAAa,EAAE,0BAlBR;AAmBPC,IAAAA,cAAc,EAAG,mDAnBV;AAoBPC,IAAAA,mBAAmB,EAAG,4DApBf;AAqBPC,IAAAA,aAAa,EAAG,2DArBT;AAsBPC,IAAAA,eAAe,EAAG,gEAtBX;AAuBPC,IAAAA,eAAe,EAAE,6DAvBV;AAwBPC,IAAAA,kBAAkB,EAAG,2DAxBd;AAyBPC,IAAAA,kBAAkB,EAAG,gDAzBd;AA0BPC,IAAAA,YAAY,EAAG,qDA1BR;AA2BPC,IAAAA,uBAAuB,EAAG,sEA3BnB;AA4BPC,IAAAA,oBAAoB,EAAG,2EA5BhB;AA6BPC,IAAAA,cAAc,EAAG,2EA7BV;AA8BPC,IAAAA,mBAAmB,EAAG,+DA9Bf;AA+BPC,IAAAA,gBAAgB,EAAG,mFA/BZ;AAgCPC,IAAAA,eAAe,EAAG,kFAhCX;AAiCPC,IAAAA,kBAAkB,EAAG;AAjCd,GAAX,CA1FuB,CA8HvB;;AACA5F,EAAAA,KAAK,GAAG;AACJ6F,IAAAA,uBAAuB,EAAE,IAAIC,MAAJ,CAAW,wmIAAX,CADrB;AAEJC,IAAAA,sBAAsB,EAAE,IAAID,MAAJ,CAAW,g7JAAX;AAFpB,GAAR,CA/HuB,CAoIvB;AACA;AACA;AACA;;AAEA,WAASE,MAAT,CAAgBC,SAAhB,EAA2BC,OAA3B,EAAoC;AAChC,QAAI,CAACD,SAAL,EAAgB;AACZ,YAAM,IAAIE,KAAJ,CAAU,aAAaD,OAAvB,CAAN;AACH;AACJ;;AAED,WAASE,WAAT,CAAqBC,IAArB,EAA2BC,EAA3B,EAA+B;AAC3B,WAAOrG,MAAM,CAACsG,KAAP,CAAaF,IAAb,EAAmBC,EAAnB,CAAP;AACH;;AAED,MAAI,OAAO,UAAU,CAAV,CAAP,KAAwB,WAA5B,EAAyC;AACrCF,IAAAA,WAAW,GAAG,SAASI,gBAAT,CAA0BH,IAA1B,EAAgCC,EAAhC,EAAoC;AAC9C,aAAOrG,MAAM,CAACsG,KAAP,CAAaF,IAAb,EAAmBC,EAAnB,EAAuBG,IAAvB,CAA4B,EAA5B,CAAP;AACH,KAFD;AAGH;;AAED,WAASC,cAAT,CAAwBC,EAAxB,EAA4B;AACxB,WAAO,aAAaC,OAAb,CAAqBD,EAArB,KAA4B,CAAnC;AACH;;AAED,WAASE,UAAT,CAAoBF,EAApB,EAAwB;AACpB,WAAO,yBAAyBC,OAAzB,CAAiCD,EAAjC,KAAwC,CAA/C;AACH;;AAED,WAASG,YAAT,CAAsBH,EAAtB,EAA0B;AACtB,WAAO,WAAWC,OAAX,CAAmBD,EAAnB,KAA0B,CAAjC;AACH,GAnKsB,CAsKvB;;;AAEA,WAASI,YAAT,CAAsBJ,EAAtB,EAA0B;AACtB,WAAQA,EAAE,KAAK,GAAR,IAAiBA,EAAE,KAAK,QAAxB,IAAsCA,EAAE,KAAK,QAA7C,IACFA,EAAE,KAAK,QADL,IACmBA,EAAE,KAAK,QAD1B,IAEFA,EAAE,CAACK,UAAH,CAAc,CAAd,KAAoB,MAApB,IACA,yGAAyGJ,OAAzG,CAAiHD,EAAjH,KAAwH,CAH7H;AAIH,GA7KsB,CA+KvB;;;AAEA,WAASM,gBAAT,CAA0BN,EAA1B,EAA8B;AAC1B,WAAQA,EAAE,KAAK,IAAP,IAAeA,EAAE,KAAK,IAAtB,IAA8BA,EAAE,KAAK,QAArC,IAAiDA,EAAE,KAAK,QAAhE;AACH,GAnLsB,CAqLvB;;;AAEA,WAASO,iBAAT,CAA2BP,EAA3B,EAA+B;AAC3B,WAAQA,EAAE,KAAK,GAAR,IAAiBA,EAAE,KAAK,GAAxB,IAAiCA,EAAE,KAAK,IAAxC,IACFA,EAAE,IAAI,GAAN,IAAaA,EAAE,IAAI,GADjB,IAC0BA,EAAE,IAAI,GAAN,IAAaA,EAAE,IAAI,GAD7C,IAEDA,EAAE,CAACK,UAAH,CAAc,CAAd,KAAoB,IAArB,IAA8BhH,KAAK,CAAC6F,uBAAN,CAA8BsB,IAA9B,CAAmCR,EAAnC,CAFnC;AAGH;;AAED,WAASS,gBAAT,CAA0BT,EAA1B,EAA8B;AAC1B,WAAQA,EAAE,KAAK,GAAR,IAAiBA,EAAE,KAAK,GAAxB,IAAiCA,EAAE,KAAK,IAAxC,IACFA,EAAE,IAAI,GAAN,IAAaA,EAAE,IAAI,GADjB,IAC0BA,EAAE,IAAI,GAAN,IAAaA,EAAE,IAAI,GAD7C,IAEDA,EAAE,IAAI,GAAP,IAAgBA,EAAE,IAAI,GAFpB,IAGDA,EAAE,CAACK,UAAH,CAAc,CAAd,KAAoB,IAArB,IAA8BhH,KAAK,CAAC+F,sBAAN,CAA6BoB,IAA7B,CAAkCR,EAAlC,CAHnC;AAIH,GAlMsB,CAoMvB;;;AAEA,WAASU,oBAAT,CAA8BC,EAA9B,EAAkC;AAC9B,YAAQA,EAAR;AAEA;AACA,WAAK,OAAL;AACA,WAAK,MAAL;AACA,WAAK,QAAL;AACA,WAAK,SAAL;AACA,WAAK,QAAL;AACA,WAAK,OAAL;AACI,eAAO,IAAP;AATJ;;AAYA,WAAO,KAAP;AACH;;AAED,WAASC,wBAAT,CAAkCD,EAAlC,EAAsC;AAClC,YAAQA,EAAR;AAEA;AACA,WAAK,YAAL;AACA,WAAK,WAAL;AACA,WAAK,SAAL;AACA,WAAK,SAAL;AACA,WAAK,WAAL;AACA,WAAK,QAAL;AACA,WAAK,QAAL;AACA,WAAK,OAAL;AACA,WAAK,KAAL;AACI,eAAO,IAAP;AAZJ;;AAeA,WAAO,KAAP;AACH;;AAED,WAASE,gBAAT,CAA0BF,EAA1B,EAA8B;AAC1B,WAAOA,EAAE,KAAK,MAAP,IAAiBA,EAAE,KAAK,WAA/B;AACH,GA3OsB,CA6OvB;;;AAEA,WAASG,SAAT,CAAmBH,EAAnB,EAAuB;AACnB,QAAII,OAAO,GAAG,KAAd;;AACA,YAAQJ,EAAE,CAAChH,MAAX;AACA,WAAK,CAAL;AACIoH,QAAAA,OAAO,GAAIJ,EAAE,KAAK,IAAR,IAAkBA,EAAE,KAAK,IAAzB,IAAmCA,EAAE,KAAK,IAApD;AACA;;AACJ,WAAK,CAAL;AACII,QAAAA,OAAO,GAAIJ,EAAE,KAAK,KAAR,IAAmBA,EAAE,KAAK,KAA1B,IAAqCA,EAAE,KAAK,KAA5C,IAAuDA,EAAE,KAAK,KAAxE;AACA;;AACJ,WAAK,CAAL;AACII,QAAAA,OAAO,GAAIJ,EAAE,KAAK,MAAR,IAAoBA,EAAE,KAAK,MAA3B,IAAuCA,EAAE,KAAK,MAA9C,IAA0DA,EAAE,KAAK,MAAjE,IAA6EA,EAAE,KAAK,MAA9F;AACA;;AACJ,WAAK,CAAL;AACII,QAAAA,OAAO,GAAIJ,EAAE,KAAK,OAAR,IAAqBA,EAAE,KAAK,OAA5B,IAAyCA,EAAE,KAAK,OAAhD,IAA6DA,EAAE,KAAK,OAA9E;AACA;;AACJ,WAAK,CAAL;AACII,QAAAA,OAAO,GAAIJ,EAAE,KAAK,QAAR,IAAsBA,EAAE,KAAK,QAA7B,IAA2CA,EAAE,KAAK,QAAlD,IAAgEA,EAAE,KAAK,QAAjF;AACA;;AACJ,WAAK,CAAL;AACII,QAAAA,OAAO,GAAIJ,EAAE,KAAK,SAAR,IAAuBA,EAAE,KAAK,SAAxC;AACA;;AACJ,WAAK,CAAL;AACII,QAAAA,OAAO,GAAIJ,EAAE,KAAK,UAAR,IAAwBA,EAAE,KAAK,UAA/B,IAA+CA,EAAE,KAAK,UAAhE;AACA;;AACJ,WAAK,EAAL;AACII,QAAAA,OAAO,GAAIJ,EAAE,KAAK,YAAlB;AACA;AAxBJ;;AA2BA,QAAII,OAAJ,EAAa;AACT,aAAO,IAAP;AACH;;AAED,YAAQJ,EAAR;AACA;AACA;AACA,WAAK,OAAL;AACI,eAAO,IAAP;AAEJ;;AACA,WAAK,OAAL;AACA,WAAK,KAAL;AACI,eAAO,IAAP;AATJ;;AAYA,QAAIpH,MAAM,IAAIqH,wBAAwB,CAACD,EAAD,CAAtC,EAA4C;AACxC,aAAO,IAAP;AACH;;AAED,WAAOD,oBAAoB,CAACC,EAAD,CAA3B;AACH,GAjSsB,CAmSvB;;;AAEA,WAASK,WAAT,GAAuB;AACnB,QAAIhB,EAAJ,EAAQiB,YAAR,EAAsBC,WAAtB;AAEAD,IAAAA,YAAY,GAAG,KAAf;AACAC,IAAAA,WAAW,GAAG,KAAd;;AAEA,WAAO1H,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,MAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AAEA,UAAI0H,WAAJ,EAAiB;AACblB,QAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,EAAN,CAAX;;AACA,YAAI8G,gBAAgB,CAACN,EAAD,CAApB,EAA0B;AACtBkB,UAAAA,WAAW,GAAG,KAAd;;AACA,cAAIlB,EAAE,KAAK,IAAP,IAAe1G,MAAM,CAACE,KAAD,CAAN,KAAkB,IAArC,EAA2C;AACvC,cAAEA,KAAF;AACH;;AACD,YAAEC,UAAF;AACAC,UAAAA,SAAS,GAAGF,KAAZ;AACH;AACJ,OAVD,MAUO,IAAIyH,YAAJ,EAAkB;AACrB,YAAIX,gBAAgB,CAACN,EAAD,CAApB,EAA0B;AACtB,cAAIA,EAAE,KAAK,IAAP,IAAe1G,MAAM,CAACE,KAAK,GAAG,CAAT,CAAN,KAAsB,IAAzC,EAA+C;AAC3C,cAAEA,KAAF;AACH;;AACD,YAAEC,UAAF;AACA,YAAED,KAAF;AACAE,UAAAA,SAAS,GAAGF,KAAZ;;AACA,cAAIA,KAAK,IAAIG,MAAb,EAAqB;AACjBwH,YAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;AACJ,SAVD,MAUO;AACH+C,UAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,EAAN,CAAX;;AACA,cAAIA,KAAK,IAAIG,MAAb,EAAqB;AACjBwH,YAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;;AACD,cAAI+C,EAAE,KAAK,GAAX,EAAgB;AACZA,YAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,gBAAIwG,EAAE,KAAK,GAAX,EAAgB;AACZ,gBAAExG,KAAF;AACAyH,cAAAA,YAAY,GAAG,KAAf;AACH;AACJ;AACJ;AACJ,OAxBM,MAwBA,IAAIjB,EAAE,KAAK,GAAX,EAAgB;AACnBA,QAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,GAAG,CAAT,CAAX;;AACA,YAAIwG,EAAE,KAAK,GAAX,EAAgB;AACZxG,UAAAA,KAAK,IAAI,CAAT;AACA0H,UAAAA,WAAW,GAAG,IAAd;AACH,SAHD,MAGO,IAAIlB,EAAE,KAAK,GAAX,EAAgB;AACnBxG,UAAAA,KAAK,IAAI,CAAT;AACAyH,UAAAA,YAAY,GAAG,IAAf;;AACA,cAAIzH,KAAK,IAAIG,MAAb,EAAqB;AACjBwH,YAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;AACJ,SANM,MAMA;AACH;AACH;AACJ,OAdM,MAcA,IAAImD,YAAY,CAACJ,EAAD,CAAhB,EAAsB;AACzB,UAAExG,KAAF;AACH,OAFM,MAEA,IAAI8G,gBAAgB,CAACN,EAAD,CAApB,EAA0B;AAC7B,UAAExG,KAAF;;AACA,YAAIwG,EAAE,KAAM,IAAR,IAAgB1G,MAAM,CAACE,KAAD,CAAN,KAAkB,IAAtC,EAA4C;AACxC,YAAEA,KAAF;AACH;;AACD,UAAEC,UAAF;AACAC,QAAAA,SAAS,GAAGF,KAAZ;AACH,OAPM,MAOA;AACH;AACH;AACJ;AACJ;;AAED,WAAS4H,aAAT,CAAuBC,MAAvB,EAA+B;AAC3B,QAAIC,CAAJ;AAAA,QAAOC,GAAP;AAAA,QAAYvB,EAAZ;AAAA,QAAgBwB,IAAI,GAAG,CAAvB;AAEAD,IAAAA,GAAG,GAAIF,MAAM,KAAK,GAAZ,GAAmB,CAAnB,GAAuB,CAA7B;;AACA,SAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,GAAhB,EAAqB,EAAED,CAAvB,EAA0B;AACtB,UAAI9H,KAAK,GAAGG,MAAR,IAAkBuG,UAAU,CAAC5G,MAAM,CAACE,KAAD,CAAP,CAAhC,EAAiD;AAC7CwG,QAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,EAAN,CAAX;AACAgI,QAAAA,IAAI,GAAGA,IAAI,GAAG,EAAP,GAAY,mBAAmBvB,OAAnB,CAA2BD,EAAE,CAACyB,WAAH,EAA3B,CAAnB;AACH,OAHD,MAGO;AACH,eAAO,EAAP;AACH;AACJ;;AACD,WAAOC,MAAM,CAACC,YAAP,CAAoBH,IAApB,CAAP;AACH;;AAED,WAASI,cAAT,GAA0B;AACtB,QAAI5B,EAAJ,EAAQ6B,KAAR,EAAelB,EAAf,EAAmBmB,OAAnB;AAEA9B,IAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,QAAI,CAAC+G,iBAAiB,CAACP,EAAD,CAAtB,EAA4B;AACxB;AACH;;AAED6B,IAAAA,KAAK,GAAGrI,KAAR;;AACA,QAAIwG,EAAE,KAAK,IAAX,EAAiB;AACb,QAAExG,KAAF;;AACA,UAAIF,MAAM,CAACE,KAAD,CAAN,KAAkB,GAAtB,EAA2B;AACvB;AACH;;AACD,QAAEA,KAAF;AACAsI,MAAAA,OAAO,GAAGtI,KAAV;AACAwG,MAAAA,EAAE,GAAGoB,aAAa,CAAC,GAAD,CAAlB;;AACA,UAAIpB,EAAJ,EAAQ;AACJ,YAAIA,EAAE,KAAK,IAAP,IAAe,CAACO,iBAAiB,CAACP,EAAD,CAArC,EAA2C;AACvC;AACH;;AACDW,QAAAA,EAAE,GAAGX,EAAL;AACH,OALD,MAKO;AACHxG,QAAAA,KAAK,GAAGsI,OAAR;AACAnB,QAAAA,EAAE,GAAG,GAAL;AACH;AACJ,KAjBD,MAiBO;AACHA,MAAAA,EAAE,GAAGrH,MAAM,CAACE,KAAK,EAAN,CAAX;AACH;;AAED,WAAOA,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,MAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,UAAI,CAACiH,gBAAgB,CAACT,EAAD,CAArB,EAA2B;AACvB;AACH;;AACD,UAAIA,EAAE,KAAK,IAAX,EAAiB;AACb,UAAExG,KAAF;;AACA,YAAIF,MAAM,CAACE,KAAD,CAAN,KAAkB,GAAtB,EAA2B;AACvB;AACH;;AACD,UAAEA,KAAF;AACAsI,QAAAA,OAAO,GAAGtI,KAAV;AACAwG,QAAAA,EAAE,GAAGoB,aAAa,CAAC,GAAD,CAAlB;;AACA,YAAIpB,EAAJ,EAAQ;AACJ,cAAIA,EAAE,KAAK,IAAP,IAAe,CAACS,gBAAgB,CAACT,EAAD,CAApC,EAA0C;AACtC;AACH;;AACDW,UAAAA,EAAE,IAAIX,EAAN;AACH,SALD,MAKO;AACHxG,UAAAA,KAAK,GAAGsI,OAAR;AACAnB,UAAAA,EAAE,IAAI,GAAN;AACH;AACJ,OAjBD,MAiBO;AACHA,QAAAA,EAAE,IAAIrH,MAAM,CAACE,KAAK,EAAN,CAAZ;AACH;AACJ,KAvDqB,CAyDtB;AACA;;;AACA,QAAImH,EAAE,CAAChH,MAAH,KAAc,CAAlB,EAAqB;AACjB,aAAO;AACHoI,QAAAA,IAAI,EAAE/I,KAAK,CAACiB,UADT;AAEH+H,QAAAA,KAAK,EAAErB,EAFJ;AAGHlH,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH;;AAED,QAAIsH,SAAS,CAACH,EAAD,CAAb,EAAmB;AACf,aAAO;AACHoB,QAAAA,IAAI,EAAE/I,KAAK,CAACkB,OADT;AAEH8H,QAAAA,KAAK,EAAErB,EAFJ;AAGHlH,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH,KA7EqB,CA+EtB;;;AAEA,QAAImH,EAAE,KAAK,MAAX,EAAmB;AACf,aAAO;AACHoB,QAAAA,IAAI,EAAE/I,KAAK,CAACmB,WADT;AAEH6H,QAAAA,KAAK,EAAErB,EAFJ;AAGHlH,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH,KAzFqB,CA2FtB;;;AAEA,QAAImH,EAAE,KAAK,MAAP,IAAiBA,EAAE,KAAK,OAA5B,EAAqC;AACjC,aAAO;AACHoB,QAAAA,IAAI,EAAE/I,KAAK,CAACe,cADT;AAEHiI,QAAAA,KAAK,EAAErB,EAFJ;AAGHlH,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH;;AAED,WAAO;AACHuI,MAAAA,IAAI,EAAE/I,KAAK,CAACiB,UADT;AAEH+H,MAAAA,KAAK,EAAErB,EAFJ;AAGHlH,MAAAA,UAAU,EAAEA,UAHT;AAIHC,MAAAA,SAAS,EAAEA,SAJR;AAKHuI,MAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,KAAP;AAOH,GA1esB,CA4evB;;;AAEA,WAAS0I,cAAT,GAA0B;AACtB,QAAIL,KAAK,GAAGrI,KAAZ;AAAA,QACI2I,GAAG,GAAG7I,MAAM,CAACE,KAAD,CADhB;AAAA,QAEI4I,GAFJ;AAAA,QAGIC,GAHJ;AAAA,QAIIC,GAJJ,CADsB,CAOtB;;AAEA,QAAIH,GAAG,KAAK,GAAR,IAAeA,GAAG,KAAK,GAAvB,IAA8BA,GAAG,KAAK,GAA1C,EAA+C;AAC3C,QAAE3I,KAAF;AACA,aAAO;AACHuI,QAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,QAAAA,KAAK,EAAEG,GAFJ;AAGH1I,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH;;AAED,QAAI2I,GAAG,KAAK,GAAR,IAAeA,GAAG,KAAK,GAAvB,IAA8BA,GAAG,KAAK,GAA1C,EAA+C;AAC3C,QAAE3I,KAAF;AACA,aAAO;AACHuI,QAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,QAAAA,KAAK,EAAEG,GAFJ;AAGH1I,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH,KA7BqB,CA+BtB;AACA;;;AAEA4I,IAAAA,GAAG,GAAG9I,MAAM,CAACE,KAAK,GAAG,CAAT,CAAZ;;AACA,QAAI2I,GAAG,KAAK,GAAR,IAAe,CAACpC,cAAc,CAACqC,GAAD,CAAlC,EAAyC;AACrC,aAAO;AACHL,QAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,QAAAA,KAAK,EAAE1I,MAAM,CAACE,KAAK,EAAN,CAFV;AAGHC,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH,KA3CqB,CA6CtB;;;AAEA6I,IAAAA,GAAG,GAAG/I,MAAM,CAACE,KAAK,GAAG,CAAT,CAAZ;AACA8I,IAAAA,GAAG,GAAGhJ,MAAM,CAACE,KAAK,GAAG,CAAT,CAAZ,CAhDsB,CAkDtB;;AAEA,QAAI2I,GAAG,KAAK,GAAR,IAAeC,GAAG,KAAK,GAAvB,IAA8BC,GAAG,KAAK,GAA1C,EAA+C;AAC3C,UAAIC,GAAG,KAAK,GAAZ,EAAiB;AACb9I,QAAAA,KAAK,IAAI,CAAT;AACA,eAAO;AACHuI,UAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,UAAAA,KAAK,EAAE,MAFJ;AAGHvI,UAAAA,UAAU,EAAEA,UAHT;AAIHC,UAAAA,SAAS,EAAEA,SAJR;AAKHuI,UAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,SAAP;AAOH;AACJ,KA/DqB,CAiEtB;;;AAEA,QAAI2I,GAAG,KAAK,GAAR,IAAeC,GAAG,KAAK,GAAvB,IAA8BC,GAAG,KAAK,GAA1C,EAA+C;AAC3C7I,MAAAA,KAAK,IAAI,CAAT;AACA,aAAO;AACHuI,QAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,QAAAA,KAAK,EAAE,KAFJ;AAGHvI,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH;;AAED,QAAI2I,GAAG,KAAK,GAAR,IAAeC,GAAG,KAAK,GAAvB,IAA8BC,GAAG,KAAK,GAA1C,EAA+C;AAC3C7I,MAAAA,KAAK,IAAI,CAAT;AACA,aAAO;AACHuI,QAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,QAAAA,KAAK,EAAE,KAFJ;AAGHvI,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH;;AAED,QAAI2I,GAAG,KAAK,GAAR,IAAeC,GAAG,KAAK,GAAvB,IAA8BC,GAAG,KAAK,GAA1C,EAA+C;AAC3C7I,MAAAA,KAAK,IAAI,CAAT;AACA,aAAO;AACHuI,QAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,QAAAA,KAAK,EAAE,KAFJ;AAGHvI,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH;;AAED,QAAI2I,GAAG,KAAK,GAAR,IAAeC,GAAG,KAAK,GAAvB,IAA8BC,GAAG,KAAK,GAA1C,EAA+C;AAC3C7I,MAAAA,KAAK,IAAI,CAAT;AACA,aAAO;AACHuI,QAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,QAAAA,KAAK,EAAE,KAFJ;AAGHvI,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH;;AAED,QAAI2I,GAAG,KAAK,GAAR,IAAeC,GAAG,KAAK,GAAvB,IAA8BC,GAAG,KAAK,GAA1C,EAA+C;AAC3C7I,MAAAA,KAAK,IAAI,CAAT;AACA,aAAO;AACHuI,QAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,QAAAA,KAAK,EAAE,KAFJ;AAGHvI,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH,KAxHqB,CA0HtB;AACA;;;AAEA,QAAI4I,GAAG,KAAK,GAAZ,EAAiB;AACb,UAAI,eAAenC,OAAf,CAAuBkC,GAAvB,KAA+B,CAAnC,EAAsC;AAClC3I,QAAAA,KAAK,IAAI,CAAT;AACA,eAAO;AACHuI,UAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,UAAAA,KAAK,EAAEG,GAAG,GAAGC,GAFV;AAGH3I,UAAAA,UAAU,EAAEA,UAHT;AAIHC,UAAAA,SAAS,EAAEA,SAJR;AAKHuI,UAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,SAAP;AAOH;AACJ;;AAED,QAAI2I,GAAG,KAAKC,GAAR,IAAgB,SAASnC,OAAT,CAAiBkC,GAAjB,KAAyB,CAA7C,EAAiD;AAC7C,UAAI,SAASlC,OAAT,CAAiBmC,GAAjB,KAAyB,CAA7B,EAAgC;AAC5B5I,QAAAA,KAAK,IAAI,CAAT;AACA,eAAO;AACHuI,UAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,UAAAA,KAAK,EAAEG,GAAG,GAAGC,GAFV;AAGH3I,UAAAA,UAAU,EAAEA,UAHT;AAIHC,UAAAA,SAAS,EAAEA,SAJR;AAKHuI,UAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,SAAP;AAOH;AACJ,KArJqB,CAuJtB;;;AAEA,QAAI,oBAAoByG,OAApB,CAA4BkC,GAA5B,KAAoC,CAAxC,EAA2C;AACvC,aAAO;AACHJ,QAAAA,IAAI,EAAE/I,KAAK,CAACqB,UADT;AAEH2H,QAAAA,KAAK,EAAE1I,MAAM,CAACE,KAAK,EAAN,CAFV;AAGHC,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAEA,SAJR;AAKHuI,QAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,OAAP;AAOH;AACJ,GAhpBsB,CAkpBvB;;;AAEA,WAAS+I,kBAAT,GAA8B;AAC1B,QAAIC,MAAJ,EAAYX,KAAZ,EAAmB7B,EAAnB;AAEAA,IAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;AACA6F,IAAAA,MAAM,CAACU,cAAc,CAACC,EAAD,CAAd,IAAuBA,EAAE,KAAK,GAA/B,EACF,oEADE,CAAN;AAGA6B,IAAAA,KAAK,GAAGrI,KAAR;AACAgJ,IAAAA,MAAM,GAAG,EAAT;;AACA,QAAIxC,EAAE,KAAK,GAAX,EAAgB;AACZwC,MAAAA,MAAM,GAAGlJ,MAAM,CAACE,KAAK,EAAN,CAAf;AACAwG,MAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX,CAFY,CAIZ;AACA;;AACA,UAAIgJ,MAAM,KAAK,GAAf,EAAoB;AAChB,YAAIxC,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAAzB,EAA8B;AAC1BwC,UAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;;AACA,iBAAOA,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,YAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,gBAAI,CAAC0G,UAAU,CAACF,EAAD,CAAf,EAAqB;AACjB;AACH;;AACDwC,YAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;AACH;;AAED,cAAIgJ,MAAM,CAAC7I,MAAP,IAAiB,CAArB,EAAwB;AACpB;AACAwH,YAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;;AAED,cAAIzD,KAAK,GAAGG,MAAZ,EAAoB;AAChBqG,YAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,gBAAI+G,iBAAiB,CAACP,EAAD,CAArB,EAA2B;AACvBmB,cAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;AACJ;;AACD,iBAAO;AACH8E,YAAAA,IAAI,EAAE/I,KAAK,CAACoB,cADT;AAEH4H,YAAAA,KAAK,EAAES,QAAQ,CAACD,MAAD,EAAS,EAAT,CAFZ;AAGH/I,YAAAA,UAAU,EAAEA,UAHT;AAIHC,YAAAA,SAAS,EAAEA,SAJR;AAKHuI,YAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,WAAP;AAOH,SA5BD,MA4BO,IAAI2G,YAAY,CAACH,EAAD,CAAhB,EAAsB;AACzBwC,UAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;;AACA,iBAAOA,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,YAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,gBAAI,CAAC2G,YAAY,CAACH,EAAD,CAAjB,EAAuB;AACnB;AACH;;AACDwC,YAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;AACH;;AAED,cAAIA,KAAK,GAAGG,MAAZ,EAAoB;AAChBqG,YAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,gBAAI+G,iBAAiB,CAACP,EAAD,CAAjB,IAAyBD,cAAc,CAACC,EAAD,CAA3C,EAAiD;AAC7CmB,cAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;AACJ;;AACD,iBAAO;AACH8E,YAAAA,IAAI,EAAE/I,KAAK,CAACoB,cADT;AAEH4H,YAAAA,KAAK,EAAES,QAAQ,CAACD,MAAD,EAAS,CAAT,CAFZ;AAGHE,YAAAA,KAAK,EAAE,IAHJ;AAIHjJ,YAAAA,UAAU,EAAEA,UAJT;AAKHC,YAAAA,SAAS,EAAEA,SALR;AAMHuI,YAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AANJ,WAAP;AAQH,SArDe,CAuDhB;;;AACA,YAAIuG,cAAc,CAACC,EAAD,CAAlB,EAAwB;AACpBmB,UAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;AACJ;;AAED,aAAOzD,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,QAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,YAAI,CAACuG,cAAc,CAACC,EAAD,CAAnB,EAAyB;AACrB;AACH;;AACDwC,QAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;AACH;AACJ;;AAED,QAAIwG,EAAE,KAAK,GAAX,EAAgB;AACZwC,MAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;;AACA,aAAOA,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,QAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,YAAI,CAACuG,cAAc,CAACC,EAAD,CAAnB,EAAyB;AACrB;AACH;;AACDwC,QAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;AACH;AACJ;;AAED,QAAIwG,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAAzB,EAA8B;AAC1BwC,MAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;AAEAwG,MAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,UAAIwG,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAAzB,EAA8B;AAC1BwC,QAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;AACH;;AAEDwG,MAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,UAAIuG,cAAc,CAACC,EAAD,CAAlB,EAAwB;AACpBwC,QAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;;AACA,eAAOA,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,UAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,cAAI,CAACuG,cAAc,CAACC,EAAD,CAAnB,EAAyB;AACrB;AACH;;AACDwC,UAAAA,MAAM,IAAIlJ,MAAM,CAACE,KAAK,EAAN,CAAhB;AACH;AACJ,OATD,MASO;AACHwG,QAAAA,EAAE,GAAG,eAAeA,EAApB;;AACA,YAAIxG,KAAK,IAAIG,MAAb,EAAqB;AACjBqG,UAAAA,EAAE,GAAG,OAAL;AACH;;AACDmB,QAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;AACJ;;AAED,QAAIzD,KAAK,GAAGG,MAAZ,EAAoB;AAChBqG,MAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,UAAI+G,iBAAiB,CAACP,EAAD,CAArB,EAA2B;AACvBmB,QAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;AACJ;;AAED,WAAO;AACH8E,MAAAA,IAAI,EAAE/I,KAAK,CAACoB,cADT;AAEH4H,MAAAA,KAAK,EAAEW,UAAU,CAACH,MAAD,CAFd;AAGH/I,MAAAA,UAAU,EAAEA,UAHT;AAIHC,MAAAA,SAAS,EAAEA,SAJR;AAKHuI,MAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AALJ,KAAP;AAOH,GA7xBsB,CA+xBvB;;;AAEA,WAASoJ,iBAAT,GAA6B;AACzB,QAAIC,GAAG,GAAG,EAAV;AAAA,QAAcC,KAAd;AAAA,QAAqBjB,KAArB;AAAA,QAA4B7B,EAA5B;AAAA,QAAgCwB,IAAhC;AAAA,QAAsCuB,SAAtC;AAAA,QAAiDjB,OAAjD;AAAA,QAA0DY,KAAK,GAAG,KAAlE;AAEAI,IAAAA,KAAK,GAAGxJ,MAAM,CAACE,KAAD,CAAd;AACA6F,IAAAA,MAAM,CAAEyD,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,GAA9B,EACF,yCADE,CAAN;AAGAjB,IAAAA,KAAK,GAAGrI,KAAR;AACA,MAAEA,KAAF;;AAEA,WAAOA,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,MAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,EAAN,CAAX;;AAEA,UAAIwG,EAAE,KAAK8C,KAAX,EAAkB;AACdA,QAAAA,KAAK,GAAG,EAAR;AACA;AACH,OAHD,MAGO,IAAI9C,EAAE,KAAK,IAAX,EAAiB;AACpBA,QAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,EAAN,CAAX;;AACA,YAAI,CAAC8G,gBAAgB,CAACN,EAAD,CAArB,EAA2B;AACvB,kBAAQA,EAAR;AACA,iBAAK,GAAL;AACI6C,cAAAA,GAAG,IAAI,IAAP;AACA;;AACJ,iBAAK,GAAL;AACIA,cAAAA,GAAG,IAAI,IAAP;AACA;;AACJ,iBAAK,GAAL;AACIA,cAAAA,GAAG,IAAI,IAAP;AACA;;AACJ,iBAAK,GAAL;AACA,iBAAK,GAAL;AACIf,cAAAA,OAAO,GAAGtI,KAAV;AACAuJ,cAAAA,SAAS,GAAG3B,aAAa,CAACpB,EAAD,CAAzB;;AACA,kBAAI+C,SAAJ,EAAe;AACXF,gBAAAA,GAAG,IAAIE,SAAP;AACH,eAFD,MAEO;AACHvJ,gBAAAA,KAAK,GAAGsI,OAAR;AACAe,gBAAAA,GAAG,IAAI7C,EAAP;AACH;;AACD;;AACJ,iBAAK,GAAL;AACI6C,cAAAA,GAAG,IAAI,IAAP;AACA;;AACJ,iBAAK,GAAL;AACIA,cAAAA,GAAG,IAAI,IAAP;AACA;;AACJ,iBAAK,GAAL;AACIA,cAAAA,GAAG,IAAI,MAAP;AACA;;AAEJ;AACI,kBAAI1C,YAAY,CAACH,EAAD,CAAhB,EAAsB;AAClBwB,gBAAAA,IAAI,GAAG,WAAWvB,OAAX,CAAmBD,EAAnB,CAAP,CADkB,CAGlB;;AACA,oBAAIwB,IAAI,KAAK,CAAb,EAAgB;AACZkB,kBAAAA,KAAK,GAAG,IAAR;AACH;;AAED,oBAAIlJ,KAAK,GAAGG,MAAR,IAAkBwG,YAAY,CAAC7G,MAAM,CAACE,KAAD,CAAP,CAAlC,EAAmD;AAC/CkJ,kBAAAA,KAAK,GAAG,IAAR;AACAlB,kBAAAA,IAAI,GAAGA,IAAI,GAAG,CAAP,GAAW,WAAWvB,OAAX,CAAmB3G,MAAM,CAACE,KAAK,EAAN,CAAzB,CAAlB,CAF+C,CAI/C;AACA;;AACA,sBAAI,OAAOyG,OAAP,CAAeD,EAAf,KAAsB,CAAtB,IACIxG,KAAK,GAAGG,MADZ,IAEIwG,YAAY,CAAC7G,MAAM,CAACE,KAAD,CAAP,CAFpB,EAEqC;AACjCgI,oBAAAA,IAAI,GAAGA,IAAI,GAAG,CAAP,GAAW,WAAWvB,OAAX,CAAmB3G,MAAM,CAACE,KAAK,EAAN,CAAzB,CAAlB;AACH;AACJ;;AACDqJ,gBAAAA,GAAG,IAAInB,MAAM,CAACC,YAAP,CAAoBH,IAApB,CAAP;AACH,eArBD,MAqBO;AACHqB,gBAAAA,GAAG,IAAI7C,EAAP;AACH;;AACD;AAxDJ;AA0DH,SA3DD,MA2DO;AACH,YAAEvG,UAAF;;AACA,cAAIuG,EAAE,KAAM,IAAR,IAAgB1G,MAAM,CAACE,KAAD,CAAN,KAAkB,IAAtC,EAA4C;AACxC,cAAEA,KAAF;AACH;AACJ;AACJ,OAnEM,MAmEA,IAAI8G,gBAAgB,CAACN,EAAD,CAApB,EAA0B;AAC7B;AACH,OAFM,MAEA;AACH6C,QAAAA,GAAG,IAAI7C,EAAP;AACH;AACJ;;AAED,QAAI8C,KAAK,KAAK,EAAd,EAAkB;AACd3B,MAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;;AAED,WAAO;AACH8E,MAAAA,IAAI,EAAE/I,KAAK,CAACsB,aADT;AAEH0H,MAAAA,KAAK,EAAEa,GAFJ;AAGHH,MAAAA,KAAK,EAAEA,KAHJ;AAIHjJ,MAAAA,UAAU,EAAEA,UAJT;AAKHC,MAAAA,SAAS,EAAEA,SALR;AAMHuI,MAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AANJ,KAAP;AAQH;;AAED,WAASwJ,UAAT,GAAsB;AAClB,QAAIH,GAAJ;AAAA,QAAS7C,EAAT;AAAA,QAAa6B,KAAb;AAAA,QAAoBoB,OAApB;AAAA,QAA6BC,KAA7B;AAAA,QAAoClB,KAApC;AAAA,QAA2CmB,WAAW,GAAG,KAAzD;AAAA,QAAgErB,OAAhE;AAAA,QAAyEsB,UAAU,GAAG,KAAtF;AAEAxJ,IAAAA,MAAM,GAAG,IAAT;AACAoH,IAAAA,WAAW;AAEXa,IAAAA,KAAK,GAAGrI,KAAR;AACAwG,IAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;AACA6F,IAAAA,MAAM,CAACW,EAAE,KAAK,GAAR,EAAa,oDAAb,CAAN;AACA6C,IAAAA,GAAG,GAAGvJ,MAAM,CAACE,KAAK,EAAN,CAAZ;;AAEA,WAAOA,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,MAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,EAAN,CAAX;AACAqJ,MAAAA,GAAG,IAAI7C,EAAP;;AACA,UAAIA,EAAE,KAAK,IAAX,EAAiB;AACbA,QAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,EAAN,CAAX,CADa,CAEb;;AACA,YAAI8G,gBAAgB,CAACN,EAAD,CAApB,EAA0B;AACtBmB,UAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAACqE,kBAAd,CAAV;AACH;;AACDoF,QAAAA,GAAG,IAAI7C,EAAP;AACH,OAPD,MAOO,IAAImD,WAAJ,EAAiB;AACpB,YAAInD,EAAE,KAAK,GAAX,EAAgB;AACZmD,UAAAA,WAAW,GAAG,KAAd;AACH;AACJ,OAJM,MAIA;AACH,YAAInD,EAAE,KAAK,GAAX,EAAgB;AACZoD,UAAAA,UAAU,GAAG,IAAb;AACA;AACH,SAHD,MAGO,IAAIpD,EAAE,KAAK,GAAX,EAAgB;AACnBmD,UAAAA,WAAW,GAAG,IAAd;AACH,SAFM,MAEA,IAAI7C,gBAAgB,CAACN,EAAD,CAApB,EAA0B;AAC7BmB,UAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAACqE,kBAAd,CAAV;AACH;AACJ;AACJ;;AAED,QAAI,CAAC2F,UAAL,EAAiB;AACbjC,MAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAACqE,kBAAd,CAAV;AACH,KAvCiB,CAyClB;;;AACAwF,IAAAA,OAAO,GAAGJ,GAAG,CAACQ,MAAJ,CAAW,CAAX,EAAcR,GAAG,CAAClJ,MAAJ,GAAa,CAA3B,CAAV;AAEAuJ,IAAAA,KAAK,GAAG,EAAR;;AACA,WAAO1J,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,MAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,UAAI,CAACiH,gBAAgB,CAACT,EAAD,CAArB,EAA2B;AACvB;AACH;;AAED,QAAExG,KAAF;;AACA,UAAIwG,EAAE,KAAK,IAAP,IAAexG,KAAK,GAAGG,MAA3B,EAAmC;AAC/BqG,QAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,YAAIwG,EAAE,KAAK,GAAX,EAAgB;AACZ,YAAExG,KAAF;AACAsI,UAAAA,OAAO,GAAGtI,KAAV;AACAwG,UAAAA,EAAE,GAAGoB,aAAa,CAAC,GAAD,CAAlB;;AACA,cAAIpB,EAAJ,EAAQ;AACJkD,YAAAA,KAAK,IAAIlD,EAAT;AACA6C,YAAAA,GAAG,IAAI,KAAP;;AACA,mBAAOf,OAAO,GAAGtI,KAAjB,EAAwB,EAAEsI,OAA1B,EAAmC;AAC/Be,cAAAA,GAAG,IAAIvJ,MAAM,CAACwI,OAAD,CAAb;AACH;AACJ,WAND,MAMO;AACHtI,YAAAA,KAAK,GAAGsI,OAAR;AACAoB,YAAAA,KAAK,IAAI,GAAT;AACAL,YAAAA,GAAG,IAAI,KAAP;AACH;AACJ,SAfD,MAeO;AACHA,UAAAA,GAAG,IAAI,IAAP;AACH;AACJ,OApBD,MAoBO;AACHK,QAAAA,KAAK,IAAIlD,EAAT;AACA6C,QAAAA,GAAG,IAAI7C,EAAP;AACH;AACJ;;AAED,QAAI;AACAgC,MAAAA,KAAK,GAAG,IAAI7C,MAAJ,CAAW8D,OAAX,EAAoBC,KAApB,CAAR;AACH,KAFD,CAEE,OAAOI,CAAP,EAAU;AACRnC,MAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAACoE,aAAd,CAAV;AACH;;AAED,WAAO;AACH+F,MAAAA,OAAO,EAAEV,GADN;AAEHb,MAAAA,KAAK,EAAEA,KAFJ;AAGHC,MAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQrI,KAAR;AAHJ,KAAP;AAKH;;AAED,WAASgK,gBAAT,CAA0BC,KAA1B,EAAiC;AAC7B,WAAOA,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACiB,UAArB,IACHwJ,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACkB,OADlB,IAEHuJ,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACe,cAFlB,IAGH0J,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACmB,WAHzB;AAIH;;AAED,WAASuJ,OAAT,GAAmB;AACf,QAAI1D,EAAJ,EAAQyD,KAAR;AAEAzC,IAAAA,WAAW;;AAEX,QAAIxH,KAAK,IAAIG,MAAb,EAAqB;AACjB,aAAO;AACHoI,QAAAA,IAAI,EAAE/I,KAAK,CAACgB,GADT;AAEHP,QAAAA,UAAU,EAAEA,UAFT;AAGHC,QAAAA,SAAS,EAAEA,SAHR;AAIHuI,QAAAA,KAAK,EAAE,CAACzI,KAAD,EAAQA,KAAR;AAJJ,OAAP;AAMH;;AAEDiK,IAAAA,KAAK,GAAGvB,cAAc,EAAtB;;AACA,QAAI,OAAOuB,KAAP,KAAiB,WAArB,EAAkC;AAC9B,aAAOA,KAAP;AACH;;AAEDzD,IAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AAEA,QAAIwG,EAAE,KAAK,IAAP,IAAeA,EAAE,KAAK,GAA1B,EAA+B;AAC3B,aAAO4C,iBAAiB,EAAxB;AACH;;AAED,QAAI5C,EAAE,KAAK,GAAP,IAAcD,cAAc,CAACC,EAAD,CAAhC,EAAsC;AAClC,aAAOuC,kBAAkB,EAAzB;AACH;;AAEDkB,IAAAA,KAAK,GAAG7B,cAAc,EAAtB;;AACA,QAAI,OAAO6B,KAAP,KAAiB,WAArB,EAAkC;AAC9B,aAAOA,KAAP;AACH;;AAEDtC,IAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;;AAED,WAAS0G,GAAT,GAAe;AACX,QAAIF,KAAJ;;AAEA,QAAI7J,MAAJ,EAAY;AACRJ,MAAAA,KAAK,GAAGI,MAAM,CAACqI,KAAP,CAAa,CAAb,CAAR;AACAxI,MAAAA,UAAU,GAAGG,MAAM,CAACH,UAApB;AACAC,MAAAA,SAAS,GAAGE,MAAM,CAACF,SAAnB;AACA+J,MAAAA,KAAK,GAAG7J,MAAR;AACAA,MAAAA,MAAM,GAAG,IAAT;AACA,aAAO6J,KAAP;AACH;;AAED7J,IAAAA,MAAM,GAAG,IAAT;AACA,WAAO8J,OAAO,EAAd;AACH;;AAED,WAASE,SAAT,GAAqB;AACjB,QAAIC,GAAJ,EAASC,IAAT,EAAejC,KAAf;;AAEA,QAAIjI,MAAM,KAAK,IAAf,EAAqB;AACjB,aAAOA,MAAP;AACH;;AAEDiK,IAAAA,GAAG,GAAGrK,KAAN;AACAsK,IAAAA,IAAI,GAAGrK,UAAP;AACAoI,IAAAA,KAAK,GAAGnI,SAAR;AACAE,IAAAA,MAAM,GAAG8J,OAAO,EAAhB;AACAlK,IAAAA,KAAK,GAAGqK,GAAR;AACApK,IAAAA,UAAU,GAAGqK,IAAb;AACApK,IAAAA,SAAS,GAAGmI,KAAZ;AAEA,WAAOjI,MAAP;AACH,GAhjCsB,CAkjCvB;;;AAEA,WAASmK,kBAAT,GAA8B;AAC1B,QAAIF,GAAJ,EAASC,IAAT,EAAejC,KAAf,EAAsBmC,KAAtB;AAEAH,IAAAA,GAAG,GAAGrK,KAAN;AACAsK,IAAAA,IAAI,GAAGrK,UAAP;AACAoI,IAAAA,KAAK,GAAGnI,SAAR;AACAsH,IAAAA,WAAW;AACXgD,IAAAA,KAAK,GAAGvK,UAAU,KAAKqK,IAAvB;AACAtK,IAAAA,KAAK,GAAGqK,GAAR;AACApK,IAAAA,UAAU,GAAGqK,IAAb;AACApK,IAAAA,SAAS,GAAGmI,KAAZ;AAEA,WAAOmC,KAAP;AACH,GAjkCsB,CAmkCvB;;;AAEA,WAAS7C,UAAT,CAAoBsC,KAApB,EAA2BQ,aAA3B,EAA0C;AACtC,QAAIC,KAAJ;AAAA,QACIC,IAAI,GAAGC,KAAK,CAACC,SAAN,CAAgBzE,KAAhB,CAAsB0E,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CADX;AAAA,QAEIC,GAAG,GAAGP,aAAa,CAACQ,OAAd,CACF,QADE,EAEF,UAAUC,KAAV,EAAiBlL,KAAjB,EAAwB;AACpB,aAAO2K,IAAI,CAAC3K,KAAD,CAAJ,IAAe,EAAtB;AACH,KAJC,CAFV;;AASA,QAAI,OAAOiK,KAAK,CAAChK,UAAb,KAA4B,QAAhC,EAA0C;AACtCyK,MAAAA,KAAK,GAAG,IAAI1E,KAAJ,CAAU,UAAUiE,KAAK,CAAChK,UAAhB,GAA6B,IAA7B,GAAoC+K,GAA9C,CAAR;AACAN,MAAAA,KAAK,CAAC1K,KAAN,GAAciK,KAAK,CAACxB,KAAN,CAAY,CAAZ,CAAd;AACAiC,MAAAA,KAAK,CAACzK,UAAN,GAAmBgK,KAAK,CAAChK,UAAzB;AACAyK,MAAAA,KAAK,CAACS,MAAN,GAAelB,KAAK,CAACxB,KAAN,CAAY,CAAZ,IAAiBvI,SAAjB,GAA6B,CAA5C;AACH,KALD,MAKO;AACHwK,MAAAA,KAAK,GAAG,IAAI1E,KAAJ,CAAU,UAAU/F,UAAV,GAAuB,IAAvB,GAA8B+K,GAAxC,CAAR;AACAN,MAAAA,KAAK,CAAC1K,KAAN,GAAcA,KAAd;AACA0K,MAAAA,KAAK,CAACzK,UAAN,GAAmBA,UAAnB;AACAyK,MAAAA,KAAK,CAACS,MAAN,GAAenL,KAAK,GAAGE,SAAR,GAAoB,CAAnC;AACH;;AAED,UAAMwK,KAAN;AACH;;AAED,WAASU,kBAAT,GAA8B;AAC1B,QAAI;AACAzD,MAAAA,UAAU,CAAC0D,KAAX,CAAiB,IAAjB,EAAuBN,SAAvB;AACH,KAFD,CAEE,OAAOjB,CAAP,EAAU;AACR,UAAIxJ,KAAK,CAACgL,MAAV,EAAkB;AACdhL,QAAAA,KAAK,CAACgL,MAAN,CAAaC,IAAb,CAAkBzB,CAAlB;AACH,OAFD,MAEO;AACH,cAAMA,CAAN;AACH;AACJ;AACJ,GAxmCsB,CA2mCvB;;;AAEA,WAAS0B,eAAT,CAAyBvB,KAAzB,EAAgC;AAC5B,QAAIA,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACgB,GAAzB,EAA8B;AAC1BmH,MAAAA,UAAU,CAACsC,KAAD,EAAQrK,QAAQ,CAACkE,aAAjB,CAAV;AACH;;AAED,QAAImG,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACoB,cAAzB,EAAyC;AACrC+G,MAAAA,UAAU,CAACsC,KAAD,EAAQrK,QAAQ,CAAC8D,gBAAjB,CAAV;AACH;;AAED,QAAIuG,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACsB,aAAzB,EAAwC;AACpC6G,MAAAA,UAAU,CAACsC,KAAD,EAAQrK,QAAQ,CAAC+D,gBAAjB,CAAV;AACH;;AAED,QAAIsG,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACiB,UAAzB,EAAqC;AACjCkH,MAAAA,UAAU,CAACsC,KAAD,EAAQrK,QAAQ,CAACgE,oBAAjB,CAAV;AACH;;AAED,QAAIqG,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACkB,OAAzB,EAAkC;AAC9B,UAAIwG,oBAAoB,CAAC+C,KAAK,CAACzB,KAAP,CAAxB,EAAuC;AACnCb,QAAAA,UAAU,CAACsC,KAAD,EAAQrK,QAAQ,CAACiE,kBAAjB,CAAV;AACH,OAFD,MAEO,IAAI9D,MAAM,IAAIqH,wBAAwB,CAAC6C,KAAK,CAACzB,KAAP,CAAtC,EAAqD;AACxD4C,QAAAA,kBAAkB,CAACnB,KAAD,EAAQrK,QAAQ,CAAC6F,kBAAjB,CAAlB;AACA;AACH;;AACDkC,MAAAA,UAAU,CAACsC,KAAD,EAAQrK,QAAQ,CAAC6D,eAAjB,EAAkCwG,KAAK,CAACzB,KAAxC,CAAV;AACH,KAzB2B,CA2B5B;;;AACAb,IAAAA,UAAU,CAACsC,KAAD,EAAQrK,QAAQ,CAAC6D,eAAjB,EAAkCwG,KAAK,CAACzB,KAAxC,CAAV;AACH,GA1oCsB,CA4oCvB;AACA;;;AAEA,WAASiD,MAAT,CAAgBjD,KAAhB,EAAuB;AACnB,QAAIyB,KAAK,GAAGE,GAAG,EAAf;;AACA,QAAIF,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACqB,UAArB,IAAmCoJ,KAAK,CAACzB,KAAN,KAAgBA,KAAvD,EAA8D;AAC1DgD,MAAAA,eAAe,CAACvB,KAAD,CAAf;AACH;AACJ,GAppCsB,CAspCvB;AACA;;;AAEA,WAASyB,aAAT,CAAuBnE,OAAvB,EAAgC;AAC5B,QAAI0C,KAAK,GAAGE,GAAG,EAAf;;AACA,QAAIF,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACkB,OAArB,IAAgCuJ,KAAK,CAACzB,KAAN,KAAgBjB,OAApD,EAA6D;AACzDiE,MAAAA,eAAe,CAACvB,KAAD,CAAf;AACH;AACJ,GA9pCsB,CAgqCvB;;;AAEA,WAAS0B,KAAT,CAAenD,KAAf,EAAsB;AAClB,QAAIyB,KAAK,GAAGG,SAAS,EAArB;AACA,WAAOH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACqB,UAArB,IAAmCoJ,KAAK,CAACzB,KAAN,KAAgBA,KAA1D;AACH,GArqCsB,CAuqCvB;;;AAEA,WAASoD,YAAT,CAAsBrE,OAAtB,EAA+B;AAC3B,QAAI0C,KAAK,GAAGG,SAAS,EAArB;AACA,WAAOH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACkB,OAArB,IAAgCuJ,KAAK,CAACzB,KAAN,KAAgBjB,OAAvD;AACH,GA5qCsB,CA8qCvB;;;AAEA,WAASsE,WAAT,GAAuB;AACnB,QAAI5B,KAAK,GAAGG,SAAS,EAArB;AAAA,QACI0B,EAAE,GAAG7B,KAAK,CAACzB,KADf;;AAGA,QAAIyB,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACqB,UAAzB,EAAqC;AACjC,aAAO,KAAP;AACH;;AACD,WAAOiL,EAAE,KAAK,GAAP,IACHA,EAAE,KAAK,IADJ,IAEHA,EAAE,KAAK,IAFJ,IAGHA,EAAE,KAAK,IAHJ,IAIHA,EAAE,KAAK,IAJJ,IAKHA,EAAE,KAAK,IALJ,IAMHA,EAAE,KAAK,KANJ,IAOHA,EAAE,KAAK,KAPJ,IAQHA,EAAE,KAAK,MARJ,IASHA,EAAE,KAAK,IATJ,IAUHA,EAAE,KAAK,IAVJ,IAWHA,EAAE,KAAK,IAXX;AAYH;;AAED,WAASC,gBAAT,GAA4B;AACxB,QAAI9B,KAAJ,EAAWK,IAAX,CADwB,CAGxB;;AACA,QAAIxK,MAAM,CAACE,KAAD,CAAN,KAAkB,GAAtB,EAA2B;AACvBmK,MAAAA,GAAG;AACH;AACH;;AAEDG,IAAAA,IAAI,GAAGrK,UAAP;AACAuH,IAAAA,WAAW;;AACX,QAAIvH,UAAU,KAAKqK,IAAnB,EAAyB;AACrB;AACH;;AAED,QAAIqB,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZxB,MAAAA,GAAG;AACH;AACH;;AAEDF,IAAAA,KAAK,GAAGG,SAAS,EAAjB;;AACA,QAAIH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACgB,GAArB,IAA4B,CAACmL,KAAK,CAAC,GAAD,CAAtC,EAA6C;AACzCH,MAAAA,eAAe,CAACvB,KAAD,CAAf;AACH;AACJ,GA7tCsB,CA+tCvB;;;AAEA,WAAS+B,cAAT,CAAwBC,IAAxB,EAA8B;AAC1B,WAAOA,IAAI,CAAC1D,IAAL,KAAc7I,MAAM,CAACe,UAArB,IAAmCwL,IAAI,CAAC1D,IAAL,KAAc7I,MAAM,CAAC0C,gBAA/D;AACH,GAnuCsB,CAquCvB;;;AAEA,WAAS8J,qBAAT,GAAiC;AAC7B,QAAIC,QAAQ,GAAG,EAAf;AAEAV,IAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,WAAO,CAACE,KAAK,CAAC,GAAD,CAAb,EAAoB;AAChB,UAAIA,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZxB,QAAAA,GAAG;AACHgC,QAAAA,QAAQ,CAACZ,IAAT,CAAc,IAAd;AACH,OAHD,MAGO;AACHY,QAAAA,QAAQ,CAACZ,IAAT,CAAca,yBAAyB,EAAvC;;AAEA,YAAI,CAACT,KAAK,CAAC,GAAD,CAAV,EAAiB;AACbF,UAAAA,MAAM,CAAC,GAAD,CAAN;AACH;AACJ;AACJ;;AAEDA,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA,WAAO;AACHlD,MAAAA,IAAI,EAAE7I,MAAM,CAACsB,eADV;AAEHmL,MAAAA,QAAQ,EAAEA;AAFP,KAAP;AAIH,GA/vCsB,CAiwCvB;;;AAEA,WAASE,qBAAT,CAA+BC,KAA/B,EAAsCC,KAAtC,EAA6C;AACzC,QAAIC,cAAJ,EAAoBC,IAApB;AAEAD,IAAAA,cAAc,GAAGzM,MAAjB;AACA0M,IAAAA,IAAI,GAAGC,2BAA2B,EAAlC;;AACA,QAAIH,KAAK,IAAIxM,MAAT,IAAmBsH,gBAAgB,CAACiF,KAAK,CAAC,CAAD,CAAL,CAASK,IAAV,CAAvC,EAAwD;AACpDvB,MAAAA,kBAAkB,CAACmB,KAAD,EAAQ3M,QAAQ,CAACkF,eAAjB,CAAlB;AACH;;AACD/E,IAAAA,MAAM,GAAGyM,cAAT;AAEA,WAAO;AACHjE,MAAAA,IAAI,EAAE7I,MAAM,CAACqC,kBADV;AAEHoF,MAAAA,EAAE,EAAE,IAFD;AAGHyF,MAAAA,MAAM,EAAEN,KAHL;AAIHO,MAAAA,QAAQ,EAAE,EAJP;AAKHJ,MAAAA,IAAI,EAAEA,IALH;AAMHK,MAAAA,IAAI,EAAE,IANH;AAOHC,MAAAA,SAAS,EAAE,KAPR;AAQHC,MAAAA,UAAU,EAAE;AART,KAAP;AAUH;;AAED,WAASC,sBAAT,GAAkC;AAC9B,QAAIhD,KAAK,GAAGE,GAAG,EAAf,CAD8B,CAG9B;AACA;;AAEA,QAAIF,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACsB,aAArB,IAAsCmJ,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACoB,cAA/D,EAA+E;AAC3E,UAAIb,MAAM,IAAIkK,KAAK,CAACf,KAApB,EAA2B;AACvBkC,QAAAA,kBAAkB,CAACnB,KAAD,EAAQrK,QAAQ,CAACqF,kBAAjB,CAAlB;AACH;;AACD,aAAOiI,aAAa,CAACjD,KAAD,CAApB;AACH;;AAED,WAAO;AACH1B,MAAAA,IAAI,EAAE7I,MAAM,CAACe,UADV;AAEHkM,MAAAA,IAAI,EAAE1C,KAAK,CAACzB;AAFT,KAAP;AAIH;;AAED,WAAS2E,mBAAT,GAA+B;AAC3B,QAAIlD,KAAJ,EAAWmD,GAAX,EAAgBjG,EAAhB,EAAoBmF,KAApB;AAEArC,IAAAA,KAAK,GAAGG,SAAS,EAAjB;;AAEA,QAAIH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACiB,UAAzB,EAAqC;AAEjC0G,MAAAA,EAAE,GAAG8F,sBAAsB,EAA3B,CAFiC,CAIjC;;AAEA,UAAIhD,KAAK,CAACzB,KAAN,KAAgB,KAAhB,IAAyB,CAACmD,KAAK,CAAC,GAAD,CAAnC,EAA0C;AACtCyB,QAAAA,GAAG,GAAGH,sBAAsB,EAA5B;AACAxB,QAAAA,MAAM,CAAC,GAAD,CAAN;AACAA,QAAAA,MAAM,CAAC,GAAD,CAAN;AACA,eAAO;AACHlD,UAAAA,IAAI,EAAE7I,MAAM,CAAC8C,QADV;AAEH4K,UAAAA,GAAG,EAAEA,GAFF;AAGH5E,UAAAA,KAAK,EAAE6D,qBAAqB,CAAC,EAAD,CAHzB;AAIHgB,UAAAA,IAAI,EAAE;AAJH,SAAP;AAMH,OAVD,MAUO,IAAIpD,KAAK,CAACzB,KAAN,KAAgB,KAAhB,IAAyB,CAACmD,KAAK,CAAC,GAAD,CAAnC,EAA0C;AAC7CyB,QAAAA,GAAG,GAAGH,sBAAsB,EAA5B;AACAxB,QAAAA,MAAM,CAAC,GAAD,CAAN;AACAxB,QAAAA,KAAK,GAAGG,SAAS,EAAjB;;AACA,YAAIH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACiB,UAAzB,EAAqC;AACjCgL,UAAAA,MAAM,CAAC,GAAD,CAAN;AACAL,UAAAA,kBAAkB,CAACnB,KAAD,EAAQrK,QAAQ,CAAC6D,eAAjB,EAAkCwG,KAAK,CAACzB,KAAxC,CAAlB;AACA,iBAAO;AACHD,YAAAA,IAAI,EAAE7I,MAAM,CAAC8C,QADV;AAEH4K,YAAAA,GAAG,EAAEA,GAFF;AAGH5E,YAAAA,KAAK,EAAE6D,qBAAqB,CAAC,EAAD,CAHzB;AAIHgB,YAAAA,IAAI,EAAE;AAJH,WAAP;AAMH,SATD,MASO;AACHf,UAAAA,KAAK,GAAG,CAAEgB,uBAAuB,EAAzB,CAAR;AACA7B,UAAAA,MAAM,CAAC,GAAD,CAAN;AACA,iBAAO;AACHlD,YAAAA,IAAI,EAAE7I,MAAM,CAAC8C,QADV;AAEH4K,YAAAA,GAAG,EAAEA,GAFF;AAGH5E,YAAAA,KAAK,EAAE6D,qBAAqB,CAACC,KAAD,EAAQrC,KAAR,CAHzB;AAIHoD,YAAAA,IAAI,EAAE;AAJH,WAAP;AAMH;AACJ,OAvBM,MAuBA;AACH5B,QAAAA,MAAM,CAAC,GAAD,CAAN;AACA,eAAO;AACHlD,UAAAA,IAAI,EAAE7I,MAAM,CAAC8C,QADV;AAEH4K,UAAAA,GAAG,EAAEjG,EAFF;AAGHqB,UAAAA,KAAK,EAAE4D,yBAAyB,EAH7B;AAIHiB,UAAAA,IAAI,EAAE;AAJH,SAAP;AAMH;AACJ,KAhDD,MAgDO,IAAIpD,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACgB,GAArB,IAA4ByJ,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACqB,UAArD,EAAiE;AACpE2K,MAAAA,eAAe,CAACvB,KAAD,CAAf;AACH,KAFM,MAEA;AACHmD,MAAAA,GAAG,GAAGH,sBAAsB,EAA5B;AACAxB,MAAAA,MAAM,CAAC,GAAD,CAAN;AACA,aAAO;AACHlD,QAAAA,IAAI,EAAE7I,MAAM,CAAC8C,QADV;AAEH4K,QAAAA,GAAG,EAAEA,GAFF;AAGH5E,QAAAA,KAAK,EAAE4D,yBAAyB,EAH7B;AAIHiB,QAAAA,IAAI,EAAE;AAJH,OAAP;AAMH;AACJ;;AAED,WAASE,sBAAT,GAAkC;AAC9B,QAAIC,UAAU,GAAG,EAAjB;AAAA,QAAqBC,QAArB;AAAA,QAA+Bd,IAA/B;AAAA,QAAqCU,IAArC;AAAA,QAA2CK,GAAG,GAAG,EAAjD;AAAA,QAAqDC,QAAQ,GAAGzF,MAAhE;AAEAuD,IAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,WAAO,CAACE,KAAK,CAAC,GAAD,CAAb,EAAoB;AAChB8B,MAAAA,QAAQ,GAAGN,mBAAmB,EAA9B;;AAEA,UAAIM,QAAQ,CAACL,GAAT,CAAa7E,IAAb,KAAsB7I,MAAM,CAACe,UAAjC,EAA6C;AACzCkM,QAAAA,IAAI,GAAGc,QAAQ,CAACL,GAAT,CAAaT,IAApB;AACH,OAFD,MAEO;AACHA,QAAAA,IAAI,GAAGgB,QAAQ,CAACF,QAAQ,CAACL,GAAT,CAAa5E,KAAd,CAAf;AACH;;AACD6E,MAAAA,IAAI,GAAII,QAAQ,CAACJ,IAAT,KAAkB,MAAnB,GAA6B1N,YAAY,CAAC2D,IAA1C,GAAkDmK,QAAQ,CAACJ,IAAT,KAAkB,KAAnB,GAA4B1N,YAAY,CAAC4D,GAAzC,GAA+C5D,YAAY,CAAC6D,GAApH;;AACA,UAAIoK,MAAM,CAAC/C,SAAP,CAAiBgD,cAAjB,CAAgC/C,IAAhC,CAAqC4C,GAArC,EAA0Cf,IAA1C,CAAJ,EAAqD;AACjD,YAAIe,GAAG,CAACf,IAAD,CAAH,KAAchN,YAAY,CAAC2D,IAA/B,EAAqC;AACjC,cAAIvD,MAAM,IAAIsN,IAAI,KAAK1N,YAAY,CAAC2D,IAApC,EAA0C;AACtC8H,YAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACuF,uBAAd,CAAlB;AACH,WAFD,MAEO,IAAIkI,IAAI,KAAK1N,YAAY,CAAC2D,IAA1B,EAAgC;AACnC8H,YAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACwF,oBAAd,CAAlB;AACH;AACJ,SAND,MAMO;AACH,cAAIiI,IAAI,KAAK1N,YAAY,CAAC2D,IAA1B,EAAgC;AAC5B8H,YAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACwF,oBAAd,CAAlB;AACH,WAFD,MAEO,IAAIsI,GAAG,CAACf,IAAD,CAAH,GAAYU,IAAhB,EAAsB;AACzBjC,YAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACyF,cAAd,CAAlB;AACH;AACJ;;AACDqI,QAAAA,GAAG,CAACf,IAAD,CAAH,IAAaU,IAAb;AACH,OAfD,MAeO;AACHK,QAAAA,GAAG,CAACf,IAAD,CAAH,GAAYU,IAAZ;AACH;;AAEDG,MAAAA,UAAU,CAACjC,IAAX,CAAgBkC,QAAhB;;AAEA,UAAI,CAAC9B,KAAK,CAAC,GAAD,CAAV,EAAiB;AACbF,QAAAA,MAAM,CAAC,GAAD,CAAN;AACH;AACJ;;AAEDA,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA,WAAO;AACHlD,MAAAA,IAAI,EAAE7I,MAAM,CAAC4C,gBADV;AAEHkL,MAAAA,UAAU,EAAEA;AAFT,KAAP;AAIH,GA75CsB,CA+5CvB;;;AAEA,WAASM,oBAAT,GAAgC;AAC5B,QAAI7B,IAAJ;AAEAR,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAQ,IAAAA,IAAI,GAAG8B,eAAe,EAAtB;AAEAtC,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA,WAAOQ,IAAP;AACH,GA36CsB,CA86CvB;;;AAEA,WAAS+B,sBAAT,GAAkC;AAC9B,QAAI/D,KAAK,GAAGG,SAAS,EAArB;AAAA,QACI7B,IAAI,GAAG0B,KAAK,CAAC1B,IADjB;;AAGA,QAAIA,IAAI,KAAK/I,KAAK,CAACiB,UAAnB,EAA+B;AAC3B,aAAO;AACH8H,QAAAA,IAAI,EAAE7I,MAAM,CAACe,UADV;AAEHkM,QAAAA,IAAI,EAAExC,GAAG,GAAG3B;AAFT,OAAP;AAIH;;AAED,QAAID,IAAI,KAAK/I,KAAK,CAACsB,aAAf,IAAgCyH,IAAI,KAAK/I,KAAK,CAACoB,cAAnD,EAAmE;AAC/D,UAAIb,MAAM,IAAIkK,KAAK,CAACf,KAApB,EAA2B;AACvBkC,QAAAA,kBAAkB,CAACnB,KAAD,EAAQrK,QAAQ,CAACqF,kBAAjB,CAAlB;AACH;;AACD,aAAOiI,aAAa,CAAC/C,GAAG,EAAJ,CAApB;AACH;;AAED,QAAI5B,IAAI,KAAK/I,KAAK,CAACkB,OAAnB,EAA4B;AACxB,UAAIkL,YAAY,CAAC,MAAD,CAAhB,EAA0B;AACtBzB,QAAAA,GAAG;AACH,eAAO;AACH5B,UAAAA,IAAI,EAAE7I,MAAM,CAACmD;AADV,SAAP;AAGH;;AAED,UAAI+I,YAAY,CAAC,UAAD,CAAhB,EAA8B;AAC1B,eAAOqC,uBAAuB,EAA9B;AACH;AACJ;;AAED,QAAI1F,IAAI,KAAK/I,KAAK,CAACe,cAAnB,EAAmC;AAC/B4J,MAAAA,GAAG;AACHF,MAAAA,KAAK,CAACzB,KAAN,GAAeyB,KAAK,CAACzB,KAAN,KAAgB,MAA/B;AACA,aAAO0E,aAAa,CAACjD,KAAD,CAApB;AACH;;AAED,QAAI1B,IAAI,KAAK/I,KAAK,CAACmB,WAAnB,EAAgC;AAC5BwJ,MAAAA,GAAG;AACHF,MAAAA,KAAK,CAACzB,KAAN,GAAc,IAAd;AACA,aAAO0E,aAAa,CAACjD,KAAD,CAApB;AACH;;AAED,QAAI0B,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZ,aAAOO,qBAAqB,EAA5B;AACH;;AAED,QAAIP,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZ,aAAO4B,sBAAsB,EAA7B;AACH;;AAED,QAAI5B,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZ,aAAOmC,oBAAoB,EAA3B;AACH;;AAED,QAAInC,KAAK,CAAC,GAAD,CAAL,IAAcA,KAAK,CAAC,IAAD,CAAvB,EAA+B;AAC3B,aAAOuB,aAAa,CAAC1D,UAAU,EAAX,CAApB;AACH;;AAED,WAAOgC,eAAe,CAACrB,GAAG,EAAJ,CAAtB;AACH,GA5+CsB,CA8+CvB;;;AAEA,WAAS+D,cAAT,GAA0B;AACtB,QAAIvD,IAAI,GAAG,EAAX;AAEAc,IAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,QAAI,CAACE,KAAK,CAAC,GAAD,CAAV,EAAiB;AACb,aAAO3L,KAAK,GAAGG,MAAf,EAAuB;AACnBwK,QAAAA,IAAI,CAACY,IAAL,CAAUa,yBAAyB,EAAnC;;AACA,YAAIT,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZ;AACH;;AACDF,QAAAA,MAAM,CAAC,GAAD,CAAN;AACH;AACJ;;AAEDA,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA,WAAOd,IAAP;AACH;;AAED,WAASwD,wBAAT,GAAoC;AAChC,QAAIlE,KAAK,GAAGE,GAAG,EAAf;;AAEA,QAAI,CAACH,gBAAgB,CAACC,KAAD,CAArB,EAA8B;AAC1BuB,MAAAA,eAAe,CAACvB,KAAD,CAAf;AACH;;AAED,WAAO;AACH1B,MAAAA,IAAI,EAAE7I,MAAM,CAACe,UADV;AAEHkM,MAAAA,IAAI,EAAE1C,KAAK,CAACzB;AAFT,KAAP;AAIH;;AAED,WAAS4F,sBAAT,GAAkC;AAC9B3C,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA,WAAO0C,wBAAwB,EAA/B;AACH;;AAED,WAASE,mBAAT,GAA+B;AAC3B,QAAIpC,IAAJ;AAEAR,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAQ,IAAAA,IAAI,GAAG8B,eAAe,EAAtB;AAEAtC,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA,WAAOQ,IAAP;AACH;;AAED,WAASqC,kBAAT,GAA8B;AAC1B,QAAIrC,IAAJ;AAEAP,IAAAA,aAAa,CAAC,KAAD,CAAb;AAEAO,IAAAA,IAAI,GAAG;AACH1D,MAAAA,IAAI,EAAE7I,MAAM,CAAC2C,aADV;AAEHkM,MAAAA,MAAM,EAAEC,2BAA2B,EAFhC;AAGH,mBAAa;AAHV,KAAP;;AAMA,QAAI7C,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZM,MAAAA,IAAI,CAAC,WAAD,CAAJ,GAAoBiC,cAAc,EAAlC;AACH;;AAED,WAAOjC,IAAP;AACH;;AAED,WAASwC,oCAAT,GAAgD;AAC5C,QAAIxC,IAAJ;AAEAA,IAAAA,IAAI,GAAGL,YAAY,CAAC,KAAD,CAAZ,GAAsB0C,kBAAkB,EAAxC,GAA6CN,sBAAsB,EAA1E;;AAEA,WAAOrC,KAAK,CAAC,GAAD,CAAL,IAAcA,KAAK,CAAC,GAAD,CAAnB,IAA4BA,KAAK,CAAC,GAAD,CAAxC,EAA+C;AAC3C,UAAIA,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZM,QAAAA,IAAI,GAAG;AACH1D,UAAAA,IAAI,EAAE7I,MAAM,CAAC0B,cADV;AAEHmN,UAAAA,MAAM,EAAEtC,IAFL;AAGH,uBAAaiC,cAAc;AAHxB,SAAP;AAKH,OAND,MAMO,IAAIvC,KAAK,CAAC,GAAD,CAAT,EAAgB;AACnBM,QAAAA,IAAI,GAAG;AACH1D,UAAAA,IAAI,EAAE7I,MAAM,CAAC0C,gBADV;AAEHsM,UAAAA,QAAQ,EAAE,IAFP;AAGHC,UAAAA,MAAM,EAAE1C,IAHL;AAIHwB,UAAAA,QAAQ,EAAEY,mBAAmB;AAJ1B,SAAP;AAMH,OAPM,MAOA;AACHpC,QAAAA,IAAI,GAAG;AACH1D,UAAAA,IAAI,EAAE7I,MAAM,CAAC0C,gBADV;AAEHsM,UAAAA,QAAQ,EAAE,KAFP;AAGHC,UAAAA,MAAM,EAAE1C,IAHL;AAIHwB,UAAAA,QAAQ,EAAEW,sBAAsB;AAJ7B,SAAP;AAMH;AACJ;;AAED,WAAOnC,IAAP;AACH;;AAGD,WAASuC,2BAAT,GAAuC;AACnC,QAAIvC,IAAJ;AAEAA,IAAAA,IAAI,GAAGL,YAAY,CAAC,KAAD,CAAZ,GAAsB0C,kBAAkB,EAAxC,GAA6CN,sBAAsB,EAA1E;;AAEA,WAAOrC,KAAK,CAAC,GAAD,CAAL,IAAcA,KAAK,CAAC,GAAD,CAA1B,EAAiC;AAC7B,UAAIA,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZM,QAAAA,IAAI,GAAG;AACH1D,UAAAA,IAAI,EAAE7I,MAAM,CAAC0C,gBADV;AAEHsM,UAAAA,QAAQ,EAAE,IAFP;AAGHC,UAAAA,MAAM,EAAE1C,IAHL;AAIHwB,UAAAA,QAAQ,EAAEY,mBAAmB;AAJ1B,SAAP;AAMH,OAPD,MAOO;AACHpC,QAAAA,IAAI,GAAG;AACH1D,UAAAA,IAAI,EAAE7I,MAAM,CAAC0C,gBADV;AAEHsM,UAAAA,QAAQ,EAAE,KAFP;AAGHC,UAAAA,MAAM,EAAE1C,IAHL;AAIHwB,UAAAA,QAAQ,EAAEW,sBAAsB;AAJ7B,SAAP;AAMH;AACJ;;AAED,WAAOnC,IAAP;AACH,GA9mDsB,CAgnDvB;;;AAEA,WAAS2C,sBAAT,GAAkC;AAC9B,QAAI3C,IAAI,GAAGwC,oCAAoC,EAA/C;AAAA,QAAmDxE,KAAnD;AAEAA,IAAAA,KAAK,GAAGG,SAAS,EAAjB;;AACA,QAAIH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACqB,UAAzB,EAAqC;AACjC,aAAOoL,IAAP;AACH;;AAED,QAAI,CAACN,KAAK,CAAC,IAAD,CAAL,IAAeA,KAAK,CAAC,IAAD,CAArB,KAAgC,CAACpB,kBAAkB,EAAvD,EAA2D;AACvD;AACA,UAAIxK,MAAM,IAAIkM,IAAI,CAAC1D,IAAL,KAAc7I,MAAM,CAACe,UAA/B,IAA6C4G,gBAAgB,CAAC4E,IAAI,CAACU,IAAN,CAAjE,EAA8E;AAC1EvB,QAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAAC2F,gBAAd,CAAlB;AACH;;AACD,UAAI,CAACyG,cAAc,CAACC,IAAD,CAAnB,EAA2B;AACvBb,QAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACsE,sBAAd,CAAlB;AACH;;AAED+H,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACuD,gBADV;AAEH4L,QAAAA,QAAQ,EAAE1E,GAAG,GAAG3B,KAFb;AAGHsG,QAAAA,QAAQ,EAAE7C,IAHP;AAIHpE,QAAAA,MAAM,EAAE;AAJL,OAAP;AAMH;;AAED,WAAOoE,IAAP;AACH,GA5oDsB,CA8oDvB;;;AAEA,WAAS8C,oBAAT,GAAgC;AAC5B,QAAI9E,KAAJ,EAAWgC,IAAX;AAEAhC,IAAAA,KAAK,GAAGG,SAAS,EAAjB;;AACA,QAAIH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACqB,UAArB,IAAmCoJ,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACkB,OAA5D,EAAqE;AACjE,aAAOkO,sBAAsB,EAA7B;AACH;;AAED,QAAIjD,KAAK,CAAC,IAAD,CAAL,IAAeA,KAAK,CAAC,IAAD,CAAxB,EAAgC;AAC5B1B,MAAAA,KAAK,GAAGE,GAAG,EAAX;AACA8B,MAAAA,IAAI,GAAG8C,oBAAoB,EAA3B,CAF4B,CAG5B;;AACA,UAAIhP,MAAM,IAAIkM,IAAI,CAAC1D,IAAL,KAAc7I,MAAM,CAACe,UAA/B,IAA6C4G,gBAAgB,CAAC4E,IAAI,CAACU,IAAN,CAAjE,EAA8E;AAC1EvB,QAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAAC4F,eAAd,CAAlB;AACH;;AAED,UAAI,CAACwG,cAAc,CAACC,IAAD,CAAnB,EAA2B;AACvBb,QAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACsE,sBAAd,CAAlB;AACH;;AAED+H,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACuD,gBADV;AAEH4L,QAAAA,QAAQ,EAAE5E,KAAK,CAACzB,KAFb;AAGHsG,QAAAA,QAAQ,EAAE7C,IAHP;AAIHpE,QAAAA,MAAM,EAAE;AAJL,OAAP;AAMA,aAAOoE,IAAP;AACH;;AAED,QAAIN,KAAK,CAAC,GAAD,CAAL,IAAcA,KAAK,CAAC,GAAD,CAAnB,IAA4BA,KAAK,CAAC,GAAD,CAAjC,IAA0CA,KAAK,CAAC,GAAD,CAAnD,EAA0D;AACtDM,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACsD,eADV;AAEH6L,QAAAA,QAAQ,EAAE1E,GAAG,GAAG3B,KAFb;AAGHsG,QAAAA,QAAQ,EAAEC,oBAAoB,EAH3B;AAIHlH,QAAAA,MAAM,EAAE;AAJL,OAAP;AAMA,aAAOoE,IAAP;AACH;;AAED,QAAIL,YAAY,CAAC,QAAD,CAAZ,IAA0BA,YAAY,CAAC,MAAD,CAAtC,IAAkDA,YAAY,CAAC,QAAD,CAAlE,EAA8E;AAC1EK,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACsD,eADV;AAEH6L,QAAAA,QAAQ,EAAE1E,GAAG,GAAG3B,KAFb;AAGHsG,QAAAA,QAAQ,EAAEC,oBAAoB,EAH3B;AAIHlH,QAAAA,MAAM,EAAE;AAJL,OAAP;;AAMA,UAAI9H,MAAM,IAAIkM,IAAI,CAAC4C,QAAL,KAAkB,QAA5B,IAAwC5C,IAAI,CAAC6C,QAAL,CAAcvG,IAAd,KAAuB7I,MAAM,CAACe,UAA1E,EAAsF;AAClF2K,QAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACsF,YAAd,CAAlB;AACH;;AACD,aAAO+G,IAAP;AACH;;AAED,WAAO2C,sBAAsB,EAA7B;AACH,GArsDsB,CAusDvB;;;AAEA,WAASI,6BAAT,GAAyC;AACrC,QAAI/C,IAAI,GAAG8C,oBAAoB,EAA/B;;AAEA,WAAOpD,KAAK,CAAC,GAAD,CAAL,IAAcA,KAAK,CAAC,GAAD,CAAnB,IAA4BA,KAAK,CAAC,GAAD,CAAxC,EAA+C;AAC3CM,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACwB,gBADV;AAEH2N,QAAAA,QAAQ,EAAE1E,GAAG,GAAG3B,KAFb;AAGHyG,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAEH,oBAAoB;AAJxB,OAAP;AAMH;;AAED,WAAO9C,IAAP;AACH,GAttDsB,CAwtDvB;;;AAEA,WAASkD,uBAAT,GAAmC;AAC/B,QAAIlD,IAAI,GAAG+C,6BAA6B,EAAxC;;AAEA,WAAOrD,KAAK,CAAC,GAAD,CAAL,IAAcA,KAAK,CAAC,GAAD,CAA1B,EAAiC;AAC7BM,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACwB,gBADV;AAEH2N,QAAAA,QAAQ,EAAE1E,GAAG,GAAG3B,KAFb;AAGHyG,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAEF,6BAA6B;AAJjC,OAAP;AAMH;;AAED,WAAO/C,IAAP;AACH,GAvuDsB,CAyuDvB;;;AAEA,WAASmD,oBAAT,GAAgC;AAC5B,QAAInD,IAAI,GAAGkD,uBAAuB,EAAlC;;AAEA,WAAOxD,KAAK,CAAC,IAAD,CAAL,IAAeA,KAAK,CAAC,IAAD,CAApB,IAA8BA,KAAK,CAAC,KAAD,CAA1C,EAAmD;AAC/CM,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACwB,gBADV;AAEH2N,QAAAA,QAAQ,EAAE1E,GAAG,GAAG3B,KAFb;AAGHyG,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAEC,uBAAuB;AAJ3B,OAAP;AAMH;;AAED,WAAOlD,IAAP;AACH,GAxvDsB,CAyvDvB;;;AAEA,WAASoD,yBAAT,GAAqC;AACjC,QAAIpD,IAAJ,EAAUqD,eAAV;AAEAA,IAAAA,eAAe,GAAGjP,KAAK,CAACkP,OAAxB;AACAlP,IAAAA,KAAK,CAACkP,OAAN,GAAgB,IAAhB;AAEAtD,IAAAA,IAAI,GAAGmD,oBAAoB,EAA3B;;AAEA,WAAOzD,KAAK,CAAC,GAAD,CAAL,IAAcA,KAAK,CAAC,GAAD,CAAnB,IAA4BA,KAAK,CAAC,IAAD,CAAjC,IAA2CA,KAAK,CAAC,IAAD,CAAhD,IAA2D2D,eAAe,IAAI1D,YAAY,CAAC,IAAD,CAA1F,IAAqGA,YAAY,CAAC,YAAD,CAAxH,EAAwI;AACpIK,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACwB,gBADV;AAEH2N,QAAAA,QAAQ,EAAE1E,GAAG,GAAG3B,KAFb;AAGHyG,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAEE,oBAAoB;AAJxB,OAAP;AAMH;;AAED/O,IAAAA,KAAK,CAACkP,OAAN,GAAgBD,eAAhB;AACA,WAAOrD,IAAP;AACH,GA9wDsB,CAgxDvB;;;AAEA,WAASuD,uBAAT,GAAmC;AAC/B,QAAIvD,IAAI,GAAGoD,yBAAyB,EAApC;;AAEA,WAAO1D,KAAK,CAAC,IAAD,CAAL,IAAeA,KAAK,CAAC,IAAD,CAApB,IAA8BA,KAAK,CAAC,KAAD,CAAnC,IAA8CA,KAAK,CAAC,KAAD,CAA1D,EAAmE;AAC/DM,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACwB,gBADV;AAEH2N,QAAAA,QAAQ,EAAE1E,GAAG,GAAG3B,KAFb;AAGHyG,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAEG,yBAAyB;AAJ7B,OAAP;AAMH;;AAED,WAAOpD,IAAP;AACH,GA/xDsB,CAiyDvB;;;AAEA,WAASwD,yBAAT,GAAqC;AACjC,QAAIxD,IAAI,GAAGuD,uBAAuB,EAAlC;;AAEA,WAAO7D,KAAK,CAAC,GAAD,CAAZ,EAAmB;AACfxB,MAAAA,GAAG;AACH8B,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACwB,gBADV;AAEH2N,QAAAA,QAAQ,EAAE,GAFP;AAGHI,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAEM,uBAAuB;AAJ3B,OAAP;AAMH;;AAED,WAAOvD,IAAP;AACH;;AAED,WAASyD,yBAAT,GAAqC;AACjC,QAAIzD,IAAI,GAAGwD,yBAAyB,EAApC;;AAEA,WAAO9D,KAAK,CAAC,GAAD,CAAZ,EAAmB;AACfxB,MAAAA,GAAG;AACH8B,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACwB,gBADV;AAEH2N,QAAAA,QAAQ,EAAE,GAFP;AAGHI,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAEO,yBAAyB;AAJ7B,OAAP;AAMH;;AAED,WAAOxD,IAAP;AACH;;AAED,WAAS0D,wBAAT,GAAoC;AAChC,QAAI1D,IAAI,GAAGyD,yBAAyB,EAApC;;AAEA,WAAO/D,KAAK,CAAC,GAAD,CAAZ,EAAmB;AACfxB,MAAAA,GAAG;AACH8B,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACwB,gBADV;AAEH2N,QAAAA,QAAQ,EAAE,GAFP;AAGHI,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAEQ,yBAAyB;AAJ7B,OAAP;AAMH;;AAED,WAAOzD,IAAP;AACH,GAj1DsB,CAm1DvB;;;AAEA,WAAS2D,yBAAT,GAAqC;AACjC,QAAI3D,IAAI,GAAG0D,wBAAwB,EAAnC;;AAEA,WAAOhE,KAAK,CAAC,IAAD,CAAZ,EAAoB;AAChBxB,MAAAA,GAAG;AACH8B,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACyC,iBADV;AAEH0M,QAAAA,QAAQ,EAAE,IAFP;AAGHI,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAES,wBAAwB;AAJ5B,OAAP;AAMH;;AAED,WAAO1D,IAAP;AACH;;AAED,WAAS4D,wBAAT,GAAoC;AAChC,QAAI5D,IAAI,GAAG2D,yBAAyB,EAApC;;AAEA,WAAOjE,KAAK,CAAC,IAAD,CAAZ,EAAoB;AAChBxB,MAAAA,GAAG;AACH8B,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACyC,iBADV;AAEH0M,QAAAA,QAAQ,EAAE,IAFP;AAGHI,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAEU,yBAAyB;AAJ7B,OAAP;AAMH;;AAED,WAAO3D,IAAP;AACH,GAn3DsB,CAq3DvB;;;AAEA,WAAS6D,0BAAT,GAAsC;AAClC,QAAI7D,IAAJ,EAAUqD,eAAV,EAA2BS,UAA3B;AAEA9D,IAAAA,IAAI,GAAG4D,wBAAwB,EAA/B;;AAEA,QAAIlE,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZxB,MAAAA,GAAG;AACHmF,MAAAA,eAAe,GAAGjP,KAAK,CAACkP,OAAxB;AACAlP,MAAAA,KAAK,CAACkP,OAAN,GAAgB,IAAhB;AACAQ,MAAAA,UAAU,GAAG3D,yBAAyB,EAAtC;AACA/L,MAAAA,KAAK,CAACkP,OAAN,GAAgBD,eAAhB;AACA7D,MAAAA,MAAM,CAAC,GAAD,CAAN;AAEAQ,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAAC4B,qBADV;AAEH0F,QAAAA,IAAI,EAAEiF,IAFH;AAGH8D,QAAAA,UAAU,EAAEA,UAHT;AAIHC,QAAAA,SAAS,EAAE5D,yBAAyB;AAJjC,OAAP;AAMH;;AAED,WAAOH,IAAP;AACH,GA74DsB,CA+4DvB;;;AAEA,WAASG,yBAAT,GAAqC;AACjC,QAAInC,KAAJ,EAAWgC,IAAX;AAEAhC,IAAAA,KAAK,GAAGG,SAAS,EAAjB;AACA6B,IAAAA,IAAI,GAAG6D,0BAA0B,EAAjC;;AAEA,QAAIjE,WAAW,EAAf,EAAmB;AACf;AACA,UAAI,CAACG,cAAc,CAACC,IAAD,CAAnB,EAA2B;AACvBb,QAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACsE,sBAAd,CAAlB;AACH,OAJc,CAMf;;;AACA,UAAInE,MAAM,IAAIkM,IAAI,CAAC1D,IAAL,KAAc7I,MAAM,CAACe,UAA/B,IAA6C4G,gBAAgB,CAAC4E,IAAI,CAACU,IAAN,CAAjE,EAA8E;AAC1EvB,QAAAA,kBAAkB,CAACnB,KAAD,EAAQrK,QAAQ,CAAC0F,mBAAjB,CAAlB;AACH;;AAED2G,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACqB,oBADV;AAEH8N,QAAAA,QAAQ,EAAE1E,GAAG,GAAG3B,KAFb;AAGHyG,QAAAA,IAAI,EAAEhD,IAHH;AAIHiD,QAAAA,KAAK,EAAE9C,yBAAyB;AAJ7B,OAAP;AAMH;;AAED,WAAOH,IAAP;AACH,GA36DsB,CA66DvB;;;AAEA,WAAS8B,eAAT,GAA2B;AACvB,QAAI9B,IAAI,GAAGG,yBAAyB,EAApC;;AAEA,QAAIT,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZM,MAAAA,IAAI,GAAG;AACH1D,QAAAA,IAAI,EAAE7I,MAAM,CAACgD,kBADV;AAEHuN,QAAAA,WAAW,EAAE,CAAEhE,IAAF;AAFV,OAAP;;AAKA,aAAOjM,KAAK,GAAGG,MAAf,EAAuB;AACnB,YAAI,CAACwL,KAAK,CAAC,GAAD,CAAV,EAAiB;AACb;AACH;;AACDxB,QAAAA,GAAG;AACH8B,QAAAA,IAAI,CAACgE,WAAL,CAAiB1E,IAAjB,CAAsBa,yBAAyB,EAA/C;AACH;AAEJ;;AACD,WAAOH,IAAP;AACH,GAl8DsB,CAo8DvB;;;AAEA,WAASiE,kBAAT,GAA8B;AAC1B,QAAIC,IAAI,GAAG,EAAX;AAAA,QACIC,SADJ;;AAGA,WAAOpQ,KAAK,GAAGG,MAAf,EAAuB;AACnB,UAAIwL,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZ;AACH;;AACDyE,MAAAA,SAAS,GAAGC,kBAAkB,EAA9B;;AACA,UAAI,OAAOD,SAAP,KAAqB,WAAzB,EAAsC;AAClC;AACH;;AACDD,MAAAA,IAAI,CAAC5E,IAAL,CAAU6E,SAAV;AACH;;AAED,WAAOD,IAAP;AACH;;AAED,WAASG,UAAT,GAAsB;AAClB,QAAIC,KAAJ;AAEA9E,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA8E,IAAAA,KAAK,GAAGL,kBAAkB,EAA1B;AAEAzE,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA,WAAO;AACHlD,MAAAA,IAAI,EAAE7I,MAAM,CAACuB,cADV;AAEHwL,MAAAA,IAAI,EAAE8D;AAFH,KAAP;AAIH,GAr+DsB,CAu+DvB;;;AAEA,WAASjD,uBAAT,GAAmC;AAC/B,QAAIrD,KAAK,GAAGE,GAAG,EAAf;;AAEA,QAAIF,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACiB,UAAzB,EAAqC;AACjC+K,MAAAA,eAAe,CAACvB,KAAD,CAAf;AACH;;AAED,WAAO;AACH1B,MAAAA,IAAI,EAAE7I,MAAM,CAACe,UADV;AAEHkM,MAAAA,IAAI,EAAE1C,KAAK,CAACzB;AAFT,KAAP;AAIH;;AAED,WAASgI,wBAAT,CAAkCnD,IAAlC,EAAwC;AACpC,QAAIlG,EAAE,GAAGmG,uBAAuB,EAAhC;AAAA,QACImD,IAAI,GAAG,IADX,CADoC,CAIpC;;AACA,QAAI1Q,MAAM,IAAIsH,gBAAgB,CAACF,EAAE,CAACwF,IAAJ,CAA9B,EAAyC;AACrCvB,MAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACiF,aAAd,CAAlB;AACH;;AAED,QAAIwI,IAAI,KAAK,OAAb,EAAsB;AAClB5B,MAAAA,MAAM,CAAC,GAAD,CAAN;AACAgF,MAAAA,IAAI,GAAGrE,yBAAyB,EAAhC;AACH,KAHD,MAGO,IAAIT,KAAK,CAAC,GAAD,CAAT,EAAgB;AACnBxB,MAAAA,GAAG;AACHsG,MAAAA,IAAI,GAAGrE,yBAAyB,EAAhC;AACH;;AAED,WAAO;AACH7D,MAAAA,IAAI,EAAE7I,MAAM,CAACyD,kBADV;AAEHgE,MAAAA,EAAE,EAAEA,EAFD;AAGHsJ,MAAAA,IAAI,EAAEA;AAHH,KAAP;AAKH;;AAED,WAASC,4BAAT,CAAsCrD,IAAtC,EAA4C;AACxC,QAAI8C,IAAI,GAAG,EAAX;;AAEA,OAAG;AACCA,MAAAA,IAAI,CAAC5E,IAAL,CAAUiF,wBAAwB,CAACnD,IAAD,CAAlC;;AACA,UAAI,CAAC1B,KAAK,CAAC,GAAD,CAAV,EAAiB;AACb;AACH;;AACDxB,MAAAA,GAAG;AACN,KAND,QAMSnK,KAAK,GAAGG,MANjB;;AAQA,WAAOgQ,IAAP;AACH;;AAED,WAASQ,sBAAT,GAAkC;AAC9B,QAAIC,YAAJ;AAEAlF,IAAAA,aAAa,CAAC,KAAD,CAAb;AAEAkF,IAAAA,YAAY,GAAGF,4BAA4B,EAA3C;AAEA3E,IAAAA,gBAAgB;AAEhB,WAAO;AACHxD,MAAAA,IAAI,EAAE7I,MAAM,CAACwD,mBADV;AAEH0N,MAAAA,YAAY,EAAEA,YAFX;AAGHvD,MAAAA,IAAI,EAAE;AAHH,KAAP;AAKH,GA1iEsB,CA4iEvB;AACA;AACA;AACA;;;AACA,WAASwD,wBAAT,CAAkCxD,IAAlC,EAAwC;AACpC,QAAIuD,YAAJ;AAEAlF,IAAAA,aAAa,CAAC2B,IAAD,CAAb;AAEAuD,IAAAA,YAAY,GAAGF,4BAA4B,CAACrD,IAAD,CAA3C;AAEAtB,IAAAA,gBAAgB;AAEhB,WAAO;AACHxD,MAAAA,IAAI,EAAE7I,MAAM,CAACwD,mBADV;AAEH0N,MAAAA,YAAY,EAAEA,YAFX;AAGHvD,MAAAA,IAAI,EAAEA;AAHH,KAAP;AAKH,GA9jEsB,CAgkEvB;;;AAEA,WAASyD,mBAAT,GAA+B;AAC3BrF,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA,WAAO;AACHlD,MAAAA,IAAI,EAAE7I,MAAM,CAACgC;AADV,KAAP;AAGH,GAxkEsB,CA0kEvB;;;AAEA,WAASqP,wBAAT,GAAoC;AAChC,QAAI9E,IAAI,GAAG8B,eAAe,EAA1B;AAEAhC,IAAAA,gBAAgB;AAEhB,WAAO;AACHxD,MAAAA,IAAI,EAAE7I,MAAM,CAACiC,mBADV;AAEHqL,MAAAA,UAAU,EAAEf;AAFT,KAAP;AAIH,GArlEsB,CAulEvB;;;AAEA,WAAS+E,gBAAT,GAA4B;AACxB,QAAIhK,IAAJ,EAAU+I,UAAV,EAAsBC,SAAtB;AAEAtE,IAAAA,aAAa,CAAC,IAAD,CAAb;AAEAD,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAzE,IAAAA,IAAI,GAAG+G,eAAe,EAAtB;AAEAtC,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAsE,IAAAA,UAAU,GAAGkB,cAAc,EAA3B;;AAEA,QAAIrF,YAAY,CAAC,MAAD,CAAhB,EAA0B;AACtBzB,MAAAA,GAAG;AACH6F,MAAAA,SAAS,GAAGiB,cAAc,EAA1B;AACH,KAHD,MAGO;AACHjB,MAAAA,SAAS,GAAG,IAAZ;AACH;;AAED,WAAO;AACHzH,MAAAA,IAAI,EAAE7I,MAAM,CAACsC,WADV;AAEHgF,MAAAA,IAAI,EAAEA,IAFH;AAGH+I,MAAAA,UAAU,EAAEA,UAHT;AAIHC,MAAAA,SAAS,EAAEA;AAJR,KAAP;AAMH,GAnnEsB,CAqnEvB;;;AAEA,WAASkB,qBAAT,GAAiC;AAC7B,QAAIzE,IAAJ,EAAUzF,IAAV,EAAgBmK,cAAhB;AAEAzF,IAAAA,aAAa,CAAC,IAAD,CAAb;AAEAyF,IAAAA,cAAc,GAAG9Q,KAAK,CAAC+Q,WAAvB;AACA/Q,IAAAA,KAAK,CAAC+Q,WAAN,GAAoB,IAApB;AAEA3E,IAAAA,IAAI,GAAGwE,cAAc,EAArB;AAEA5Q,IAAAA,KAAK,CAAC+Q,WAAN,GAAoBD,cAApB;AAEAzF,IAAAA,aAAa,CAAC,OAAD,CAAb;AAEAD,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAzE,IAAAA,IAAI,GAAG+G,eAAe,EAAtB;AAEAtC,IAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,QAAIE,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZxB,MAAAA,GAAG;AACN;;AAED,WAAO;AACH5B,MAAAA,IAAI,EAAE7I,MAAM,CAAC8B,gBADV;AAEHiL,MAAAA,IAAI,EAAEA,IAFH;AAGHzF,MAAAA,IAAI,EAAEA;AAHH,KAAP;AAKH;;AAED,WAASqK,mBAAT,GAA+B;AAC3B,QAAIrK,IAAJ,EAAUyF,IAAV,EAAgB0E,cAAhB;AAEAzF,IAAAA,aAAa,CAAC,OAAD,CAAb;AAEAD,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAzE,IAAAA,IAAI,GAAG+G,eAAe,EAAtB;AAEAtC,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA0F,IAAAA,cAAc,GAAG9Q,KAAK,CAAC+Q,WAAvB;AACA/Q,IAAAA,KAAK,CAAC+Q,WAAN,GAAoB,IAApB;AAEA3E,IAAAA,IAAI,GAAGwE,cAAc,EAArB;AAEA5Q,IAAAA,KAAK,CAAC+Q,WAAN,GAAoBD,cAApB;AAEA,WAAO;AACH5I,MAAAA,IAAI,EAAE7I,MAAM,CAAC0D,cADV;AAEH4D,MAAAA,IAAI,EAAEA,IAFH;AAGHyF,MAAAA,IAAI,EAAEA;AAHH,KAAP;AAKH;;AAED,WAAS6E,2BAAT,GAAuC;AACnC,QAAIrH,KAAK,GAAGE,GAAG,EAAf;AAEA,WAAO;AACH5B,MAAAA,IAAI,EAAE7I,MAAM,CAACwD,mBADV;AAEH0N,MAAAA,YAAY,EAAEF,4BAA4B,EAFvC;AAGHrD,MAAAA,IAAI,EAAEpD,KAAK,CAACzB;AAHT,KAAP;AAKH;;AAED,WAAS+I,iBAAT,GAA6B;AACzB,QAAId,IAAJ,EAAUzJ,IAAV,EAAgBwK,MAAhB,EAAwBvC,IAAxB,EAA8BC,KAA9B,EAAqCzC,IAArC,EAA2C0E,cAA3C;AAEAV,IAAAA,IAAI,GAAGzJ,IAAI,GAAGwK,MAAM,GAAG,IAAvB;AAEA9F,IAAAA,aAAa,CAAC,KAAD,CAAb;AAEAD,IAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,QAAIE,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZxB,MAAAA,GAAG;AACN,KAFD,MAEO;AACH,UAAIyB,YAAY,CAAC,KAAD,CAAZ,IAAuBA,YAAY,CAAC,KAAD,CAAvC,EAAgD;AAC5CvL,QAAAA,KAAK,CAACkP,OAAN,GAAgB,KAAhB;AACAkB,QAAAA,IAAI,GAAGa,2BAA2B,EAAlC;AACAjR,QAAAA,KAAK,CAACkP,OAAN,GAAgB,IAAhB;;AAEA,YAAIkB,IAAI,CAACG,YAAL,CAAkBzQ,MAAlB,KAA6B,CAA7B,IAAkCyL,YAAY,CAAC,IAAD,CAAlD,EAA0D;AACtDzB,UAAAA,GAAG;AACH8E,UAAAA,IAAI,GAAGwB,IAAP;AACAvB,UAAAA,KAAK,GAAGnB,eAAe,EAAvB;AACA0C,UAAAA,IAAI,GAAG,IAAP;AACH;AACJ,OAXD,MAWO;AACHpQ,QAAAA,KAAK,CAACkP,OAAN,GAAgB,KAAhB;AACAkB,QAAAA,IAAI,GAAG1C,eAAe,EAAtB;AACA1N,QAAAA,KAAK,CAACkP,OAAN,GAAgB,IAAhB;;AAEA,YAAI3D,YAAY,CAAC,IAAD,CAAhB,EAAwB;AACpB;AACA,cAAI,CAACI,cAAc,CAACyE,IAAD,CAAnB,EAA2B;AACvBrF,YAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACuE,iBAAd,CAAlB;AACH;;AAEDgG,UAAAA,GAAG;AACH8E,UAAAA,IAAI,GAAGwB,IAAP;AACAvB,UAAAA,KAAK,GAAGnB,eAAe,EAAvB;AACA0C,UAAAA,IAAI,GAAG,IAAP;AACH;AACJ;;AAED,UAAI,OAAOxB,IAAP,KAAgB,WAApB,EAAiC;AAC7BxD,QAAAA,MAAM,CAAC,GAAD,CAAN;AACH;AACJ;;AAED,QAAI,OAAOwD,IAAP,KAAgB,WAApB,EAAiC;AAE7B,UAAI,CAACtD,KAAK,CAAC,GAAD,CAAV,EAAiB;AACb3E,QAAAA,IAAI,GAAG+G,eAAe,EAAtB;AACH;;AACDtC,MAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,UAAI,CAACE,KAAK,CAAC,GAAD,CAAV,EAAiB;AACb6F,QAAAA,MAAM,GAAGzD,eAAe,EAAxB;AACH;AACJ;;AAEDtC,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA0F,IAAAA,cAAc,GAAG9Q,KAAK,CAAC+Q,WAAvB;AACA/Q,IAAAA,KAAK,CAAC+Q,WAAN,GAAoB,IAApB;AAEA3E,IAAAA,IAAI,GAAGwE,cAAc,EAArB;AAEA5Q,IAAAA,KAAK,CAAC+Q,WAAN,GAAoBD,cAApB;;AAEA,QAAI,OAAOlC,IAAP,KAAgB,WAApB,EAAiC;AAC7B,aAAO;AACH1G,QAAAA,IAAI,EAAE7I,MAAM,CAACkC,YADV;AAEH6O,QAAAA,IAAI,EAAEA,IAFH;AAGHzJ,QAAAA,IAAI,EAAEA,IAHH;AAIHwK,QAAAA,MAAM,EAAEA,MAJL;AAKH/E,QAAAA,IAAI,EAAEA;AALH,OAAP;AAOH;;AAED,WAAO;AACHlE,MAAAA,IAAI,EAAE7I,MAAM,CAACmC,cADV;AAEHoN,MAAAA,IAAI,EAAEA,IAFH;AAGHC,MAAAA,KAAK,EAAEA,KAHJ;AAIHzC,MAAAA,IAAI,EAAEA,IAJH;AAKHgF,MAAAA,IAAI,EAAE;AALH,KAAP;AAOH,GA7wEsB,CA+wEvB;;;AAEA,WAASC,sBAAT,GAAkC;AAC9B,QAAIzH,KAAJ;AAAA,QAAW0H,KAAK,GAAG,IAAnB;AAEAjG,IAAAA,aAAa,CAAC,UAAD,CAAb,CAH8B,CAK9B;;AACA,QAAI5L,MAAM,CAACE,KAAD,CAAN,KAAkB,GAAtB,EAA2B;AACvBmK,MAAAA,GAAG;;AAEH,UAAI,CAAC9J,KAAK,CAAC+Q,WAAX,EAAwB;AACpBzJ,QAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC4E,eAAd,CAAV;AACH;;AAED,aAAO;AACH+D,QAAAA,IAAI,EAAE7I,MAAM,CAAC6B,iBADV;AAEHoQ,QAAAA,KAAK,EAAE;AAFJ,OAAP;AAIH;;AAED,QAAIpH,kBAAkB,EAAtB,EAA0B;AACtB,UAAI,CAAClK,KAAK,CAAC+Q,WAAX,EAAwB;AACpBzJ,QAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC4E,eAAd,CAAV;AACH;;AAED,aAAO;AACH+D,QAAAA,IAAI,EAAE7I,MAAM,CAAC6B,iBADV;AAEHoQ,QAAAA,KAAK,EAAE;AAFJ,OAAP;AAIH;;AAED1H,IAAAA,KAAK,GAAGG,SAAS,EAAjB;;AACA,QAAIH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACiB,UAAzB,EAAqC;AACjCkR,MAAAA,KAAK,GAAGrE,uBAAuB,EAA/B;;AAEA,UAAI,CAACM,MAAM,CAAC/C,SAAP,CAAiBgD,cAAjB,CAAgC/C,IAAhC,CAAqCzK,KAAK,CAACuR,QAA3C,EAAqDD,KAAK,CAAChF,IAA3D,CAAL,EAAuE;AACnEhF,QAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC0E,YAAd,EAA4BqN,KAAK,CAAChF,IAAlC,CAAV;AACH;AACJ;;AAEDZ,IAAAA,gBAAgB;;AAEhB,QAAI4F,KAAK,KAAK,IAAV,IAAkB,CAACtR,KAAK,CAAC+Q,WAA7B,EAA0C;AACtCzJ,MAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC4E,eAAd,CAAV;AACH;;AAED,WAAO;AACH+D,MAAAA,IAAI,EAAE7I,MAAM,CAAC6B,iBADV;AAEHoQ,MAAAA,KAAK,EAAEA;AAFJ,KAAP;AAIH,GAl0EsB,CAo0EvB;;;AAEA,WAASE,mBAAT,GAA+B;AAC3B,QAAI5H,KAAJ;AAAA,QAAW0H,KAAK,GAAG,IAAnB;AAEAjG,IAAAA,aAAa,CAAC,OAAD,CAAb,CAH2B,CAK3B;;AACA,QAAI5L,MAAM,CAACE,KAAD,CAAN,KAAkB,GAAtB,EAA2B;AACvBmK,MAAAA,GAAG;;AAEH,UAAI,EAAE9J,KAAK,CAAC+Q,WAAN,IAAqB/Q,KAAK,CAACyR,QAA7B,CAAJ,EAA4C;AACxCnK,QAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6E,YAAd,CAAV;AACH;;AAED,aAAO;AACH8D,QAAAA,IAAI,EAAE7I,MAAM,CAACyB,cADV;AAEHwQ,QAAAA,KAAK,EAAE;AAFJ,OAAP;AAIH;;AAED,QAAIpH,kBAAkB,EAAtB,EAA0B;AACtB,UAAI,EAAElK,KAAK,CAAC+Q,WAAN,IAAqB/Q,KAAK,CAACyR,QAA7B,CAAJ,EAA4C;AACxCnK,QAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6E,YAAd,CAAV;AACH;;AAED,aAAO;AACH8D,QAAAA,IAAI,EAAE7I,MAAM,CAACyB,cADV;AAEHwQ,QAAAA,KAAK,EAAE;AAFJ,OAAP;AAIH;;AAED1H,IAAAA,KAAK,GAAGG,SAAS,EAAjB;;AACA,QAAIH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACiB,UAAzB,EAAqC;AACjCkR,MAAAA,KAAK,GAAGrE,uBAAuB,EAA/B;;AAEA,UAAI,CAACM,MAAM,CAAC/C,SAAP,CAAiBgD,cAAjB,CAAgC/C,IAAhC,CAAqCzK,KAAK,CAACuR,QAA3C,EAAqDD,KAAK,CAAChF,IAA3D,CAAL,EAAuE;AACnEhF,QAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC0E,YAAd,EAA4BqN,KAAK,CAAChF,IAAlC,CAAV;AACH;AACJ;;AAEDZ,IAAAA,gBAAgB;;AAEhB,QAAI4F,KAAK,KAAK,IAAV,IAAkB,EAAEtR,KAAK,CAAC+Q,WAAN,IAAqB/Q,KAAK,CAACyR,QAA7B,CAAtB,EAA8D;AAC1DnK,MAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6E,YAAd,CAAV;AACH;;AAED,WAAO;AACH8D,MAAAA,IAAI,EAAE7I,MAAM,CAACyB,cADV;AAEHwQ,MAAAA,KAAK,EAAEA;AAFJ,KAAP;AAIH,GAv3EsB,CAy3EvB;;;AAEA,WAASI,oBAAT,GAAgC;AAC5B,QAAI9H,KAAJ;AAAA,QAAW6E,QAAQ,GAAG,IAAtB;AAEApD,IAAAA,aAAa,CAAC,QAAD,CAAb;;AAEA,QAAI,CAACrL,KAAK,CAAC2R,cAAX,EAA2B;AACvB5G,MAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAAC8E,aAAd,CAAlB;AACH,KAP2B,CAS5B;;;AACA,QAAI5E,MAAM,CAACE,KAAD,CAAN,KAAkB,GAAtB,EAA2B;AACvB,UAAI+G,iBAAiB,CAACjH,MAAM,CAACE,KAAK,GAAG,CAAT,CAAP,CAArB,EAA0C;AACtC8O,QAAAA,QAAQ,GAAGf,eAAe,EAA1B;AACAhC,QAAAA,gBAAgB;AAChB,eAAO;AACHxD,UAAAA,IAAI,EAAE7I,MAAM,CAAC+C,eADV;AAEHqM,UAAAA,QAAQ,EAAEA;AAFP,SAAP;AAIH;AACJ;;AAED,QAAIvE,kBAAkB,EAAtB,EAA0B;AACtB,aAAO;AACHhC,QAAAA,IAAI,EAAE7I,MAAM,CAAC+C,eADV;AAEHqM,QAAAA,QAAQ,EAAE;AAFP,OAAP;AAIH;;AAED,QAAI,CAACnD,KAAK,CAAC,GAAD,CAAV,EAAiB;AACb1B,MAAAA,KAAK,GAAGG,SAAS,EAAjB;;AACA,UAAI,CAACuB,KAAK,CAAC,GAAD,CAAN,IAAe1B,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACgB,GAAxC,EAA6C;AACzCsO,QAAAA,QAAQ,GAAGf,eAAe,EAA1B;AACH;AACJ;;AAEDhC,IAAAA,gBAAgB;AAEhB,WAAO;AACHxD,MAAAA,IAAI,EAAE7I,MAAM,CAAC+C,eADV;AAEHqM,MAAAA,QAAQ,EAAEA;AAFP,KAAP;AAIH,GAp6EsB,CAs6EvB;;;AAEA,WAASmD,kBAAT,GAA8B;AAC1B,QAAItD,MAAJ,EAAYlC,IAAZ;;AAEA,QAAI1M,MAAJ,EAAY;AACRqL,MAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAAC+E,cAAd,CAAlB;AACH;;AAED+G,IAAAA,aAAa,CAAC,MAAD,CAAb;AAEAD,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAkD,IAAAA,MAAM,GAAGZ,eAAe,EAAxB;AAEAtC,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAgB,IAAAA,IAAI,GAAGwE,cAAc,EAArB;AAEA,WAAO;AACH1I,MAAAA,IAAI,EAAE7I,MAAM,CAAC2D,aADV;AAEHsL,MAAAA,MAAM,EAAEA,MAFL;AAGHlC,MAAAA,IAAI,EAAEA;AAHH,KAAP;AAKH,GA97EsB,CAg8EvB;;;AAEA,WAASyF,eAAT,GAA2B;AACvB,QAAIlL,IAAJ;AAAA,QACI+I,UAAU,GAAG,EADjB;AAAA,QAEIK,SAFJ;;AAIA,QAAIxE,YAAY,CAAC,SAAD,CAAhB,EAA6B;AACzBzB,MAAAA,GAAG;AACHnD,MAAAA,IAAI,GAAG,IAAP;AACH,KAHD,MAGO;AACH0E,MAAAA,aAAa,CAAC,MAAD,CAAb;AACA1E,MAAAA,IAAI,GAAG+G,eAAe,EAAtB;AACH;;AACDtC,IAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,WAAOzL,KAAK,GAAGG,MAAf,EAAuB;AACnB,UAAIwL,KAAK,CAAC,GAAD,CAAL,IAAcC,YAAY,CAAC,SAAD,CAA1B,IAAyCA,YAAY,CAAC,MAAD,CAAzD,EAAmE;AAC/D;AACH;;AACDwE,MAAAA,SAAS,GAAGa,cAAc,EAA1B;;AACA,UAAI,OAAOb,SAAP,KAAqB,WAAzB,EAAsC;AAClC;AACH;;AACDL,MAAAA,UAAU,CAACxE,IAAX,CAAgB6E,SAAhB;AACH;;AAED,WAAO;AACH7H,MAAAA,IAAI,EAAE7I,MAAM,CAACkD,UADV;AAEHoE,MAAAA,IAAI,EAAEA,IAFH;AAGH+I,MAAAA,UAAU,EAAEA;AAHT,KAAP;AAKH;;AAED,WAASoC,oBAAT,GAAgC;AAC5B,QAAIC,YAAJ,EAAkBC,KAAlB,EAAyBC,MAAzB,EAAiCC,WAAjC,EAA8CC,YAA9C;AAEA9G,IAAAA,aAAa,CAAC,QAAD,CAAb;AAEAD,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA2G,IAAAA,YAAY,GAAGrE,eAAe,EAA9B;AAEAtC,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAA,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA4G,IAAAA,KAAK,GAAG,EAAR;;AAEA,QAAI1G,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZxB,MAAAA,GAAG;AACH,aAAO;AACH5B,QAAAA,IAAI,EAAE7I,MAAM,CAACiD,eADV;AAEHyP,QAAAA,YAAY,EAAEA,YAFX;AAGHC,QAAAA,KAAK,EAAEA;AAHJ,OAAP;AAKH;;AAEDE,IAAAA,WAAW,GAAGlS,KAAK,CAACyR,QAApB;AACAzR,IAAAA,KAAK,CAACyR,QAAN,GAAiB,IAAjB;AACAU,IAAAA,YAAY,GAAG,KAAf;;AAEA,WAAOxS,KAAK,GAAGG,MAAf,EAAuB;AACnB,UAAIwL,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZ;AACH;;AACD2G,MAAAA,MAAM,GAAGJ,eAAe,EAAxB;;AACA,UAAII,MAAM,CAACtL,IAAP,KAAgB,IAApB,EAA0B;AACtB,YAAIwL,YAAJ,EAAkB;AACd7K,UAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAACwE,wBAAd,CAAV;AACH;;AACDoO,QAAAA,YAAY,GAAG,IAAf;AACH;;AACDH,MAAAA,KAAK,CAAC9G,IAAN,CAAW+G,MAAX;AACH;;AAEDjS,IAAAA,KAAK,CAACyR,QAAN,GAAiBS,WAAjB;AAEA9G,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA,WAAO;AACHlD,MAAAA,IAAI,EAAE7I,MAAM,CAACiD,eADV;AAEHyP,MAAAA,YAAY,EAAEA,YAFX;AAGHC,MAAAA,KAAK,EAAEA;AAHJ,KAAP;AAKH,GArhFsB,CAuhFvB;;;AAEA,WAASI,mBAAT,GAA+B;AAC3B,QAAI3D,QAAJ;AAEApD,IAAAA,aAAa,CAAC,OAAD,CAAb;;AAEA,QAAInB,kBAAkB,EAAtB,EAA0B;AACtB5C,MAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAACmE,iBAAd,CAAV;AACH;;AAED+K,IAAAA,QAAQ,GAAGf,eAAe,EAA1B;AAEAhC,IAAAA,gBAAgB;AAEhB,WAAO;AACHxD,MAAAA,IAAI,EAAE7I,MAAM,CAACoD,cADV;AAEHgM,MAAAA,QAAQ,EAAEA;AAFP,KAAP;AAIH,GA1iFsB,CA4iFvB;;;AAEA,WAAS4D,gBAAT,GAA4B;AACxB,QAAIpG,KAAJ;AAEAZ,IAAAA,aAAa,CAAC,OAAD,CAAb;AAEAD,IAAAA,MAAM,CAAC,GAAD,CAAN;;AACA,QAAIE,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZH,MAAAA,eAAe,CAACpB,SAAS,EAAV,CAAf;AACH;;AAEDkC,IAAAA,KAAK,GAAGgB,uBAAuB,EAA/B,CAVwB,CAWxB;;AACA,QAAIvN,MAAM,IAAIsH,gBAAgB,CAACiF,KAAK,CAACK,IAAP,CAA9B,EAA4C;AACxCvB,MAAAA,kBAAkB,CAAC,EAAD,EAAKxL,QAAQ,CAACgF,mBAAd,CAAlB;AACH;;AAED6G,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEA,WAAO;AACHlD,MAAAA,IAAI,EAAE7I,MAAM,CAAC2B,WADV;AAEHiL,MAAAA,KAAK,EAAEA,KAFJ;AAGHG,MAAAA,IAAI,EAAE6D,UAAU;AAHb,KAAP;AAKH;;AAED,WAASqC,iBAAT,GAA6B;AACzB,QAAIpC,KAAJ;AAAA,QAAWqC,QAAQ,GAAG,EAAtB;AAAA,QAA0BC,SAAS,GAAG,IAAtC;AAEAnH,IAAAA,aAAa,CAAC,KAAD,CAAb;AAEA6E,IAAAA,KAAK,GAAGD,UAAU,EAAlB;;AAEA,QAAI1E,YAAY,CAAC,OAAD,CAAhB,EAA2B;AACvBgH,MAAAA,QAAQ,CAACrH,IAAT,CAAcmH,gBAAgB,EAA9B;AACH;;AAED,QAAI9G,YAAY,CAAC,SAAD,CAAhB,EAA6B;AACzBzB,MAAAA,GAAG;AACH0I,MAAAA,SAAS,GAAGvC,UAAU,EAAtB;AACH;;AAED,QAAIsC,QAAQ,CAACzS,MAAT,KAAoB,CAApB,IAAyB,CAAC0S,SAA9B,EAAyC;AACrClL,MAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAACyE,gBAAd,CAAV;AACH;;AAED,WAAO;AACHkE,MAAAA,IAAI,EAAE7I,MAAM,CAACqD,YADV;AAEHwN,MAAAA,KAAK,EAAEA,KAFJ;AAGHuC,MAAAA,eAAe,EAAE,EAHd;AAIHF,MAAAA,QAAQ,EAAEA,QAJP;AAKHC,MAAAA,SAAS,EAAEA;AALR,KAAP;AAOH,GAlmFsB,CAomFvB;;;AAEA,WAASE,sBAAT,GAAkC;AAC9BrH,IAAAA,aAAa,CAAC,UAAD,CAAb;AAEAK,IAAAA,gBAAgB;AAEhB,WAAO;AACHxD,MAAAA,IAAI,EAAE7I,MAAM,CAAC+B;AADV,KAAP;AAGH,GA9mFsB,CAgnFvB;;;AAEA,WAASwP,cAAT,GAA0B;AACtB,QAAIhH,KAAK,GAAGG,SAAS,EAArB;AAAA,QACI6B,IADJ;AAAA,QAEI+G,WAFJ;;AAIA,QAAI/I,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACgB,GAAzB,EAA8B;AAC1BgL,MAAAA,eAAe,CAACvB,KAAD,CAAf;AACH;;AAED,QAAIA,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACqB,UAAzB,EAAqC;AACjC,cAAQoJ,KAAK,CAACzB,KAAd;AACA,aAAK,GAAL;AACI,iBAAOsI,mBAAmB,EAA1B;;AACJ,aAAK,GAAL;AACI,iBAAOR,UAAU,EAAjB;;AACJ,aAAK,GAAL;AACI,iBAAOS,wBAAwB,EAA/B;;AACJ;AACI;AARJ;AAUH;;AAED,QAAI9G,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACkB,OAAzB,EAAkC;AAC9B,cAAQuJ,KAAK,CAACzB,KAAd;AACA,aAAK,OAAL;AACI,iBAAOqJ,mBAAmB,EAA1B;;AACJ,aAAK,UAAL;AACI,iBAAOH,sBAAsB,EAA7B;;AACJ,aAAK,UAAL;AACI,iBAAOqB,sBAAsB,EAA7B;;AACJ,aAAK,IAAL;AACI,iBAAO7B,qBAAqB,EAA5B;;AACJ,aAAK,KAAL;AACI,iBAAOK,iBAAiB,EAAxB;;AACJ,aAAK,UAAL;AACI,iBAAO0B,wBAAwB,EAA/B;;AACJ,aAAK,IAAL;AACI,iBAAOjC,gBAAgB,EAAvB;;AACJ,aAAK,QAAL;AACI,iBAAOe,oBAAoB,EAA3B;;AACJ,aAAK,QAAL;AACI,iBAAOI,oBAAoB,EAA3B;;AACJ,aAAK,OAAL;AACI,iBAAOM,mBAAmB,EAA1B;;AACJ,aAAK,KAAL;AACI,iBAAOE,iBAAiB,EAAxB;;AACJ,aAAK,KAAL;AACI,iBAAOhC,sBAAsB,EAA7B;;AACJ,aAAK,OAAL;AACI,iBAAOU,mBAAmB,EAA1B;;AACJ,aAAK,MAAL;AACI,iBAAOY,kBAAkB,EAAzB;;AACJ;AACI;AA9BJ;AAgCH;;AAEDhG,IAAAA,IAAI,GAAG8B,eAAe,EAAtB,CAzDsB,CA2DtB;;AACA,QAAK9B,IAAI,CAAC1D,IAAL,KAAc7I,MAAM,CAACe,UAAtB,IAAqCkL,KAAK,CAAC,GAAD,CAA9C,EAAqD;AACjDxB,MAAAA,GAAG;;AAEH,UAAIyD,MAAM,CAAC/C,SAAP,CAAiBgD,cAAjB,CAAgC/C,IAAhC,CAAqCzK,KAAK,CAACuR,QAA3C,EAAqD3F,IAAI,CAACU,IAA1D,CAAJ,EAAqE;AACjEhF,QAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC2E,aAAd,EAA6B,OAA7B,EAAsC0H,IAAI,CAACU,IAA3C,CAAV;AACH;;AAEDtM,MAAAA,KAAK,CAACuR,QAAN,CAAe3F,IAAI,CAACU,IAApB,IAA4B,IAA5B;AACAqG,MAAAA,WAAW,GAAG/B,cAAc,EAA5B;AACA,aAAO5Q,KAAK,CAACuR,QAAN,CAAe3F,IAAI,CAACU,IAApB,CAAP;AAEA,aAAO;AACHpE,QAAAA,IAAI,EAAE7I,MAAM,CAACwC,gBADV;AAEHyP,QAAAA,KAAK,EAAE1F,IAFJ;AAGHQ,QAAAA,IAAI,EAAEuG;AAHH,OAAP;AAKH;;AAEDjH,IAAAA,gBAAgB;AAEhB,WAAO;AACHxD,MAAAA,IAAI,EAAE7I,MAAM,CAACiC,mBADV;AAEHqL,MAAAA,UAAU,EAAEf;AAFT,KAAP;AAIH,GAtsFsB,CAwsFvB;;;AAEA,WAASS,2BAAT,GAAuC;AACnC,QAAIwG,aAAJ;AAAA,QAAmBC,cAAc,GAAG,EAApC;AAAA,QAAwClJ,KAAxC;AAAA,QAA+CmJ,SAA/C;AAAA,QAA0DC,eAA1D;AAAA,QACIC,WADJ;AAAA,QACiBnC,cADjB;AAAA,QACiCoB,WADjC;AAAA,QAC8CgB,iBAD9C;AAGA9H,IAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,WAAOzL,KAAK,GAAGG,MAAf,EAAuB;AACnB8J,MAAAA,KAAK,GAAGG,SAAS,EAAjB;;AACA,UAAIH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACsB,aAAzB,EAAwC;AACpC;AACH;;AAEDoS,MAAAA,aAAa,GAAG7C,kBAAkB,EAAlC;AACA8C,MAAAA,cAAc,CAAC5H,IAAf,CAAoB2H,aAApB;;AACA,UAAIA,aAAa,CAAClG,UAAd,CAAyBzE,IAAzB,KAAkC7I,MAAM,CAACuC,OAA7C,EAAsD;AAClD;AACA;AACH;;AACDmR,MAAAA,SAAS,GAAGnN,WAAW,CAACgE,KAAK,CAACxB,KAAN,CAAY,CAAZ,IAAiB,CAAlB,EAAqBwB,KAAK,CAACxB,KAAN,CAAY,CAAZ,IAAiB,CAAtC,CAAvB;;AACA,UAAI2K,SAAS,KAAK,YAAlB,EAAgC;AAC5BrT,QAAAA,MAAM,GAAG,IAAT;;AACA,YAAIsT,eAAJ,EAAqB;AACjBjI,UAAAA,kBAAkB,CAACiI,eAAD,EAAkBzT,QAAQ,CAACqF,kBAA3B,CAAlB;AACH;AACJ,OALD,MAKO;AACH,YAAI,CAACoO,eAAD,IAAoBpJ,KAAK,CAACf,KAA9B,EAAqC;AACjCmK,UAAAA,eAAe,GAAGpJ,KAAlB;AACH;AACJ;AACJ;;AAEDqJ,IAAAA,WAAW,GAAGjT,KAAK,CAACuR,QAApB;AACAT,IAAAA,cAAc,GAAG9Q,KAAK,CAAC+Q,WAAvB;AACAmB,IAAAA,WAAW,GAAGlS,KAAK,CAACyR,QAApB;AACAyB,IAAAA,iBAAiB,GAAGlT,KAAK,CAAC2R,cAA1B;AAEA3R,IAAAA,KAAK,CAACuR,QAAN,GAAiB,EAAjB;AACAvR,IAAAA,KAAK,CAAC+Q,WAAN,GAAoB,KAApB;AACA/Q,IAAAA,KAAK,CAACyR,QAAN,GAAiB,KAAjB;AACAzR,IAAAA,KAAK,CAAC2R,cAAN,GAAuB,IAAvB;;AAEA,WAAOhS,KAAK,GAAGG,MAAf,EAAuB;AACnB,UAAIwL,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZ;AACH;;AACDuH,MAAAA,aAAa,GAAG7C,kBAAkB,EAAlC;;AACA,UAAI,OAAO6C,aAAP,KAAyB,WAA7B,EAA0C;AACtC;AACH;;AACDC,MAAAA,cAAc,CAAC5H,IAAf,CAAoB2H,aAApB;AACH;;AAEDzH,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEApL,IAAAA,KAAK,CAACuR,QAAN,GAAiB0B,WAAjB;AACAjT,IAAAA,KAAK,CAAC+Q,WAAN,GAAoBD,cAApB;AACA9Q,IAAAA,KAAK,CAACyR,QAAN,GAAiBS,WAAjB;AACAlS,IAAAA,KAAK,CAAC2R,cAAN,GAAuBuB,iBAAvB;AAEA,WAAO;AACHhL,MAAAA,IAAI,EAAE7I,MAAM,CAACuB,cADV;AAEHwL,MAAAA,IAAI,EAAE0G;AAFH,KAAP;AAIH;;AAED,WAASF,wBAAT,GAAoC;AAChC,QAAI9L,EAAJ;AAAA,QAAQmF,KAAR;AAAA,QAAeM,MAAM,GAAG,EAAxB;AAAA,QAA4BH,IAA5B;AAAA,QAAkCxC,KAAlC;AAAA,QAAyCuJ,QAAzC;AAAA,QAAmDH,eAAnD;AAAA,QAAoEtN,OAApE;AAAA,QAA6EyG,cAA7E;AAAA,QAA6FiH,QAA7F;AAEA/H,IAAAA,aAAa,CAAC,UAAD,CAAb;AACAzB,IAAAA,KAAK,GAAGG,SAAS,EAAjB;AACAjD,IAAAA,EAAE,GAAGmG,uBAAuB,EAA5B;;AACA,QAAIvN,MAAJ,EAAY;AACR,UAAIsH,gBAAgB,CAAC4C,KAAK,CAACzB,KAAP,CAApB,EAAmC;AAC/B4C,QAAAA,kBAAkB,CAACnB,KAAD,EAAQrK,QAAQ,CAACoF,kBAAjB,CAAlB;AACH;AACJ,KAJD,MAIO;AACH,UAAIqC,gBAAgB,CAAC4C,KAAK,CAACzB,KAAP,CAApB,EAAmC;AAC/B6K,QAAAA,eAAe,GAAGpJ,KAAlB;AACAlE,QAAAA,OAAO,GAAGnG,QAAQ,CAACoF,kBAAnB;AACH,OAHD,MAGO,IAAIoC,wBAAwB,CAAC6C,KAAK,CAACzB,KAAP,CAA5B,EAA2C;AAC9C6K,QAAAA,eAAe,GAAGpJ,KAAlB;AACAlE,QAAAA,OAAO,GAAGnG,QAAQ,CAAC6F,kBAAnB;AACH;AACJ;;AAEDgG,IAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,QAAI,CAACE,KAAK,CAAC,GAAD,CAAV,EAAiB;AACb8H,MAAAA,QAAQ,GAAG,EAAX;;AACA,aAAOzT,KAAK,GAAGG,MAAf,EAAuB;AACnB8J,QAAAA,KAAK,GAAGG,SAAS,EAAjB;AACAkC,QAAAA,KAAK,GAAGgB,uBAAuB,EAA/B;;AACA,YAAIvN,MAAJ,EAAY;AACR,cAAIsH,gBAAgB,CAAC4C,KAAK,CAACzB,KAAP,CAApB,EAAmC;AAC/BgL,YAAAA,QAAQ,GAAGvJ,KAAX;AACAlE,YAAAA,OAAO,GAAGnG,QAAQ,CAACkF,eAAnB;AACH;;AACD,cAAI8I,MAAM,CAAC/C,SAAP,CAAiBgD,cAAjB,CAAgC/C,IAAhC,CAAqC2I,QAArC,EAA+CxJ,KAAK,CAACzB,KAArD,CAAJ,EAAiE;AAC7DgL,YAAAA,QAAQ,GAAGvJ,KAAX;AACAlE,YAAAA,OAAO,GAAGnG,QAAQ,CAACmF,eAAnB;AACH;AACJ,SATD,MASO,IAAI,CAACsO,eAAL,EAAsB;AACzB,cAAIhM,gBAAgB,CAAC4C,KAAK,CAACzB,KAAP,CAApB,EAAmC;AAC/B6K,YAAAA,eAAe,GAAGpJ,KAAlB;AACAlE,YAAAA,OAAO,GAAGnG,QAAQ,CAACkF,eAAnB;AACH,WAHD,MAGO,IAAIsC,wBAAwB,CAAC6C,KAAK,CAACzB,KAAP,CAA5B,EAA2C;AAC9C6K,YAAAA,eAAe,GAAGpJ,KAAlB;AACAlE,YAAAA,OAAO,GAAGnG,QAAQ,CAAC6F,kBAAnB;AACH,WAHM,MAGA,IAAImI,MAAM,CAAC/C,SAAP,CAAiBgD,cAAjB,CAAgC/C,IAAhC,CAAqC2I,QAArC,EAA+CxJ,KAAK,CAACzB,KAArD,CAAJ,EAAiE;AACpE6K,YAAAA,eAAe,GAAGpJ,KAAlB;AACAlE,YAAAA,OAAO,GAAGnG,QAAQ,CAACmF,eAAnB;AACH;AACJ;;AACD6H,QAAAA,MAAM,CAACrB,IAAP,CAAYe,KAAZ;AACAmH,QAAAA,QAAQ,CAACnH,KAAK,CAACK,IAAP,CAAR,GAAuB,IAAvB;;AACA,YAAIhB,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZ;AACH;;AACDF,QAAAA,MAAM,CAAC,GAAD,CAAN;AACH;AACJ;;AAEDA,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAe,IAAAA,cAAc,GAAGzM,MAAjB;AACA0M,IAAAA,IAAI,GAAGC,2BAA2B,EAAlC;;AACA,QAAI3M,MAAM,IAAIsT,eAAd,EAA+B;AAC3B1L,MAAAA,UAAU,CAAC0L,eAAD,EAAkBtN,OAAlB,CAAV;AACH;;AACD,QAAIhG,MAAM,IAAIyT,QAAd,EAAwB;AACpBpI,MAAAA,kBAAkB,CAACoI,QAAD,EAAWzN,OAAX,CAAlB;AACH;;AACDhG,IAAAA,MAAM,GAAGyM,cAAT;AAEA,WAAO;AACHjE,MAAAA,IAAI,EAAE7I,MAAM,CAACoC,mBADV;AAEHqF,MAAAA,EAAE,EAAEA,EAFD;AAGHyF,MAAAA,MAAM,EAAEA,MAHL;AAIHC,MAAAA,QAAQ,EAAE,EAJP;AAKHJ,MAAAA,IAAI,EAAEA,IALH;AAMHK,MAAAA,IAAI,EAAE,IANH;AAOHC,MAAAA,SAAS,EAAE,KAPR;AAQHC,MAAAA,UAAU,EAAE;AART,KAAP;AAUH;;AAED,WAASiB,uBAAT,GAAmC;AAC/B,QAAIhE,KAAJ;AAAA,QAAW9C,EAAE,GAAG,IAAhB;AAAA,QAAsBqM,QAAtB;AAAA,QAAgCH,eAAhC;AAAA,QAAiDtN,OAAjD;AAAA,QAA0DuG,KAA1D;AAAA,QAAiEM,MAAM,GAAG,EAA1E;AAAA,QAA8EH,IAA9E;AAAA,QAAoFD,cAApF;AAAA,QAAoGiH,QAApG;AAEA/H,IAAAA,aAAa,CAAC,UAAD,CAAb;;AAEA,QAAI,CAACC,KAAK,CAAC,GAAD,CAAV,EAAiB;AACb1B,MAAAA,KAAK,GAAGG,SAAS,EAAjB;AACAjD,MAAAA,EAAE,GAAGmG,uBAAuB,EAA5B;;AACA,UAAIvN,MAAJ,EAAY;AACR,YAAIsH,gBAAgB,CAAC4C,KAAK,CAACzB,KAAP,CAApB,EAAmC;AAC/B4C,UAAAA,kBAAkB,CAACnB,KAAD,EAAQrK,QAAQ,CAACoF,kBAAjB,CAAlB;AACH;AACJ,OAJD,MAIO;AACH,YAAIqC,gBAAgB,CAAC4C,KAAK,CAACzB,KAAP,CAApB,EAAmC;AAC/B6K,UAAAA,eAAe,GAAGpJ,KAAlB;AACAlE,UAAAA,OAAO,GAAGnG,QAAQ,CAACoF,kBAAnB;AACH,SAHD,MAGO,IAAIoC,wBAAwB,CAAC6C,KAAK,CAACzB,KAAP,CAA5B,EAA2C;AAC9C6K,UAAAA,eAAe,GAAGpJ,KAAlB;AACAlE,UAAAA,OAAO,GAAGnG,QAAQ,CAAC6F,kBAAnB;AACH;AACJ;AACJ;;AAEDgG,IAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,QAAI,CAACE,KAAK,CAAC,GAAD,CAAV,EAAiB;AACb8H,MAAAA,QAAQ,GAAG,EAAX;;AACA,aAAOzT,KAAK,GAAGG,MAAf,EAAuB;AACnB8J,QAAAA,KAAK,GAAGG,SAAS,EAAjB;AACAkC,QAAAA,KAAK,GAAGgB,uBAAuB,EAA/B;;AACA,YAAIvN,MAAJ,EAAY;AACR,cAAIsH,gBAAgB,CAAC4C,KAAK,CAACzB,KAAP,CAApB,EAAmC;AAC/BgL,YAAAA,QAAQ,GAAGvJ,KAAX;AACAlE,YAAAA,OAAO,GAAGnG,QAAQ,CAACkF,eAAnB;AACH;;AACD,cAAI8I,MAAM,CAAC/C,SAAP,CAAiBgD,cAAjB,CAAgC/C,IAAhC,CAAqC2I,QAArC,EAA+CxJ,KAAK,CAACzB,KAArD,CAAJ,EAAiE;AAC7DgL,YAAAA,QAAQ,GAAGvJ,KAAX;AACAlE,YAAAA,OAAO,GAAGnG,QAAQ,CAACmF,eAAnB;AACH;AACJ,SATD,MASO,IAAI,CAACsO,eAAL,EAAsB;AACzB,cAAIhM,gBAAgB,CAAC4C,KAAK,CAACzB,KAAP,CAApB,EAAmC;AAC/B6K,YAAAA,eAAe,GAAGpJ,KAAlB;AACAlE,YAAAA,OAAO,GAAGnG,QAAQ,CAACkF,eAAnB;AACH,WAHD,MAGO,IAAIsC,wBAAwB,CAAC6C,KAAK,CAACzB,KAAP,CAA5B,EAA2C;AAC9C6K,YAAAA,eAAe,GAAGpJ,KAAlB;AACAlE,YAAAA,OAAO,GAAGnG,QAAQ,CAAC6F,kBAAnB;AACH,WAHM,MAGA,IAAImI,MAAM,CAAC/C,SAAP,CAAiBgD,cAAjB,CAAgC/C,IAAhC,CAAqC2I,QAArC,EAA+CxJ,KAAK,CAACzB,KAArD,CAAJ,EAAiE;AACpE6K,YAAAA,eAAe,GAAGpJ,KAAlB;AACAlE,YAAAA,OAAO,GAAGnG,QAAQ,CAACmF,eAAnB;AACH;AACJ;;AACD6H,QAAAA,MAAM,CAACrB,IAAP,CAAYe,KAAZ;AACAmH,QAAAA,QAAQ,CAACnH,KAAK,CAACK,IAAP,CAAR,GAAuB,IAAvB;;AACA,YAAIhB,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZ;AACH;;AACDF,QAAAA,MAAM,CAAC,GAAD,CAAN;AACH;AACJ;;AAEDA,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAe,IAAAA,cAAc,GAAGzM,MAAjB;AACA0M,IAAAA,IAAI,GAAGC,2BAA2B,EAAlC;;AACA,QAAI3M,MAAM,IAAIsT,eAAd,EAA+B;AAC3B1L,MAAAA,UAAU,CAAC0L,eAAD,EAAkBtN,OAAlB,CAAV;AACH;;AACD,QAAIhG,MAAM,IAAIyT,QAAd,EAAwB;AACpBpI,MAAAA,kBAAkB,CAACoI,QAAD,EAAWzN,OAAX,CAAlB;AACH;;AACDhG,IAAAA,MAAM,GAAGyM,cAAT;AAEA,WAAO;AACHjE,MAAAA,IAAI,EAAE7I,MAAM,CAACqC,kBADV;AAEHoF,MAAAA,EAAE,EAAEA,EAFD;AAGHyF,MAAAA,MAAM,EAAEA,MAHL;AAIHC,MAAAA,QAAQ,EAAE,EAJP;AAKHJ,MAAAA,IAAI,EAAEA,IALH;AAMHK,MAAAA,IAAI,EAAE,IANH;AAOHC,MAAAA,SAAS,EAAE,KAPR;AAQHC,MAAAA,UAAU,EAAE;AART,KAAP;AAUH,GA96FsB,CAg7FvB;;;AAEA,WAASqD,kBAAT,GAA8B;AAC1B,QAAIpG,KAAK,GAAGG,SAAS,EAArB;;AAEA,QAAIH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACkB,OAAzB,EAAkC;AAC9B,cAAQuJ,KAAK,CAACzB,KAAd;AACA,aAAK,OAAL;AACA,aAAK,KAAL;AACI,iBAAOqI,wBAAwB,CAAC5G,KAAK,CAACzB,KAAP,CAA/B;;AACJ,aAAK,UAAL;AACI,iBAAOyK,wBAAwB,EAA/B;;AACJ;AACI,iBAAOhC,cAAc,EAArB;AAPJ;AASH;;AAED,QAAIhH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACgB,GAAzB,EAA8B;AAC1B,aAAOyQ,cAAc,EAArB;AACH;AACJ;;AAED,WAASyC,mBAAT,GAA+B;AAC3B,QAAIR,aAAJ;AAAA,QAAmBC,cAAc,GAAG,EAApC;AAAA,QAAwClJ,KAAxC;AAAA,QAA+CmJ,SAA/C;AAAA,QAA0DC,eAA1D;;AAEA,WAAOrT,KAAK,GAAGG,MAAf,EAAuB;AACnB8J,MAAAA,KAAK,GAAGG,SAAS,EAAjB;;AACA,UAAIH,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACsB,aAAzB,EAAwC;AACpC;AACH;;AAEDoS,MAAAA,aAAa,GAAG7C,kBAAkB,EAAlC;AACA8C,MAAAA,cAAc,CAAC5H,IAAf,CAAoB2H,aAApB;;AACA,UAAIA,aAAa,CAAClG,UAAd,CAAyBzE,IAAzB,KAAkC7I,MAAM,CAACuC,OAA7C,EAAsD;AAClD;AACA;AACH;;AACDmR,MAAAA,SAAS,GAAGnN,WAAW,CAACgE,KAAK,CAACxB,KAAN,CAAY,CAAZ,IAAiB,CAAlB,EAAqBwB,KAAK,CAACxB,KAAN,CAAY,CAAZ,IAAiB,CAAtC,CAAvB;;AACA,UAAI2K,SAAS,KAAK,YAAlB,EAAgC;AAC5BrT,QAAAA,MAAM,GAAG,IAAT;;AACA,YAAIsT,eAAJ,EAAqB;AACjBjI,UAAAA,kBAAkB,CAACiI,eAAD,EAAkBzT,QAAQ,CAACqF,kBAA3B,CAAlB;AACH;AACJ,OALD,MAKO;AACH,YAAI,CAACoO,eAAD,IAAoBpJ,KAAK,CAACf,KAA9B,EAAqC;AACjCmK,UAAAA,eAAe,GAAGpJ,KAAlB;AACH;AACJ;AACJ;;AAED,WAAOjK,KAAK,GAAGG,MAAf,EAAuB;AACnB+S,MAAAA,aAAa,GAAG7C,kBAAkB,EAAlC;;AACA,UAAI,OAAO6C,aAAP,KAAyB,WAA7B,EAA0C;AACtC;AACH;;AACDC,MAAAA,cAAc,CAAC5H,IAAf,CAAoB2H,aAApB;AACH;;AACD,WAAOC,cAAP;AACH;;AAED,WAASQ,YAAT,GAAwB;AACpB,QAAIC,OAAJ;AACA7T,IAAAA,MAAM,GAAG,KAAT;AACA6T,IAAAA,OAAO,GAAG;AACNrL,MAAAA,IAAI,EAAE7I,MAAM,CAAC6C,OADP;AAENkK,MAAAA,IAAI,EAAEiH,mBAAmB;AAFnB,KAAV;AAIA,WAAOE,OAAP;AACH,GAp/FsB,CAs/FvB;AACA;;;AAEA,WAASC,UAAT,CAAoBtL,IAApB,EAA0BC,KAA1B,EAAiCH,KAAjC,EAAwCyL,GAAxC,EAA6CC,GAA7C,EAAkD;AAC9ClO,IAAAA,MAAM,CAAC,OAAOwC,KAAP,KAAiB,QAAlB,EAA4B,kCAA5B,CAAN,CAD8C,CAG9C;AACA;AACA;AACA;;AACA,QAAI/H,KAAK,CAAC0T,QAAN,CAAe7T,MAAf,GAAwB,CAA5B,EAA+B;AAC3B,UAAIG,KAAK,CAAC0T,QAAN,CAAe1T,KAAK,CAAC0T,QAAN,CAAe7T,MAAf,GAAwB,CAAvC,EAA0CsI,KAA1C,CAAgD,CAAhD,IAAqDJ,KAAzD,EAAgE;AAC5D;AACH;AACJ;;AAED/H,IAAAA,KAAK,CAAC0T,QAAN,CAAezI,IAAf,CAAoB;AAChBhD,MAAAA,IAAI,EAAEA,IADU;AAEhBC,MAAAA,KAAK,EAAEA,KAFS;AAGhBC,MAAAA,KAAK,EAAE,CAACJ,KAAD,EAAQyL,GAAR,CAHS;AAIhBC,MAAAA,GAAG,EAAEA;AAJW,KAApB;AAMH;;AAED,WAASE,WAAT,GAAuB;AACnB,QAAIC,OAAJ,EAAa1N,EAAb,EAAiBuN,GAAjB,EAAsB1L,KAAtB,EAA6BZ,YAA7B,EAA2CC,WAA3C;AAEAwM,IAAAA,OAAO,GAAG,EAAV;AACAzM,IAAAA,YAAY,GAAG,KAAf;AACAC,IAAAA,WAAW,GAAG,KAAd;;AAEA,WAAO1H,KAAK,GAAGG,MAAf,EAAuB;AACnBqG,MAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AAEA,UAAI0H,WAAJ,EAAiB;AACblB,QAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,EAAN,CAAX;;AACA,YAAI8G,gBAAgB,CAACN,EAAD,CAApB,EAA0B;AACtBuN,UAAAA,GAAG,CAACD,GAAJ,GAAU;AACNxJ,YAAAA,IAAI,EAAErK,UADA;AAENkL,YAAAA,MAAM,EAAEnL,KAAK,GAAGE,SAAR,GAAoB;AAFtB,WAAV;AAIAwH,UAAAA,WAAW,GAAG,KAAd;AACAmM,UAAAA,UAAU,CAAC,MAAD,EAASK,OAAT,EAAkB7L,KAAlB,EAAyBrI,KAAK,GAAG,CAAjC,EAAoC+T,GAApC,CAAV;;AACA,cAAIvN,EAAE,KAAK,IAAP,IAAe1G,MAAM,CAACE,KAAD,CAAN,KAAkB,IAArC,EAA2C;AACvC,cAAEA,KAAF;AACH;;AACD,YAAEC,UAAF;AACAC,UAAAA,SAAS,GAAGF,KAAZ;AACAkU,UAAAA,OAAO,GAAG,EAAV;AACH,SAbD,MAaO,IAAIlU,KAAK,IAAIG,MAAb,EAAqB;AACxBuH,UAAAA,WAAW,GAAG,KAAd;AACAwM,UAAAA,OAAO,IAAI1N,EAAX;AACAuN,UAAAA,GAAG,CAACD,GAAJ,GAAU;AACNxJ,YAAAA,IAAI,EAAErK,UADA;AAENkL,YAAAA,MAAM,EAAEhL,MAAM,GAAGD;AAFX,WAAV;AAIA2T,UAAAA,UAAU,CAAC,MAAD,EAASK,OAAT,EAAkB7L,KAAlB,EAAyBlI,MAAzB,EAAiC4T,GAAjC,CAAV;AACH,SARM,MAQA;AACHG,UAAAA,OAAO,IAAI1N,EAAX;AACH;AACJ,OA1BD,MA0BO,IAAIiB,YAAJ,EAAkB;AACrB,YAAIX,gBAAgB,CAACN,EAAD,CAApB,EAA0B;AACtB,cAAIA,EAAE,KAAK,IAAP,IAAe1G,MAAM,CAACE,KAAK,GAAG,CAAT,CAAN,KAAsB,IAAzC,EAA+C;AAC3C,cAAEA,KAAF;AACAkU,YAAAA,OAAO,IAAI,MAAX;AACH,WAHD,MAGO;AACHA,YAAAA,OAAO,IAAI1N,EAAX;AACH;;AACD,YAAEvG,UAAF;AACA,YAAED,KAAF;AACAE,UAAAA,SAAS,GAAGF,KAAZ;;AACA,cAAIA,KAAK,IAAIG,MAAb,EAAqB;AACjBwH,YAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;AACJ,SAbD,MAaO;AACH+C,UAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,EAAN,CAAX;;AACA,cAAIA,KAAK,IAAIG,MAAb,EAAqB;AACjBwH,YAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;;AACDyQ,UAAAA,OAAO,IAAI1N,EAAX;;AACA,cAAIA,EAAE,KAAK,GAAX,EAAgB;AACZA,YAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAD,CAAX;;AACA,gBAAIwG,EAAE,KAAK,GAAX,EAAgB;AACZ0N,cAAAA,OAAO,GAAGA,OAAO,CAACrK,MAAR,CAAe,CAAf,EAAkBqK,OAAO,CAAC/T,MAAR,GAAiB,CAAnC,CAAV;AACAsH,cAAAA,YAAY,GAAG,KAAf;AACA,gBAAEzH,KAAF;AACA+T,cAAAA,GAAG,CAACD,GAAJ,GAAU;AACNxJ,gBAAAA,IAAI,EAAErK,UADA;AAENkL,gBAAAA,MAAM,EAAEnL,KAAK,GAAGE;AAFV,eAAV;AAIA2T,cAAAA,UAAU,CAAC,OAAD,EAAUK,OAAV,EAAmB7L,KAAnB,EAA0BrI,KAA1B,EAAiC+T,GAAjC,CAAV;AACAG,cAAAA,OAAO,GAAG,EAAV;AACH;AACJ;AACJ;AACJ,OAnCM,MAmCA,IAAI1N,EAAE,KAAK,GAAX,EAAgB;AACnBA,QAAAA,EAAE,GAAG1G,MAAM,CAACE,KAAK,GAAG,CAAT,CAAX;;AACA,YAAIwG,EAAE,KAAK,GAAX,EAAgB;AACZuN,UAAAA,GAAG,GAAG;AACF1L,YAAAA,KAAK,EAAE;AACHiC,cAAAA,IAAI,EAAErK,UADH;AAEHkL,cAAAA,MAAM,EAAEnL,KAAK,GAAGE;AAFb;AADL,WAAN;AAMAmI,UAAAA,KAAK,GAAGrI,KAAR;AACAA,UAAAA,KAAK,IAAI,CAAT;AACA0H,UAAAA,WAAW,GAAG,IAAd;;AACA,cAAI1H,KAAK,IAAIG,MAAb,EAAqB;AACjB4T,YAAAA,GAAG,CAACD,GAAJ,GAAU;AACNxJ,cAAAA,IAAI,EAAErK,UADA;AAENkL,cAAAA,MAAM,EAAEnL,KAAK,GAAGE;AAFV,aAAV;AAIAwH,YAAAA,WAAW,GAAG,KAAd;AACAmM,YAAAA,UAAU,CAAC,MAAD,EAASK,OAAT,EAAkB7L,KAAlB,EAAyBrI,KAAzB,EAAgC+T,GAAhC,CAAV;AACH;AACJ,SAlBD,MAkBO,IAAIvN,EAAE,KAAK,GAAX,EAAgB;AACnB6B,UAAAA,KAAK,GAAGrI,KAAR;AACAA,UAAAA,KAAK,IAAI,CAAT;AACAyH,UAAAA,YAAY,GAAG,IAAf;AACAsM,UAAAA,GAAG,GAAG;AACF1L,YAAAA,KAAK,EAAE;AACHiC,cAAAA,IAAI,EAAErK,UADH;AAEHkL,cAAAA,MAAM,EAAEnL,KAAK,GAAGE,SAAR,GAAoB;AAFzB;AADL,WAAN;;AAMA,cAAIF,KAAK,IAAIG,MAAb,EAAqB;AACjBwH,YAAAA,UAAU,CAAC,EAAD,EAAK/H,QAAQ,CAAC6D,eAAd,EAA+B,SAA/B,CAAV;AACH;AACJ,SAbM,MAaA;AACH;AACH;AACJ,OApCM,MAoCA,IAAImD,YAAY,CAACJ,EAAD,CAAhB,EAAsB;AACzB,UAAExG,KAAF;AACH,OAFM,MAEA,IAAI8G,gBAAgB,CAACN,EAAD,CAApB,EAA0B;AAC7B,UAAExG,KAAF;;AACA,YAAIwG,EAAE,KAAM,IAAR,IAAgB1G,MAAM,CAACE,KAAD,CAAN,KAAkB,IAAtC,EAA4C;AACxC,YAAEA,KAAF;AACH;;AACD,UAAEC,UAAF;AACAC,QAAAA,SAAS,GAAGF,KAAZ;AACH,OAPM,MAOA;AACH;AACH;AACJ;AACJ;;AAED,WAASmU,qBAAT,GAAiC;AAC7B,QAAIrM,CAAJ;AAAA,QAAOsM,KAAP;AAAA,QAAcF,OAAd;AAAA,QAAuBF,QAAQ,GAAG,EAAlC;;AAEA,SAAKlM,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGxH,KAAK,CAAC0T,QAAN,CAAe7T,MAA/B,EAAuC,EAAE2H,CAAzC,EAA4C;AACxCsM,MAAAA,KAAK,GAAG9T,KAAK,CAAC0T,QAAN,CAAelM,CAAf,CAAR;AACAoM,MAAAA,OAAO,GAAG;AACN3L,QAAAA,IAAI,EAAE6L,KAAK,CAAC7L,IADN;AAENC,QAAAA,KAAK,EAAE4L,KAAK,CAAC5L;AAFP,OAAV;;AAIA,UAAIlI,KAAK,CAACmI,KAAV,EAAiB;AACbyL,QAAAA,OAAO,CAACzL,KAAR,GAAgB2L,KAAK,CAAC3L,KAAtB;AACH;;AACD,UAAInI,KAAK,CAACyT,GAAV,EAAe;AACXG,QAAAA,OAAO,CAACH,GAAR,GAAcK,KAAK,CAACL,GAApB;AACH;;AACDC,MAAAA,QAAQ,CAACzI,IAAT,CAAc2I,OAAd;AACH;;AAED5T,IAAAA,KAAK,CAAC0T,QAAN,GAAiBA,QAAjB;AACH;;AAED,WAASK,YAAT,GAAwB;AACpB,QAAIhM,KAAJ,EAAW0L,GAAX,EAAgB9J,KAAhB,EAAuBxB,KAAvB,EAA8BD,KAA9B;AAEAhB,IAAAA,WAAW;AACXa,IAAAA,KAAK,GAAGrI,KAAR;AACA+T,IAAAA,GAAG,GAAG;AACF1L,MAAAA,KAAK,EAAE;AACHiC,QAAAA,IAAI,EAAErK,UADH;AAEHkL,QAAAA,MAAM,EAAEnL,KAAK,GAAGE;AAFb;AADL,KAAN;AAOA+J,IAAAA,KAAK,GAAG3J,KAAK,CAAC4J,OAAN,EAAR;AACA6J,IAAAA,GAAG,CAACD,GAAJ,GAAU;AACNxJ,MAAAA,IAAI,EAAErK,UADA;AAENkL,MAAAA,MAAM,EAAEnL,KAAK,GAAGE;AAFV,KAAV;;AAKA,QAAI+J,KAAK,CAAC1B,IAAN,KAAe/I,KAAK,CAACgB,GAAzB,EAA8B;AAC1BiI,MAAAA,KAAK,GAAG,CAACwB,KAAK,CAACxB,KAAN,CAAY,CAAZ,CAAD,EAAiBwB,KAAK,CAACxB,KAAN,CAAY,CAAZ,CAAjB,CAAR;AACAD,MAAAA,KAAK,GAAGvC,WAAW,CAACgE,KAAK,CAACxB,KAAN,CAAY,CAAZ,CAAD,EAAiBwB,KAAK,CAACxB,KAAN,CAAY,CAAZ,CAAjB,CAAnB;AACAnI,MAAAA,KAAK,CAACgU,MAAN,CAAa/I,IAAb,CAAkB;AACdhD,QAAAA,IAAI,EAAE9I,SAAS,CAACwK,KAAK,CAAC1B,IAAP,CADD;AAEdC,QAAAA,KAAK,EAAEA,KAFO;AAGdC,QAAAA,KAAK,EAAEA,KAHO;AAIdsL,QAAAA,GAAG,EAAEA;AAJS,OAAlB;AAMH;;AAED,WAAO9J,KAAP;AACH;;AAED,WAASsK,YAAT,GAAwB;AACpB,QAAIlK,GAAJ,EAAS0J,GAAT,EAAcS,KAAd,EAAqBvK,KAArB;AAEAzC,IAAAA,WAAW;AAEX6C,IAAAA,GAAG,GAAGrK,KAAN;AACA+T,IAAAA,GAAG,GAAG;AACF1L,MAAAA,KAAK,EAAE;AACHiC,QAAAA,IAAI,EAAErK,UADH;AAEHkL,QAAAA,MAAM,EAAEnL,KAAK,GAAGE;AAFb;AADL,KAAN;AAOAsU,IAAAA,KAAK,GAAGlU,KAAK,CAACkJ,UAAN,EAAR;AACAuK,IAAAA,GAAG,CAACD,GAAJ,GAAU;AACNxJ,MAAAA,IAAI,EAAErK,UADA;AAENkL,MAAAA,MAAM,EAAEnL,KAAK,GAAGE;AAFV,KAAV,CAdoB,CAmBpB;;AACA,QAAII,KAAK,CAACgU,MAAN,CAAanU,MAAb,GAAsB,CAA1B,EAA6B;AACzB8J,MAAAA,KAAK,GAAG3J,KAAK,CAACgU,MAAN,CAAahU,KAAK,CAACgU,MAAN,CAAanU,MAAb,GAAsB,CAAnC,CAAR;;AACA,UAAI8J,KAAK,CAACxB,KAAN,CAAY,CAAZ,MAAmB4B,GAAnB,IAA0BJ,KAAK,CAAC1B,IAAN,KAAe,YAA7C,EAA2D;AACvD,YAAI0B,KAAK,CAACzB,KAAN,KAAgB,GAAhB,IAAuByB,KAAK,CAACzB,KAAN,KAAgB,IAA3C,EAAiD;AAC7ClI,UAAAA,KAAK,CAACgU,MAAN,CAAaG,GAAb;AACH;AACJ;AACJ;;AAEDnU,IAAAA,KAAK,CAACgU,MAAN,CAAa/I,IAAb,CAAkB;AACdhD,MAAAA,IAAI,EAAE,mBADQ;AAEdC,MAAAA,KAAK,EAAEgM,KAAK,CAACzK,OAFC;AAGdtB,MAAAA,KAAK,EAAE,CAAC4B,GAAD,EAAMrK,KAAN,CAHO;AAId+T,MAAAA,GAAG,EAAEA;AAJS,KAAlB;AAOA,WAAOS,KAAP;AACH;;AAED,WAASE,mBAAT,GAA+B;AAC3B,QAAI5M,CAAJ;AAAA,QAAOsM,KAAP;AAAA,QAAcnK,KAAd;AAAA,QAAqBqK,MAAM,GAAG,EAA9B;;AAEA,SAAKxM,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGxH,KAAK,CAACgU,MAAN,CAAanU,MAA7B,EAAqC,EAAE2H,CAAvC,EAA0C;AACtCsM,MAAAA,KAAK,GAAG9T,KAAK,CAACgU,MAAN,CAAaxM,CAAb,CAAR;AACAmC,MAAAA,KAAK,GAAG;AACJ1B,QAAAA,IAAI,EAAE6L,KAAK,CAAC7L,IADR;AAEJC,QAAAA,KAAK,EAAE4L,KAAK,CAAC5L;AAFT,OAAR;;AAIA,UAAIlI,KAAK,CAACmI,KAAV,EAAiB;AACbwB,QAAAA,KAAK,CAACxB,KAAN,GAAc2L,KAAK,CAAC3L,KAApB;AACH;;AACD,UAAInI,KAAK,CAACyT,GAAV,EAAe;AACX9J,QAAAA,KAAK,CAAC8J,GAAN,GAAYK,KAAK,CAACL,GAAlB;AACH;;AACDO,MAAAA,MAAM,CAAC/I,IAAP,CAAYtB,KAAZ;AACH;;AAED3J,IAAAA,KAAK,CAACgU,MAAN,GAAeA,MAAf;AACH;;AAED,WAASpH,aAAT,CAAuBjD,KAAvB,EAA8B;AAC1B,WAAO;AACH1B,MAAAA,IAAI,EAAE7I,MAAM,CAACuC,OADV;AAEHuG,MAAAA,KAAK,EAAEyB,KAAK,CAACzB;AAFV,KAAP;AAIH;;AAED,WAASmM,gBAAT,CAA0B1K,KAA1B,EAAiC;AAC7B,WAAO;AACH1B,MAAAA,IAAI,EAAE7I,MAAM,CAACuC,OADV;AAEHuG,MAAAA,KAAK,EAAEyB,KAAK,CAACzB,KAFV;AAGHoM,MAAAA,GAAG,EAAE3O,WAAW,CAACgE,KAAK,CAACxB,KAAN,CAAY,CAAZ,CAAD,EAAiBwB,KAAK,CAACxB,KAAN,CAAY,CAAZ,CAAjB;AAHb,KAAP;AAKH;;AAED,WAASoM,oBAAT,GAAgC;AAC5B,QAAIC,MAAM,GAAG,EAAb;AAEAA,IAAAA,MAAM,CAACrM,KAAP,GAAe,CAACzI,KAAD,EAAQA,KAAR,CAAf;AACA8U,IAAAA,MAAM,CAACf,GAAP,GAAa;AACT1L,MAAAA,KAAK,EAAE;AACHiC,QAAAA,IAAI,EAAErK,UADH;AAEHkL,QAAAA,MAAM,EAAEnL,KAAK,GAAGE;AAFb,OADE;AAKT4T,MAAAA,GAAG,EAAE;AACDxJ,QAAAA,IAAI,EAAErK,UADL;AAEDkL,QAAAA,MAAM,EAAEnL,KAAK,GAAGE;AAFf;AALI,KAAb;;AAWA4U,IAAAA,MAAM,CAAChB,GAAP,GAAa,YAAY;AACrB,WAAKrL,KAAL,CAAW,CAAX,IAAgBzI,KAAhB;AACA,WAAK+T,GAAL,CAASD,GAAT,CAAaxJ,IAAb,GAAoBrK,UAApB;AACA,WAAK8T,GAAL,CAASD,GAAT,CAAa3I,MAAb,GAAsBnL,KAAK,GAAGE,SAA9B;AACH,KAJD;;AAMA4U,IAAAA,MAAM,CAACC,UAAP,GAAoB,UAAUC,IAAV,EAAgB;AAChC,UAAI1U,KAAK,CAACmI,KAAV,EAAiB;AACbuM,QAAAA,IAAI,CAACC,UAAL,GAAkB,CAAC,KAAKxM,KAAL,CAAW,CAAX,CAAD,EAAgB,KAAKA,KAAL,CAAW,CAAX,CAAhB,CAAlB;AACH;;AACD,UAAInI,KAAK,CAACyT,GAAV,EAAe;AACXiB,QAAAA,IAAI,CAACE,QAAL,GAAgB;AACZ7M,UAAAA,KAAK,EAAE;AACHiC,YAAAA,IAAI,EAAE,KAAKyJ,GAAL,CAAS1L,KAAT,CAAeiC,IADlB;AAEHa,YAAAA,MAAM,EAAE,KAAK4I,GAAL,CAAS1L,KAAT,CAAe8C;AAFpB,WADK;AAKZ2I,UAAAA,GAAG,EAAE;AACDxJ,YAAAA,IAAI,EAAE,KAAKyJ,GAAL,CAASD,GAAT,CAAaxJ,IADlB;AAEDa,YAAAA,MAAM,EAAE,KAAK4I,GAAL,CAASD,GAAT,CAAa3I;AAFpB;AALO,SAAhB;AAUH;AACJ,KAhBD;;AAkBA2J,IAAAA,MAAM,CAACzJ,KAAP,GAAe,UAAU2J,IAAV,EAAgB;AAC3B,UAAI1U,KAAK,CAACmI,KAAV,EAAiB;AACbuM,QAAAA,IAAI,CAACvM,KAAL,GAAa,CAAC,KAAKA,KAAL,CAAW,CAAX,CAAD,EAAgB,KAAKA,KAAL,CAAW,CAAX,CAAhB,CAAb;AACH;;AACD,UAAInI,KAAK,CAACyT,GAAV,EAAe;AACXiB,QAAAA,IAAI,CAACjB,GAAL,GAAW;AACP1L,UAAAA,KAAK,EAAE;AACHiC,YAAAA,IAAI,EAAE,KAAKyJ,GAAL,CAAS1L,KAAT,CAAeiC,IADlB;AAEHa,YAAAA,MAAM,EAAE,KAAK4I,GAAL,CAAS1L,KAAT,CAAe8C;AAFpB,WADA;AAKP2I,UAAAA,GAAG,EAAE;AACDxJ,YAAAA,IAAI,EAAE,KAAKyJ,GAAL,CAASD,GAAT,CAAaxJ,IADlB;AAEDa,YAAAA,MAAM,EAAE,KAAK4I,GAAL,CAASD,GAAT,CAAa3I;AAFpB;AALE,SAAX;AAUH;AACJ,KAhBD;;AAkBA,WAAO2J,MAAP;AACH;;AAED,WAASK,oBAAT,GAAgC;AAC5B,QAAIL,MAAJ,EAAY7I,IAAZ;AAEAzE,IAAAA,WAAW;AACXsN,IAAAA,MAAM,GAAGD,oBAAoB,EAA7B;AACApJ,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAQ,IAAAA,IAAI,GAAG8B,eAAe,EAAtB;AAEAtC,IAAAA,MAAM,CAAC,GAAD,CAAN;AAEAqJ,IAAAA,MAAM,CAAChB,GAAP;AACAgB,IAAAA,MAAM,CAACC,UAAP,CAAkB9I,IAAlB;AAEA,WAAOA,IAAP;AACH;;AAED,WAASmJ,2BAAT,GAAuC;AACnC,QAAIN,MAAJ,EAAY7I,IAAZ;AAEAzE,IAAAA,WAAW;AACXsN,IAAAA,MAAM,GAAGD,oBAAoB,EAA7B;AAEA5I,IAAAA,IAAI,GAAGL,YAAY,CAAC,KAAD,CAAZ,GAAsB0C,kBAAkB,EAAxC,GAA6CN,sBAAsB,EAA1E;;AAEA,WAAOrC,KAAK,CAAC,GAAD,CAAL,IAAcA,KAAK,CAAC,GAAD,CAA1B,EAAiC;AAC7B,UAAIA,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZM,QAAAA,IAAI,GAAG;AACH1D,UAAAA,IAAI,EAAE7I,MAAM,CAAC0C,gBADV;AAEHsM,UAAAA,QAAQ,EAAE,IAFP;AAGHC,UAAAA,MAAM,EAAE1C,IAHL;AAIHwB,UAAAA,QAAQ,EAAEY,mBAAmB;AAJ1B,SAAP;AAMAyG,QAAAA,MAAM,CAAChB,GAAP;AACAgB,QAAAA,MAAM,CAACzJ,KAAP,CAAaY,IAAb;AACH,OATD,MASO;AACHA,QAAAA,IAAI,GAAG;AACH1D,UAAAA,IAAI,EAAE7I,MAAM,CAAC0C,gBADV;AAEHsM,UAAAA,QAAQ,EAAE,KAFP;AAGHC,UAAAA,MAAM,EAAE1C,IAHL;AAIHwB,UAAAA,QAAQ,EAAEW,sBAAsB;AAJ7B,SAAP;AAMA0G,QAAAA,MAAM,CAAChB,GAAP;AACAgB,QAAAA,MAAM,CAACzJ,KAAP,CAAaY,IAAb;AACH;AACJ;;AAED,WAAOA,IAAP;AACH;;AAED,WAASoJ,oCAAT,GAAgD;AAC5C,QAAIP,MAAJ,EAAY7I,IAAZ;AAEAzE,IAAAA,WAAW;AACXsN,IAAAA,MAAM,GAAGD,oBAAoB,EAA7B;AAEA5I,IAAAA,IAAI,GAAGL,YAAY,CAAC,KAAD,CAAZ,GAAsB0C,kBAAkB,EAAxC,GAA6CN,sBAAsB,EAA1E;;AAEA,WAAOrC,KAAK,CAAC,GAAD,CAAL,IAAcA,KAAK,CAAC,GAAD,CAAnB,IAA4BA,KAAK,CAAC,GAAD,CAAxC,EAA+C;AAC3C,UAAIA,KAAK,CAAC,GAAD,CAAT,EAAgB;AACZM,QAAAA,IAAI,GAAG;AACH1D,UAAAA,IAAI,EAAE7I,MAAM,CAAC0B,cADV;AAEHmN,UAAAA,MAAM,EAAEtC,IAFL;AAGH,uBAAaiC,cAAc;AAHxB,SAAP;AAKA4G,QAAAA,MAAM,CAAChB,GAAP;AACAgB,QAAAA,MAAM,CAACzJ,KAAP,CAAaY,IAAb;AACH,OARD,MAQO,IAAIN,KAAK,CAAC,GAAD,CAAT,EAAgB;AACnBM,QAAAA,IAAI,GAAG;AACH1D,UAAAA,IAAI,EAAE7I,MAAM,CAAC0C,gBADV;AAEHsM,UAAAA,QAAQ,EAAE,IAFP;AAGHC,UAAAA,MAAM,EAAE1C,IAHL;AAIHwB,UAAAA,QAAQ,EAAEY,mBAAmB;AAJ1B,SAAP;AAMAyG,QAAAA,MAAM,CAAChB,GAAP;AACAgB,QAAAA,MAAM,CAACzJ,KAAP,CAAaY,IAAb;AACH,OATM,MASA;AACHA,QAAAA,IAAI,GAAG;AACH1D,UAAAA,IAAI,EAAE7I,MAAM,CAAC0C,gBADV;AAEHsM,UAAAA,QAAQ,EAAE,KAFP;AAGHC,UAAAA,MAAM,EAAE1C,IAHL;AAIHwB,UAAAA,QAAQ,EAAEW,sBAAsB;AAJ7B,SAAP;AAMA0G,QAAAA,MAAM,CAAChB,GAAP;AACAgB,QAAAA,MAAM,CAACzJ,KAAP,CAAaY,IAAb;AACH;AACJ;;AAED,WAAOA,IAAP;AACH;;AAED,WAASqJ,WAAT,CAAqBN,IAArB,EAA2B;AACvB,QAAIO,CAAJ,EAAOzN,CAAP,EAAUsM,KAAV;AAEAmB,IAAAA,CAAC,GAAI3H,MAAM,CAAC/C,SAAP,CAAiB8C,QAAjB,CAA0BtC,KAA1B,CAAgC2J,IAAhC,MAA0C,gBAA3C,GAA+D,EAA/D,GAAoE,EAAxE;;AACA,SAAKlN,CAAL,IAAUkN,IAAV,EAAgB;AACZ,UAAIA,IAAI,CAACnH,cAAL,CAAoB/F,CAApB,KAA0BA,CAAC,KAAK,YAAhC,IAAgDA,CAAC,KAAK,UAA1D,EAAsE;AAClEsM,QAAAA,KAAK,GAAGY,IAAI,CAAClN,CAAD,CAAZ;;AACA,YAAIsM,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,QAAnC,IAA+CA,KAAK,YAAYzO,MAApE,EAA4E;AACxE4P,UAAAA,CAAC,CAACzN,CAAD,CAAD,GAAOsM,KAAP;AACH,SAFD,MAEO;AACHmB,UAAAA,CAAC,CAACzN,CAAD,CAAD,GAAOwN,WAAW,CAAClB,KAAD,CAAlB;AACH;AACJ;AACJ;;AACD,WAAOmB,CAAP;AACH;;AAED,WAASC,oBAAT,CAA8B/M,KAA9B,EAAqCsL,GAArC,EAA0C;AAEtC,WAAO,UAAU0B,aAAV,EAAyB;AAE5B,eAASC,QAAT,CAAkBV,IAAlB,EAAwB;AACpB,eAAOA,IAAI,CAACzM,IAAL,KAAc7I,MAAM,CAACyC,iBAArB,IACH6S,IAAI,CAACzM,IAAL,KAAc7I,MAAM,CAACwB,gBADzB;AAEH;;AAED,eAASyU,KAAT,CAAeX,IAAf,EAAqB;AACjB,YAAI3M,KAAJ,EAAWyL,GAAX;;AAEA,YAAI4B,QAAQ,CAACV,IAAI,CAAC/F,IAAN,CAAZ,EAAyB;AACrB0G,UAAAA,KAAK,CAACX,IAAI,CAAC/F,IAAN,CAAL;AACH;;AACD,YAAIyG,QAAQ,CAACV,IAAI,CAAC9F,KAAN,CAAZ,EAA0B;AACtByG,UAAAA,KAAK,CAACX,IAAI,CAAC9F,KAAN,CAAL;AACH;;AAED,YAAIzG,KAAJ,EAAW;AACP,cAAIuM,IAAI,CAAC/F,IAAL,CAAUgG,UAAV,IAAwBD,IAAI,CAAC9F,KAAL,CAAW+F,UAAvC,EAAmD;AAC/C5M,YAAAA,KAAK,GAAG2M,IAAI,CAAC/F,IAAL,CAAUgG,UAAV,GAAuBD,IAAI,CAAC/F,IAAL,CAAUgG,UAAV,CAAqB,CAArB,CAAvB,GAAiDD,IAAI,CAAC/F,IAAL,CAAUxG,KAAV,CAAgB,CAAhB,CAAzD;AACAqL,YAAAA,GAAG,GAAGkB,IAAI,CAAC9F,KAAL,CAAW+F,UAAX,GAAwBD,IAAI,CAAC9F,KAAL,CAAW+F,UAAX,CAAsB,CAAtB,CAAxB,GAAmDD,IAAI,CAAC9F,KAAL,CAAWzG,KAAX,CAAiB,CAAjB,CAAzD;AACAuM,YAAAA,IAAI,CAACvM,KAAL,GAAa,CAACJ,KAAD,EAAQyL,GAAR,CAAb;AACH,WAJD,MAIO,IAAI,OAAOkB,IAAI,CAACvM,KAAZ,KAAsB,WAA1B,EAAuC;AAC1CJ,YAAAA,KAAK,GAAG2M,IAAI,CAAC/F,IAAL,CAAUxG,KAAV,CAAgB,CAAhB,CAAR;AACAqL,YAAAA,GAAG,GAAGkB,IAAI,CAAC9F,KAAL,CAAWzG,KAAX,CAAiB,CAAjB,CAAN;AACAuM,YAAAA,IAAI,CAACvM,KAAL,GAAa,CAACJ,KAAD,EAAQyL,GAAR,CAAb;AACH;AACJ;;AACD,YAAIC,GAAJ,EAAS;AACL,cAAIiB,IAAI,CAAC/F,IAAL,CAAUiG,QAAV,IAAsBF,IAAI,CAAC9F,KAAL,CAAWgG,QAArC,EAA+C;AAC3C7M,YAAAA,KAAK,GAAG2M,IAAI,CAAC/F,IAAL,CAAUiG,QAAV,GAAqBF,IAAI,CAAC/F,IAAL,CAAUiG,QAAV,CAAmB7M,KAAxC,GAAgD2M,IAAI,CAAC/F,IAAL,CAAU8E,GAAV,CAAc1L,KAAtE;AACAyL,YAAAA,GAAG,GAAGkB,IAAI,CAAC9F,KAAL,CAAWgG,QAAX,GAAsBF,IAAI,CAAC9F,KAAL,CAAWgG,QAAX,CAAoBpB,GAA1C,GAAgDkB,IAAI,CAAC9F,KAAL,CAAW6E,GAAX,CAAeD,GAArE;AACAkB,YAAAA,IAAI,CAACjB,GAAL,GAAW;AACP1L,cAAAA,KAAK,EAAEA,KADA;AAEPyL,cAAAA,GAAG,EAAEA;AAFE,aAAX;AAIH,WAPD,MAOO,IAAI,OAAOkB,IAAI,CAACjB,GAAZ,KAAoB,WAAxB,EAAqC;AACxCiB,YAAAA,IAAI,CAACjB,GAAL,GAAW;AACP1L,cAAAA,KAAK,EAAE2M,IAAI,CAAC/F,IAAL,CAAU8E,GAAV,CAAc1L,KADd;AAEPyL,cAAAA,GAAG,EAAEkB,IAAI,CAAC9F,KAAL,CAAW6E,GAAX,CAAeD;AAFb,aAAX;AAIH;AACJ;AACJ;;AAED,aAAO,YAAY;AACf,YAAIgB,MAAJ,EAAYE,IAAZ;AAEAxN,QAAAA,WAAW;AAEXsN,QAAAA,MAAM,GAAGD,oBAAoB,EAA7B;AACAG,QAAAA,IAAI,GAAGS,aAAa,CAACpK,KAAd,CAAoB,IAApB,EAA0BN,SAA1B,CAAP;AACA+J,QAAAA,MAAM,CAAChB,GAAP;;AAEA,YAAIrL,KAAK,IAAI,OAAOuM,IAAI,CAACvM,KAAZ,KAAsB,WAAnC,EAAgD;AAC5CqM,UAAAA,MAAM,CAACzJ,KAAP,CAAa2J,IAAb;AACH;;AAED,YAAIjB,GAAG,IAAI,OAAOiB,IAAI,CAACjB,GAAZ,KAAoB,WAA/B,EAA4C;AACxCe,UAAAA,MAAM,CAACzJ,KAAP,CAAa2J,IAAb;AACH;;AAED,YAAIU,QAAQ,CAACV,IAAD,CAAZ,EAAoB;AAChBW,UAAAA,KAAK,CAACX,IAAD,CAAL;AACH;;AAED,eAAOA,IAAP;AACH,OAtBD;AAuBH,KApED;AAqEH;;AAED,WAASY,KAAT,GAAiB;AAEb,QAAIC,YAAJ;;AAEA,QAAIvV,KAAK,CAAC0T,QAAV,EAAoB;AAChB1T,MAAAA,KAAK,CAACkH,WAAN,GAAoBA,WAApB;AACAA,MAAAA,WAAW,GAAGyM,WAAd;AACH;;AAED,QAAI3T,KAAK,CAACsU,GAAV,EAAe;AACXtU,MAAAA,KAAK,CAAC4M,aAAN,GAAsBA,aAAtB;AACAA,MAAAA,aAAa,GAAGyH,gBAAhB;AACH;;AAED,QAAIrU,KAAK,CAACmI,KAAN,IAAenI,KAAK,CAACyT,GAAzB,EAA8B;AAE1BzT,MAAAA,KAAK,CAACwN,oBAAN,GAA6BA,oBAA7B;AACAxN,MAAAA,KAAK,CAACkO,2BAAN,GAAoCA,2BAApC;AACAlO,MAAAA,KAAK,CAACmO,oCAAN,GAA6CA,oCAA7C;AACAX,MAAAA,oBAAoB,GAAGqH,oBAAvB;AACA3G,MAAAA,2BAA2B,GAAG4G,2BAA9B;AACA3G,MAAAA,oCAAoC,GAAG4G,oCAAvC;AAEAQ,MAAAA,YAAY,GAAGL,oBAAoB,CAAClV,KAAK,CAACmI,KAAP,EAAcnI,KAAK,CAACyT,GAApB,CAAnC;AAEAzT,MAAAA,KAAK,CAAC6O,uBAAN,GAAgCA,uBAAhC;AACA7O,MAAAA,KAAK,CAAC8L,yBAAN,GAAkCA,yBAAlC;AACA9L,MAAAA,KAAK,CAACmP,yBAAN,GAAkCA,yBAAlC;AACAnP,MAAAA,KAAK,CAACqP,wBAAN,GAAiCA,wBAAjC;AACArP,MAAAA,KAAK,CAACoP,yBAAN,GAAkCA,yBAAlC;AACApP,MAAAA,KAAK,CAACgQ,UAAN,GAAmBA,UAAnB;AACAhQ,MAAAA,KAAK,CAACoM,2BAAN,GAAoCA,2BAApC;AACApM,MAAAA,KAAK,CAACoS,gBAAN,GAAyBA,gBAAzB;AACApS,MAAAA,KAAK,CAAC+N,mBAAN,GAA4BA,mBAA5B;AACA/N,MAAAA,KAAK,CAACwP,0BAAN,GAAmCA,0BAAnC;AACAxP,MAAAA,KAAK,CAACuQ,wBAAN,GAAiCA,wBAAjC;AACAvQ,MAAAA,KAAK,CAACkP,uBAAN,GAAgCA,uBAAhC;AACAlP,MAAAA,KAAK,CAACyN,eAAN,GAAwBA,eAAxB;AACAzN,MAAAA,KAAK,CAACgR,2BAAN,GAAoCA,2BAApC;AACAhR,MAAAA,KAAK,CAAC2S,wBAAN,GAAiCA,wBAAjC;AACA3S,MAAAA,KAAK,CAAC2N,uBAAN,GAAgCA,uBAAhC;AACA3N,MAAAA,KAAK,CAACsP,yBAAN,GAAkCA,yBAAlC;AACAtP,MAAAA,KAAK,CAACuP,wBAAN,GAAiCA,wBAAjC;AACAvP,MAAAA,KAAK,CAAC0O,6BAAN,GAAsCA,6BAAtC;AACA1O,MAAAA,KAAK,CAACgO,kBAAN,GAA2BA,kBAA3B;AACAhO,MAAAA,KAAK,CAAC6N,wBAAN,GAAiCA,wBAAjC;AACA7N,MAAAA,KAAK,CAAC6M,mBAAN,GAA4BA,mBAA5B;AACA7M,MAAAA,KAAK,CAAC2M,sBAAN,GAA+BA,sBAA/B;AACA3M,MAAAA,KAAK,CAACsO,sBAAN,GAA+BA,sBAA/B;AACAtO,MAAAA,KAAK,CAAC0N,sBAAN,GAA+BA,sBAA/B;AACA1N,MAAAA,KAAK,CAACqT,YAAN,GAAqBA,YAArB;AACArT,MAAAA,KAAK,CAAC+L,qBAAN,GAA8BA,qBAA9B;AACA/L,MAAAA,KAAK,CAAC+O,yBAAN,GAAkCA,yBAAlC;AACA/O,MAAAA,KAAK,CAAC2Q,cAAN,GAAuBA,cAAvB;AACA3Q,MAAAA,KAAK,CAAC8O,oBAAN,GAA6BA,oBAA7B;AACA9O,MAAAA,KAAK,CAAC4R,eAAN,GAAwBA,eAAxB;AACA5R,MAAAA,KAAK,CAACyO,oBAAN,GAA6BA,oBAA7B;AACAzO,MAAAA,KAAK,CAACkQ,wBAAN,GAAiCA,wBAAjC;AACAlQ,MAAAA,KAAK,CAACgN,uBAAN,GAAgCA,uBAAhC;AAEA6B,MAAAA,uBAAuB,GAAG0G,YAAY,CAACvV,KAAK,CAAC6O,uBAAP,CAAtC;AACA/C,MAAAA,yBAAyB,GAAGyJ,YAAY,CAACvV,KAAK,CAAC8L,yBAAP,CAAxC;AACAqD,MAAAA,yBAAyB,GAAGoG,YAAY,CAACvV,KAAK,CAACmP,yBAAP,CAAxC;AACAE,MAAAA,wBAAwB,GAAGkG,YAAY,CAACvV,KAAK,CAACqP,wBAAP,CAAvC;AACAD,MAAAA,yBAAyB,GAAGmG,YAAY,CAACvV,KAAK,CAACoP,yBAAP,CAAxC;AACAY,MAAAA,UAAU,GAAGuF,YAAY,CAACvV,KAAK,CAACgQ,UAAP,CAAzB;AACA5D,MAAAA,2BAA2B,GAAGmJ,YAAY,CAACvV,KAAK,CAACoM,2BAAP,CAA1C;AACAgG,MAAAA,gBAAgB,GAAGmD,YAAY,CAACvV,KAAK,CAACoS,gBAAP,CAA/B;AACArE,MAAAA,mBAAmB,GAAGwH,YAAY,CAACvV,KAAK,CAAC+N,mBAAP,CAAlC;AACAyB,MAAAA,0BAA0B,GAAG+F,YAAY,CAACvV,KAAK,CAACwP,0BAAP,CAAzC;AACAe,MAAAA,wBAAwB,GAAGgF,YAAY,CAACvV,KAAK,CAACuQ,wBAAP,CAAvC;AACArB,MAAAA,uBAAuB,GAAGqG,YAAY,CAACvV,KAAK,CAACkP,uBAAP,CAAtC;AACAzB,MAAAA,eAAe,GAAG8H,YAAY,CAACvV,KAAK,CAACyN,eAAP,CAA9B;AACAuD,MAAAA,2BAA2B,GAAGuE,YAAY,CAACvV,KAAK,CAACgR,2BAAP,CAA1C;AACA2B,MAAAA,wBAAwB,GAAG4C,YAAY,CAACvV,KAAK,CAAC2S,wBAAP,CAAvC;AACAhF,MAAAA,uBAAuB,GAAG4H,YAAY,CAACvV,KAAK,CAAC2N,uBAAP,CAAtC;AACAO,MAAAA,2BAA2B,GAAGqH,YAAY,CAACrH,2BAAD,CAA1C;AACAoB,MAAAA,yBAAyB,GAAGiG,YAAY,CAACvV,KAAK,CAACsP,yBAAP,CAAxC;AACAC,MAAAA,wBAAwB,GAAGgG,YAAY,CAACvV,KAAK,CAACuP,wBAAP,CAAvC;AACAb,MAAAA,6BAA6B,GAAG6G,YAAY,CAACvV,KAAK,CAAC0O,6BAAP,CAA5C;AACAV,MAAAA,kBAAkB,GAAGuH,YAAY,CAACvV,KAAK,CAACgO,kBAAP,CAAjC;AACAH,MAAAA,wBAAwB,GAAG0H,YAAY,CAACvV,KAAK,CAAC6N,wBAAP,CAAvC;AACAhB,MAAAA,mBAAmB,GAAG0I,YAAY,CAACvV,KAAK,CAAC6M,mBAAP,CAAlC;AACAF,MAAAA,sBAAsB,GAAG4I,YAAY,CAACvV,KAAK,CAAC2M,sBAAP,CAArC;AACA2B,MAAAA,sBAAsB,GAAGiH,YAAY,CAACvV,KAAK,CAACsO,sBAAP,CAArC;AACAZ,MAAAA,sBAAsB,GAAG6H,YAAY,CAACvV,KAAK,CAAC0N,sBAAP,CAArC;AACA2F,MAAAA,YAAY,GAAGkC,YAAY,CAACvV,KAAK,CAACqT,YAAP,CAA3B;AACAtH,MAAAA,qBAAqB,GAAGwJ,YAAY,CAACvV,KAAK,CAAC+L,qBAAP,CAApC;AACAgD,MAAAA,yBAAyB,GAAGwG,YAAY,CAACvV,KAAK,CAAC+O,yBAAP,CAAxC;AACA4B,MAAAA,cAAc,GAAG4E,YAAY,CAACvV,KAAK,CAAC2Q,cAAP,CAA7B;AACA7B,MAAAA,oBAAoB,GAAGyG,YAAY,CAACvV,KAAK,CAAC8O,oBAAP,CAAnC;AACA8C,MAAAA,eAAe,GAAG2D,YAAY,CAACvV,KAAK,CAAC4R,eAAP,CAA9B;AACAnD,MAAAA,oBAAoB,GAAG8G,YAAY,CAACvV,KAAK,CAACyO,oBAAP,CAAnC;AACAyB,MAAAA,wBAAwB,GAAGqF,YAAY,CAACvV,KAAK,CAACkQ,wBAAP,CAAvC;AACAlD,MAAAA,uBAAuB,GAAGuI,YAAY,CAACvV,KAAK,CAACgN,uBAAP,CAAtC;AACH;;AAED,QAAI,OAAOhN,KAAK,CAACgU,MAAb,KAAwB,WAA5B,EAAyC;AACrChU,MAAAA,KAAK,CAAC4J,OAAN,GAAgBA,OAAhB;AACA5J,MAAAA,KAAK,CAACkJ,UAAN,GAAmBA,UAAnB;AAEAU,MAAAA,OAAO,GAAGmK,YAAV;AACA7K,MAAAA,UAAU,GAAG+K,YAAb;AACH;AACJ;;AAED,WAASuB,OAAT,GAAmB;AACf,QAAI,OAAOxV,KAAK,CAACkH,WAAb,KAA6B,UAAjC,EAA6C;AACzCA,MAAAA,WAAW,GAAGlH,KAAK,CAACkH,WAApB;AACH;;AAED,QAAIlH,KAAK,CAACsU,GAAV,EAAe;AACX1H,MAAAA,aAAa,GAAG5M,KAAK,CAAC4M,aAAtB;AACH;;AAED,QAAI5M,KAAK,CAACmI,KAAN,IAAenI,KAAK,CAACyT,GAAzB,EAA8B;AAC1B5E,MAAAA,uBAAuB,GAAG7O,KAAK,CAAC6O,uBAAhC;AACA/C,MAAAA,yBAAyB,GAAG9L,KAAK,CAAC8L,yBAAlC;AACAqD,MAAAA,yBAAyB,GAAGnP,KAAK,CAACmP,yBAAlC;AACAE,MAAAA,wBAAwB,GAAGrP,KAAK,CAACqP,wBAAjC;AACAD,MAAAA,yBAAyB,GAAGpP,KAAK,CAACoP,yBAAlC;AACAY,MAAAA,UAAU,GAAGhQ,KAAK,CAACgQ,UAAnB;AACA5D,MAAAA,2BAA2B,GAAGpM,KAAK,CAACoM,2BAApC;AACAgG,MAAAA,gBAAgB,GAAGpS,KAAK,CAACoS,gBAAzB;AACArE,MAAAA,mBAAmB,GAAG/N,KAAK,CAAC+N,mBAA5B;AACAyB,MAAAA,0BAA0B,GAAGxP,KAAK,CAACwP,0BAAnC;AACAe,MAAAA,wBAAwB,GAAGvQ,KAAK,CAACuQ,wBAAjC;AACArB,MAAAA,uBAAuB,GAAGlP,KAAK,CAACkP,uBAAhC;AACAzB,MAAAA,eAAe,GAAGzN,KAAK,CAACyN,eAAxB;AACAuD,MAAAA,2BAA2B,GAAGhR,KAAK,CAACgR,2BAApC;AACA2B,MAAAA,wBAAwB,GAAG3S,KAAK,CAAC2S,wBAAjC;AACAhF,MAAAA,uBAAuB,GAAG3N,KAAK,CAAC2N,uBAAhC;AACAH,MAAAA,oBAAoB,GAAGxN,KAAK,CAACwN,oBAA7B;AACAU,MAAAA,2BAA2B,GAAGlO,KAAK,CAACkO,2BAApC;AACAC,MAAAA,oCAAoC,GAAGnO,KAAK,CAACmO,oCAA7C;AACAmB,MAAAA,yBAAyB,GAAGtP,KAAK,CAACsP,yBAAlC;AACAC,MAAAA,wBAAwB,GAAGvP,KAAK,CAACuP,wBAAjC;AACAb,MAAAA,6BAA6B,GAAG1O,KAAK,CAAC0O,6BAAtC;AACAV,MAAAA,kBAAkB,GAAGhO,KAAK,CAACgO,kBAA3B;AACAH,MAAAA,wBAAwB,GAAG7N,KAAK,CAAC6N,wBAAjC;AACAhB,MAAAA,mBAAmB,GAAG7M,KAAK,CAAC6M,mBAA5B;AACAF,MAAAA,sBAAsB,GAAG3M,KAAK,CAAC2M,sBAA/B;AACAe,MAAAA,sBAAsB,GAAG1N,KAAK,CAAC0N,sBAA/B;AACAY,MAAAA,sBAAsB,GAAGtO,KAAK,CAACsO,sBAA/B;AACA+E,MAAAA,YAAY,GAAGrT,KAAK,CAACqT,YAArB;AACAtH,MAAAA,qBAAqB,GAAG/L,KAAK,CAAC+L,qBAA9B;AACAgD,MAAAA,yBAAyB,GAAG/O,KAAK,CAAC+O,yBAAlC;AACA4B,MAAAA,cAAc,GAAG3Q,KAAK,CAAC2Q,cAAvB;AACA7B,MAAAA,oBAAoB,GAAG9O,KAAK,CAAC8O,oBAA7B;AACA8C,MAAAA,eAAe,GAAG5R,KAAK,CAAC4R,eAAxB;AACAnD,MAAAA,oBAAoB,GAAGzO,KAAK,CAACyO,oBAA7B;AACAyB,MAAAA,wBAAwB,GAAGlQ,KAAK,CAACkQ,wBAAjC;AACAlD,MAAAA,uBAAuB,GAAGhN,KAAK,CAACgN,uBAAhC;AACH;;AAED,QAAI,OAAOhN,KAAK,CAACkJ,UAAb,KAA4B,UAAhC,EAA4C;AACxCU,MAAAA,OAAO,GAAG5J,KAAK,CAAC4J,OAAhB;AACAV,MAAAA,UAAU,GAAGlJ,KAAK,CAACkJ,UAAnB;AACH;AACJ;;AAED,WAASuM,aAAT,CAAuB1M,GAAvB,EAA4B;AACxB,QAAIlJ,MAAM,GAAGkJ,GAAG,CAAClJ,MAAjB;AAAA,QACI6V,MAAM,GAAG,EADb;AAAA,QAEIlO,CAFJ;;AAGA,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG3H,MAAhB,EAAwB,EAAE2H,CAA1B,EAA6B;AACzBkO,MAAAA,MAAM,CAAClO,CAAD,CAAN,GAAYuB,GAAG,CAAC4M,MAAJ,CAAWnO,CAAX,CAAZ;AACH;;AACD,WAAOkO,MAAP;AACH;;AAED,WAASE,KAAT,CAAelO,IAAf,EAAqBmO,OAArB,EAA8B;AAC1B,QAAIvC,OAAJ,EAAajG,QAAb;AAEAA,IAAAA,QAAQ,GAAGzF,MAAX;;AACA,QAAI,OAAOF,IAAP,KAAgB,QAAhB,IAA4B,EAAEA,IAAI,YAAYE,MAAlB,CAAhC,EAA2D;AACvDF,MAAAA,IAAI,GAAG2F,QAAQ,CAAC3F,IAAD,CAAf;AACH;;AAEDlI,IAAAA,MAAM,GAAGkI,IAAT;AACAhI,IAAAA,KAAK,GAAG,CAAR;AACAC,IAAAA,UAAU,GAAIH,MAAM,CAACK,MAAP,GAAgB,CAAjB,GAAsB,CAAtB,GAA0B,CAAvC;AACAD,IAAAA,SAAS,GAAG,CAAZ;AACAC,IAAAA,MAAM,GAAGL,MAAM,CAACK,MAAhB;AACAC,IAAAA,MAAM,GAAG,IAAT;AACAC,IAAAA,KAAK,GAAG;AACJkP,MAAAA,OAAO,EAAE,IADL;AAEJqC,MAAAA,QAAQ,EAAE,EAFN;AAGJI,MAAAA,cAAc,EAAE,KAHZ;AAIJZ,MAAAA,WAAW,EAAE,KAJT;AAKJU,MAAAA,QAAQ,EAAE;AALN,KAAR;AAQAxR,IAAAA,KAAK,GAAG,EAAR;;AACA,QAAI,OAAO6V,OAAP,KAAmB,WAAvB,EAAoC;AAChC7V,MAAAA,KAAK,CAACmI,KAAN,GAAe,OAAO0N,OAAO,CAAC1N,KAAf,KAAyB,SAA1B,IAAwC0N,OAAO,CAAC1N,KAA9D;AACAnI,MAAAA,KAAK,CAACyT,GAAN,GAAa,OAAOoC,OAAO,CAACpC,GAAf,KAAuB,SAAxB,IAAsCoC,OAAO,CAACpC,GAA1D;AACAzT,MAAAA,KAAK,CAACsU,GAAN,GAAa,OAAOuB,OAAO,CAACvB,GAAf,KAAuB,SAAxB,IAAsCuB,OAAO,CAACvB,GAA1D;;AACA,UAAI,OAAOuB,OAAO,CAAC7B,MAAf,KAA0B,SAA1B,IAAuC6B,OAAO,CAAC7B,MAAnD,EAA2D;AACvDhU,QAAAA,KAAK,CAACgU,MAAN,GAAe,EAAf;AACH;;AACD,UAAI,OAAO6B,OAAO,CAACjC,OAAf,KAA2B,SAA3B,IAAwCiC,OAAO,CAACjC,OAApD,EAA6D;AACzD5T,QAAAA,KAAK,CAAC0T,QAAN,GAAiB,EAAjB;AACH;;AACD,UAAI,OAAOmC,OAAO,CAACC,QAAf,KAA4B,SAA5B,IAAyCD,OAAO,CAACC,QAArD,EAA+D;AAC3D9V,QAAAA,KAAK,CAACgL,MAAN,GAAe,EAAf;AACH;AACJ;;AAED,QAAInL,MAAM,GAAG,CAAb,EAAgB;AACZ,UAAI,OAAOL,MAAM,CAAC,CAAD,CAAb,KAAqB,WAAzB,EAAsC;AAClC;AACA;AACA;AACA,YAAIkI,IAAI,YAAYE,MAApB,EAA4B;AACxBpI,UAAAA,MAAM,GAAGkI,IAAI,CAACqO,OAAL,EAAT;AACH,SANiC,CAQlC;;;AACA,YAAI,OAAOvW,MAAM,CAAC,CAAD,CAAb,KAAqB,WAAzB,EAAsC;AAClCA,UAAAA,MAAM,GAAGiW,aAAa,CAAC/N,IAAD,CAAtB;AACH;AACJ;AACJ;;AAED4N,IAAAA,KAAK;;AACL,QAAI;AACAhC,MAAAA,OAAO,GAAGD,YAAY,EAAtB;;AACA,UAAI,OAAOrT,KAAK,CAAC0T,QAAb,KAA0B,WAA9B,EAA2C;AACvCG,QAAAA,qBAAqB;AACrBP,QAAAA,OAAO,CAACI,QAAR,GAAmB1T,KAAK,CAAC0T,QAAzB;AACH;;AACD,UAAI,OAAO1T,KAAK,CAACgU,MAAb,KAAwB,WAA5B,EAAyC;AACrCI,QAAAA,mBAAmB;AACnBd,QAAAA,OAAO,CAACU,MAAR,GAAiBhU,KAAK,CAACgU,MAAvB;AACH;;AACD,UAAI,OAAOhU,KAAK,CAACgL,MAAb,KAAwB,WAA5B,EAAyC;AACrCsI,QAAAA,OAAO,CAACtI,MAAR,GAAiBhL,KAAK,CAACgL,MAAvB;AACH;;AACD,UAAIhL,KAAK,CAACmI,KAAN,IAAenI,KAAK,CAACyT,GAAzB,EAA8B;AAC1BH,QAAAA,OAAO,CAACnH,IAAR,GAAe6I,WAAW,CAAC1B,OAAO,CAACnH,IAAT,CAA1B;AACH;AACJ,KAhBD,CAgBE,OAAO3C,CAAP,EAAU;AACR,YAAMA,CAAN;AACH,KAlBD,SAkBU;AACNgM,MAAAA,OAAO;AACPxV,MAAAA,KAAK,GAAG,EAAR;AACH;;AAED,WAAOsT,OAAP;AACH,GAnvHsB,CAqvHvB;;;AACAtU,EAAAA,OAAO,CAACgX,OAAR,GAAkB,OAAlB;AAEAhX,EAAAA,OAAO,CAAC4W,KAAR,GAAgBA,KAAhB,CAxvHuB,CA0vHvB;;AACA5W,EAAAA,OAAO,CAACI,MAAR,GAAkB,YAAY;AAC1B,QAAIiN,IAAJ;AAAA,QAAU4J,KAAK,GAAG,EAAlB;;AAEA,QAAI,OAAO3I,MAAM,CAAC4I,MAAd,KAAyB,UAA7B,EAAyC;AACrCD,MAAAA,KAAK,GAAG3I,MAAM,CAAC4I,MAAP,CAAc,IAAd,CAAR;AACH;;AAED,SAAK7J,IAAL,IAAajN,MAAb,EAAqB;AACjB,UAAIA,MAAM,CAACmO,cAAP,CAAsBlB,IAAtB,CAAJ,EAAiC;AAC7B4J,QAAAA,KAAK,CAAC5J,IAAD,CAAL,GAAcjN,MAAM,CAACiN,IAAD,CAApB;AACH;AACJ;;AAED,QAAI,OAAOiB,MAAM,CAAC6I,MAAd,KAAyB,UAA7B,EAAyC;AACrC7I,MAAAA,MAAM,CAAC6I,MAAP,CAAcF,KAAd;AACH;;AAED,WAAOA,KAAP;AACH,GAlBiB,EAAlB;AAoBH,CA3xHA,CAAD;AA4xHA","sourcesContent":["/*\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\nthrowError: true, createLiteral: true, generateStatement: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseStatement: true, parseSourceElement: true */\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        buffer,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function sliceSource(from, to) {\n        return source.slice(from, to);\n    }\n\n    if (typeof 'esprima'[0] === 'undefined') {\n        sliceSource = function sliceArraySource(from, to) {\n            return source.slice(from, to).join('');\n        };\n    }\n\n    function isDecimalDigit(ch) {\n        return '0123456789'.indexOf(ch) >= 0;\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === ' ') || (ch === '\\u0009') || (ch === '\\u000B') ||\n            (ch === '\\u000C') || (ch === '\\u00A0') ||\n            (ch.charCodeAt(0) >= 0x1680 &&\n             '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === '\\n' || ch === '\\r' || ch === '\\u2028' || ch === '\\u2029');\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === '$') || (ch === '_') || (ch === '\\\\') ||\n            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierStart.test(ch));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === '$') || (ch === '_') || (ch === '\\\\') ||\n            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n            ((ch >= '0') && (ch <= '9')) ||\n            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n\n        // Future reserved words.\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        }\n\n        return false;\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n\n        // Strict Mode reserved words.\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        }\n\n        return false;\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        var keyword = false;\n        switch (id.length) {\n        case 2:\n            keyword = (id === 'if') || (id === 'in') || (id === 'do');\n            break;\n        case 3:\n            keyword = (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');\n            break;\n        case 4:\n            keyword = (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with');\n            break;\n        case 5:\n            keyword = (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw');\n            break;\n        case 6:\n            keyword = (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch');\n            break;\n        case 7:\n            keyword = (id === 'default') || (id === 'finally');\n            break;\n        case 8:\n            keyword = (id === 'function') || (id === 'continue') || (id === 'debugger');\n            break;\n        case 10:\n            keyword = (id === 'instanceof');\n            break;\n        }\n\n        if (keyword) {\n            return true;\n        }\n\n        switch (id) {\n        // Future reserved words.\n        // 'const' is specialized as Keyword in V8.\n        case 'const':\n            return true;\n\n        // For compatiblity to SpiderMonkey and ES.next\n        case 'yield':\n        case 'let':\n            return true;\n        }\n\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        return isFutureReservedWord(id);\n    }\n\n    // 7.4 Comments\n\n    function skipComment() {\n        var ch, blockComment, lineComment;\n\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source[index];\n\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch)) {\n                    lineComment = false;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === '\\r' && source[index + 1] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            ++index;\n                            blockComment = false;\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    index += 2;\n                    lineComment = true;\n                } else if (ch === '*') {\n                    index += 2;\n                    blockComment = true;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanIdentifier() {\n        var ch, start, id, restore;\n\n        ch = source[index];\n        if (!isIdentifierStart(ch)) {\n            return;\n        }\n\n        start = index;\n        if (ch === '\\\\') {\n            ++index;\n            if (source[index] !== 'u') {\n                return;\n            }\n            ++index;\n            restore = index;\n            ch = scanHexEscape('u');\n            if (ch) {\n                if (ch === '\\\\' || !isIdentifierStart(ch)) {\n                    return;\n                }\n                id = ch;\n            } else {\n                index = restore;\n                id = 'u';\n            }\n        } else {\n            id = source[index++];\n        }\n\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            if (ch === '\\\\') {\n                ++index;\n                if (source[index] !== 'u') {\n                    return;\n                }\n                ++index;\n                restore = index;\n                ch = scanHexEscape('u');\n                if (ch) {\n                    if (ch === '\\\\' || !isIdentifierPart(ch)) {\n                        return;\n                    }\n                    id += ch;\n                } else {\n                    index = restore;\n                    id += 'u';\n                }\n            } else {\n                id += source[index++];\n            }\n        }\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            return {\n                type: Token.Identifier,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (isKeyword(id)) {\n            return {\n                type: Token.Keyword,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 7.8.1 Null Literals\n\n        if (id === 'null') {\n            return {\n                type: Token.NullLiteral,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 7.8.2 Boolean Literals\n\n        if (id === 'true' || id === 'false') {\n            return {\n                type: Token.BooleanLiteral,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        return {\n            type: Token.Identifier,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        // Check for most common single-character punctuators.\n\n        if (ch1 === ';' || ch1 === '{' || ch1 === '}') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === ',' || ch1 === '(' || ch1 === ')') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Dot (.) can also start a floating-point number, hence the need\n        // to check the next character.\n\n        ch2 = source[index + 1];\n        if (ch1 === '.' && !isDecimalDigit(ch2)) {\n            return {\n                type: Token.Punctuator,\n                value: source[index++],\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Peek more characters.\n\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '=' && ch2 === '=' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '===',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '!' && ch2 === '=' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '!==',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 2-character punctuators: <= >= == != ++ -- << >> && ||\n        // += -= *= %= &= |= ^= /=\n\n        if (ch2 === '=') {\n            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n                index += 2;\n                return {\n                    type: Token.Punctuator,\n                    value: ch1 + ch2,\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {\n            if ('+-<>&|'.indexOf(ch2) >= 0) {\n                index += 2;\n                return {\n                    type: Token.Punctuator,\n                    value: ch1 + ch2,\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // The remaining 1-character punctuators.\n\n        if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {\n            return {\n                type: Token.Punctuator,\n                value: source[index++],\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    number += source[index++];\n                    while (index < length) {\n                        ch = source[index];\n                        if (!isHexDigit(ch)) {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n\n                    if (number.length <= 2) {\n                        // only 0x\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n\n                    if (index < length) {\n                        ch = source[index];\n                        if (isIdentifierStart(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 16),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                } else if (isOctalDigit(ch)) {\n                    number += source[index++];\n                    while (index < length) {\n                        ch = source[index];\n                        if (!isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n\n                    if (index < length) {\n                        ch = source[index];\n                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 8),\n                        octal: true,\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                }\n\n                // decimal number starts with '0' such as '09' is illegal.\n                if (isDecimalDigit(ch)) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (index < length) {\n                ch = source[index];\n                if (!isDecimalDigit(ch)) {\n                    break;\n                }\n                number += source[index++];\n            }\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (index < length) {\n                ch = source[index];\n                if (!isDecimalDigit(ch)) {\n                    break;\n                }\n                number += source[index++];\n            }\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n\n            ch = source[index];\n            if (isDecimalDigit(ch)) {\n                number += source[index++];\n                while (index < length) {\n                    ch = source[index];\n                    if (!isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += source[index++];\n                }\n            } else {\n                ch = 'character ' + ch;\n                if (index >= length) {\n                    ch = '<end>';\n                }\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (index < length) {\n            ch = source[index];\n            if (isIdentifierStart(ch)) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch)) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                }\n            } else if (isLineTerminator(ch)) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanRegExp() {\n        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;\n\n        buffer = null;\n        skipComment();\n\n        start = index;\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch)) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                } else if (isLineTerminator(ch)) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        pattern = str.substr(1, str.length - 2);\n\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        str += '\\\\u';\n                        for (; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                } else {\n                    str += '\\\\';\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n        return {\n            literal: str,\n            value: value,\n            range: [start, index]\n        };\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advance() {\n        var ch, token;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        token = scanPunctuator();\n        if (typeof token !== 'undefined') {\n            return token;\n        }\n\n        ch = source[index];\n\n        if (ch === '\\'' || ch === '\"') {\n            return scanStringLiteral();\n        }\n\n        if (ch === '.' || isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        token = scanIdentifier();\n        if (typeof token !== 'undefined') {\n            return token;\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function lex() {\n        var token;\n\n        if (buffer) {\n            index = buffer.range[1];\n            lineNumber = buffer.lineNumber;\n            lineStart = buffer.lineStart;\n            token = buffer;\n            buffer = null;\n            return token;\n        }\n\n        buffer = null;\n        return advance();\n    }\n\n    function lookahead() {\n        var pos, line, start;\n\n        if (buffer !== null) {\n            return buffer;\n        }\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        buffer = advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return buffer;\n    }\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    return args[index] || '';\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        var token = lookahead();\n        return token.type === Token.Punctuator && token.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        var token = lookahead();\n        return token.type === Token.Keyword && token.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var token = lookahead(),\n            op = token.value;\n\n        if (token.type !== Token.Punctuator) {\n            return false;\n        }\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var token, line;\n\n        // Catch the very common case first.\n        if (source[index] === ';') {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        token = lookahead();\n        if (token.type !== Token.EOF && !match('}')) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [];\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        expect(']');\n\n        return {\n            type: Syntax.ArrayExpression,\n            elements: elements\n        };\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body;\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            throwErrorTolerant(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionExpression,\n            id: null,\n            params: param,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    function parseObjectPropertyKey() {\n        var token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return createLiteral(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, param;\n\n        token = lookahead();\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                return {\n                    type: Syntax.Property,\n                    key: key,\n                    value: parsePropertyFunction([]),\n                    kind: 'get'\n                };\n            } else if (token.value === 'set' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead();\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n                    return {\n                        type: Syntax.Property,\n                        key: key,\n                        value: parsePropertyFunction([]),\n                        kind: 'set'\n                    };\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    return {\n                        type: Syntax.Property,\n                        key: key,\n                        value: parsePropertyFunction(param, token),\n                        kind: 'set'\n                    };\n                }\n            } else {\n                expect(':');\n                return {\n                    type: Syntax.Property,\n                    key: id,\n                    value: parseAssignmentExpression(),\n                    kind: 'init'\n                };\n            }\n        } else if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpected(token);\n        } else {\n            key = parseObjectPropertyKey();\n            expect(':');\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: parseAssignmentExpression(),\n                kind: 'init'\n            };\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, kind, map = {}, toString = String;\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n            if (Object.prototype.hasOwnProperty.call(map, name)) {\n                if (map[name] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[name] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[name] |= kind;\n            } else {\n                map[name] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return {\n            type: Syntax.ObjectExpression,\n            properties: properties\n        };\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var token = lookahead(),\n            type = token.type;\n\n        if (type === Token.Identifier) {\n            return {\n                type: Syntax.Identifier,\n                name: lex().value\n            };\n        }\n\n        if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return createLiteral(lex());\n        }\n\n        if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                lex();\n                return {\n                    type: Syntax.ThisExpression\n                };\n            }\n\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n        }\n\n        if (type === Token.BooleanLiteral) {\n            lex();\n            token.value = (token.value === 'true');\n            return createLiteral(token);\n        }\n\n        if (type === Token.NullLiteral) {\n            lex();\n            token.value = null;\n            return createLiteral(token);\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('/') || match('/=')) {\n            return createLiteral(scanRegExp());\n        }\n\n        return throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var expr;\n\n        expectKeyword('new');\n\n        expr = {\n            type: Syntax.NewExpression,\n            callee: parseLeftHandSideExpression(),\n            'arguments': []\n        };\n\n        if (match('(')) {\n            expr['arguments'] = parseArguments();\n        }\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                expr = {\n                    type: Syntax.CallExpression,\n                    callee: expr,\n                    'arguments': parseArguments()\n                };\n            } else if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n            }\n        }\n\n        return expr;\n    }\n\n\n    function parseLeftHandSideExpression() {\n        var expr;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr = parseLeftHandSideExpressionAllowCall(), token;\n\n        token = lookahead();\n        if (token.type !== Token.Punctuator) {\n            return expr;\n        }\n\n        if ((match('++') || match('--')) && !peekLineTerminator()) {\n            // 11.3.1, 11.3.2\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPostfix);\n            }\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = {\n                type: Syntax.UpdateExpression,\n                operator: lex().value,\n                argument: expr,\n                prefix: false\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr;\n\n        token = lookahead();\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return parsePostfixExpression();\n        }\n\n        if (match('++') || match('--')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = {\n                type: Syntax.UpdateExpression,\n                operator: token.value,\n                argument: expr,\n                prefix: true\n            };\n            return expr;\n        }\n\n        if (match('+') || match('-') || match('~') || match('!')) {\n            expr = {\n                type: Syntax.UnaryExpression,\n                operator: lex().value,\n                argument: parseUnaryExpression(),\n                prefix: true\n            };\n            return expr;\n        }\n\n        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            expr = {\n                type: Syntax.UnaryExpression,\n                operator: lex().value,\n                argument: parseUnaryExpression(),\n                prefix: true\n            };\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n            return expr;\n        }\n\n        return parsePostfixExpression();\n    }\n\n    // 11.5 Multiplicative Operators\n\n    function parseMultiplicativeExpression() {\n        var expr = parseUnaryExpression();\n\n        while (match('*') || match('/') || match('%')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseUnaryExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.6 Additive Operators\n\n    function parseAdditiveExpression() {\n        var expr = parseMultiplicativeExpression();\n\n        while (match('+') || match('-')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseMultiplicativeExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.7 Bitwise Shift Operators\n\n    function parseShiftExpression() {\n        var expr = parseAdditiveExpression();\n\n        while (match('<<') || match('>>') || match('>>>')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseAdditiveExpression()\n            };\n        }\n\n        return expr;\n    }\n    // 11.8 Relational Operators\n\n    function parseRelationalExpression() {\n        var expr, previousAllowIn;\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n\n        expr = parseShiftExpression();\n\n        while (match('<') || match('>') || match('<=') || match('>=') || (previousAllowIn && matchKeyword('in')) || matchKeyword('instanceof')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseShiftExpression()\n            };\n        }\n\n        state.allowIn = previousAllowIn;\n        return expr;\n    }\n\n    // 11.9 Equality Operators\n\n    function parseEqualityExpression() {\n        var expr = parseRelationalExpression();\n\n        while (match('==') || match('!=') || match('===') || match('!==')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseRelationalExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.10 Binary Bitwise Operators\n\n    function parseBitwiseANDExpression() {\n        var expr = parseEqualityExpression();\n\n        while (match('&')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '&',\n                left: expr,\n                right: parseEqualityExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseBitwiseXORExpression() {\n        var expr = parseBitwiseANDExpression();\n\n        while (match('^')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '^',\n                left: expr,\n                right: parseBitwiseANDExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseBitwiseORExpression() {\n        var expr = parseBitwiseXORExpression();\n\n        while (match('|')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '|',\n                left: expr,\n                right: parseBitwiseXORExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.11 Binary Logical Operators\n\n    function parseLogicalANDExpression() {\n        var expr = parseBitwiseORExpression();\n\n        while (match('&&')) {\n            lex();\n            expr = {\n                type: Syntax.LogicalExpression,\n                operator: '&&',\n                left: expr,\n                right: parseBitwiseORExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseLogicalORExpression() {\n        var expr = parseLogicalANDExpression();\n\n        while (match('||')) {\n            lex();\n            expr = {\n                type: Syntax.LogicalExpression,\n                operator: '||',\n                left: expr,\n                right: parseLogicalANDExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent;\n\n        expr = parseLogicalORExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n\n            expr = {\n                type: Syntax.ConditionalExpression,\n                test: expr,\n                consequent: consequent,\n                alternate: parseAssignmentExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, expr;\n\n        token = lookahead();\n        expr = parseConditionalExpression();\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            expr = {\n                type: Syntax.AssignmentExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseAssignmentExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expr = {\n                type: Syntax.SequenceExpression,\n                expressions: [ expr ]\n            };\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr.expressions.push(parseAssignmentExpression());\n            }\n\n        }\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block;\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return {\n            type: Syntax.BlockStatement,\n            body: block\n        };\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseVariableDeclaration(kind) {\n        var id = parseVariableIdentifier(),\n            init = null;\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            throwErrorTolerant({}, Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return {\n            type: Syntax.VariableDeclarator,\n            id: id,\n            init: init\n        };\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: declarations,\n            kind: 'var'\n        };\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations;\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: declarations,\n            kind: kind\n        };\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        expect(';');\n\n        return {\n            type: Syntax.EmptyStatement\n        };\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var expr = parseExpression();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ExpressionStatement,\n            expression: expr\n        };\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return {\n            type: Syntax.IfStatement,\n            test: test,\n            consequent: consequent,\n            alternate: alternate\n        };\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return {\n            type: Syntax.DoWhileStatement,\n            body: body,\n            test: test\n        };\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return {\n            type: Syntax.WhileStatement,\n            test: test,\n            body: body\n        };\n    }\n\n    function parseForVariableDeclaration() {\n        var token = lex();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: parseVariableDeclarationList(),\n            kind: token.value\n        };\n    }\n\n    function parseForStatement() {\n        var init, test, update, left, right, body, oldInIteration;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n\n                if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isLeftHandSide(init)) {\n                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        if (typeof left === 'undefined') {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        }\n\n        return {\n            type: Syntax.ForInStatement,\n            left: left,\n            right: right,\n            body: body,\n            each: false\n        };\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var token, label = null;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source[index] === ';') {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return {\n                type: Syntax.ContinueStatement,\n                label: null\n            };\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return {\n                type: Syntax.ContinueStatement,\n                label: null\n            };\n        }\n\n        token = lookahead();\n        if (token.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return {\n            type: Syntax.ContinueStatement,\n            label: label\n        };\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var token, label = null;\n\n        expectKeyword('break');\n\n        // Optimize the most common form: 'break;'.\n        if (source[index] === ';') {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return {\n                type: Syntax.BreakStatement,\n                label: null\n            };\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return {\n                type: Syntax.BreakStatement,\n                label: null\n            };\n        }\n\n        token = lookahead();\n        if (token.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return {\n            type: Syntax.BreakStatement,\n            label: label\n        };\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var token, argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source[index] === ' ') {\n            if (isIdentifierStart(source[index + 1])) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return {\n                    type: Syntax.ReturnStatement,\n                    argument: argument\n                };\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: null\n            };\n        }\n\n        if (!match(';')) {\n            token = lookahead();\n            if (!match('}') && token.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ReturnStatement,\n            argument: argument\n        };\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body;\n\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return {\n            type: Syntax.WithStatement,\n            object: object,\n            body: body\n        };\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test,\n            consequent = [],\n            statement;\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            consequent.push(statement);\n        }\n\n        return {\n            type: Syntax.SwitchCase,\n            test: test,\n            consequent: consequent\n        };\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return {\n            type: Syntax.SwitchStatement,\n            discriminant: discriminant,\n            cases: cases\n        };\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ThrowStatement,\n            argument: argument\n        };\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param;\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead());\n        }\n\n        param = parseVariableIdentifier();\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n\n        return {\n            type: Syntax.CatchClause,\n            param: param,\n            body: parseBlock()\n        };\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return {\n            type: Syntax.TryStatement,\n            block: block,\n            guardedHandlers: [],\n            handlers: handlers,\n            finalizer: finalizer\n        };\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.DebuggerStatement\n        };\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var token = lookahead(),\n            expr,\n            labeledBody;\n\n        if (token.type === Token.EOF) {\n            throwUnexpected(token);\n        }\n\n        if (token.type === Token.Punctuator) {\n            switch (token.value) {\n            case ';':\n                return parseEmptyStatement();\n            case '{':\n                return parseBlock();\n            case '(':\n                return parseExpressionStatement();\n            default:\n                break;\n            }\n        }\n\n        if (token.type === Token.Keyword) {\n            switch (token.value) {\n            case 'break':\n                return parseBreakStatement();\n            case 'continue':\n                return parseContinueStatement();\n            case 'debugger':\n                return parseDebuggerStatement();\n            case 'do':\n                return parseDoWhileStatement();\n            case 'for':\n                return parseForStatement();\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'if':\n                return parseIfStatement();\n            case 'return':\n                return parseReturnStatement();\n            case 'switch':\n                return parseSwitchStatement();\n            case 'throw':\n                return parseThrowStatement();\n            case 'try':\n                return parseTryStatement();\n            case 'var':\n                return parseVariableStatement();\n            case 'while':\n                return parseWhileStatement();\n            case 'with':\n                return parseWithStatement();\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[expr.name] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[expr.name];\n\n            return {\n                type: Syntax.LabeledStatement,\n                label: expr,\n                body: labeledBody\n            };\n        }\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ExpressionStatement,\n            expression: expr\n        };\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;\n\n        expect('{');\n\n        while (index < length) {\n            token = lookahead();\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n\n        return {\n            type: Syntax.BlockStatement,\n            body: sourceElements\n        };\n    }\n\n    function parseFunctionDeclaration() {\n        var id, param, params = [], body, token, stricted, firstRestricted, message, previousStrict, paramSet;\n\n        expectKeyword('function');\n        token = lookahead();\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead();\n                param = parseVariableIdentifier();\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[param.name] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionDeclaration,\n            id: id,\n            params: params,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, param, params = [], body, previousStrict, paramSet;\n\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead();\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    throwErrorTolerant(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead();\n                param = parseVariableIdentifier();\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[param.name] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionExpression,\n            id: id,\n            params: params,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    // 14 Program\n\n    function parseSourceElement() {\n        var token = lookahead();\n\n        if (token.type === Token.Keyword) {\n            switch (token.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(token.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (token.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead();\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var program;\n        strict = false;\n        program = {\n            type: Syntax.Program,\n            body: parseSourceElements()\n        };\n        return program;\n    }\n\n    // The following functions are needed only when the option to preserve\n    // the comments is active.\n\n    function addComment(type, value, start, end, loc) {\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (extra.comments.length > 0) {\n            if (extra.comments[extra.comments.length - 1].range[1] > start) {\n                return;\n            }\n        }\n\n        extra.comments.push({\n            type: type,\n            value: value,\n            range: [start, end],\n            loc: loc\n        });\n    }\n\n    function scanComment() {\n        var comment, ch, loc, start, blockComment, lineComment;\n\n        comment = '';\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source[index];\n\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch)) {\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    lineComment = false;\n                    addComment('Line', comment, start, index - 1, loc);\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                    comment = '';\n                } else if (index >= length) {\n                    lineComment = false;\n                    comment += ch;\n                    loc.end = {\n                        line: lineNumber,\n                        column: length - lineStart\n                    };\n                    addComment('Line', comment, start, length, loc);\n                } else {\n                    comment += ch;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === '\\r' && source[index + 1] === '\\n') {\n                        ++index;\n                        comment += '\\r\\n';\n                    } else {\n                        comment += ch;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    comment += ch;\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            comment = comment.substr(0, comment.length - 1);\n                            blockComment = false;\n                            ++index;\n                            loc.end = {\n                                line: lineNumber,\n                                column: index - lineStart\n                            };\n                            addComment('Block', comment, start, index, loc);\n                            comment = '';\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart\n                        }\n                    };\n                    start = index;\n                    index += 2;\n                    lineComment = true;\n                    if (index >= length) {\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        lineComment = false;\n                        addComment('Line', comment, start, index, loc);\n                    }\n                } else if (ch === '*') {\n                    start = index;\n                    index += 2;\n                    blockComment = true;\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart - 2\n                        }\n                    };\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function filterCommentLocation() {\n        var i, entry, comment, comments = [];\n\n        for (i = 0; i < extra.comments.length; ++i) {\n            entry = extra.comments[i];\n            comment = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                comment.range = entry.range;\n            }\n            if (extra.loc) {\n                comment.loc = entry.loc;\n            }\n            comments.push(comment);\n        }\n\n        extra.comments = comments;\n    }\n\n    function collectToken() {\n        var start, loc, token, range, value;\n\n        skipComment();\n        start = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = extra.advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = sliceSource(token.range[0], token.range[1]);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            });\n        }\n\n        return token;\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = extra.scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        // Pop the previous token, which is likely '/' or '/='\n        if (extra.tokens.length > 0) {\n            token = extra.tokens[extra.tokens.length - 1];\n            if (token.range[0] === pos && token.type === 'Punctuator') {\n                if (token.value === '/' || token.value === '/=') {\n                    extra.tokens.pop();\n                }\n            }\n        }\n\n        extra.tokens.push({\n            type: 'RegularExpression',\n            value: regex.literal,\n            range: [pos, index],\n            loc: loc\n        });\n\n        return regex;\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function createLiteral(token) {\n        return {\n            type: Syntax.Literal,\n            value: token.value\n        };\n    }\n\n    function createRawLiteral(token) {\n        return {\n            type: Syntax.Literal,\n            value: token.value,\n            raw: sliceSource(token.range[0], token.range[1])\n        };\n    }\n\n    function createLocationMarker() {\n        var marker = {};\n\n        marker.range = [index, index];\n        marker.loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            },\n            end: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        marker.end = function () {\n            this.range[1] = index;\n            this.loc.end.line = lineNumber;\n            this.loc.end.column = index - lineStart;\n        };\n\n        marker.applyGroup = function (node) {\n            if (extra.range) {\n                node.groupRange = [this.range[0], this.range[1]];\n            }\n            if (extra.loc) {\n                node.groupLoc = {\n                    start: {\n                        line: this.loc.start.line,\n                        column: this.loc.start.column\n                    },\n                    end: {\n                        line: this.loc.end.line,\n                        column: this.loc.end.column\n                    }\n                };\n            }\n        };\n\n        marker.apply = function (node) {\n            if (extra.range) {\n                node.range = [this.range[0], this.range[1]];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: this.loc.start.line,\n                        column: this.loc.start.column\n                    },\n                    end: {\n                        line: this.loc.end.line,\n                        column: this.loc.end.column\n                    }\n                };\n            }\n        };\n\n        return marker;\n    }\n\n    function trackGroupExpression() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        marker.end();\n        marker.applyGroup(expr);\n\n        return expr;\n    }\n\n    function trackLeftHandSideExpression() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function trackLeftHandSideExpressionAllowCall() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                expr = {\n                    type: Syntax.CallExpression,\n                    callee: expr,\n                    'arguments': parseArguments()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function filterGroup(node) {\n        var n, i, entry;\n\n        n = (Object.prototype.toString.apply(node) === '[object Array]') ? [] : {};\n        for (i in node) {\n            if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {\n                entry = node[i];\n                if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {\n                    n[i] = entry;\n                } else {\n                    n[i] = filterGroup(entry);\n                }\n            }\n        }\n        return n;\n    }\n\n    function wrapTrackingFunction(range, loc) {\n\n        return function (parseFunction) {\n\n            function isBinary(node) {\n                return node.type === Syntax.LogicalExpression ||\n                    node.type === Syntax.BinaryExpression;\n            }\n\n            function visit(node) {\n                var start, end;\n\n                if (isBinary(node.left)) {\n                    visit(node.left);\n                }\n                if (isBinary(node.right)) {\n                    visit(node.right);\n                }\n\n                if (range) {\n                    if (node.left.groupRange || node.right.groupRange) {\n                        start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];\n                        end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];\n                        node.range = [start, end];\n                    } else if (typeof node.range === 'undefined') {\n                        start = node.left.range[0];\n                        end = node.right.range[1];\n                        node.range = [start, end];\n                    }\n                }\n                if (loc) {\n                    if (node.left.groupLoc || node.right.groupLoc) {\n                        start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;\n                        end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;\n                        node.loc = {\n                            start: start,\n                            end: end\n                        };\n                    } else if (typeof node.loc === 'undefined') {\n                        node.loc = {\n                            start: node.left.loc.start,\n                            end: node.right.loc.end\n                        };\n                    }\n                }\n            }\n\n            return function () {\n                var marker, node;\n\n                skipComment();\n\n                marker = createLocationMarker();\n                node = parseFunction.apply(null, arguments);\n                marker.end();\n\n                if (range && typeof node.range === 'undefined') {\n                    marker.apply(node);\n                }\n\n                if (loc && typeof node.loc === 'undefined') {\n                    marker.apply(node);\n                }\n\n                if (isBinary(node)) {\n                    visit(node);\n                }\n\n                return node;\n            };\n        };\n    }\n\n    function patch() {\n\n        var wrapTracking;\n\n        if (extra.comments) {\n            extra.skipComment = skipComment;\n            skipComment = scanComment;\n        }\n\n        if (extra.raw) {\n            extra.createLiteral = createLiteral;\n            createLiteral = createRawLiteral;\n        }\n\n        if (extra.range || extra.loc) {\n\n            extra.parseGroupExpression = parseGroupExpression;\n            extra.parseLeftHandSideExpression = parseLeftHandSideExpression;\n            extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;\n            parseGroupExpression = trackGroupExpression;\n            parseLeftHandSideExpression = trackLeftHandSideExpression;\n            parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;\n\n            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);\n\n            extra.parseAdditiveExpression = parseAdditiveExpression;\n            extra.parseAssignmentExpression = parseAssignmentExpression;\n            extra.parseBitwiseANDExpression = parseBitwiseANDExpression;\n            extra.parseBitwiseORExpression = parseBitwiseORExpression;\n            extra.parseBitwiseXORExpression = parseBitwiseXORExpression;\n            extra.parseBlock = parseBlock;\n            extra.parseFunctionSourceElements = parseFunctionSourceElements;\n            extra.parseCatchClause = parseCatchClause;\n            extra.parseComputedMember = parseComputedMember;\n            extra.parseConditionalExpression = parseConditionalExpression;\n            extra.parseConstLetDeclaration = parseConstLetDeclaration;\n            extra.parseEqualityExpression = parseEqualityExpression;\n            extra.parseExpression = parseExpression;\n            extra.parseForVariableDeclaration = parseForVariableDeclaration;\n            extra.parseFunctionDeclaration = parseFunctionDeclaration;\n            extra.parseFunctionExpression = parseFunctionExpression;\n            extra.parseLogicalANDExpression = parseLogicalANDExpression;\n            extra.parseLogicalORExpression = parseLogicalORExpression;\n            extra.parseMultiplicativeExpression = parseMultiplicativeExpression;\n            extra.parseNewExpression = parseNewExpression;\n            extra.parseNonComputedProperty = parseNonComputedProperty;\n            extra.parseObjectProperty = parseObjectProperty;\n            extra.parseObjectPropertyKey = parseObjectPropertyKey;\n            extra.parsePostfixExpression = parsePostfixExpression;\n            extra.parsePrimaryExpression = parsePrimaryExpression;\n            extra.parseProgram = parseProgram;\n            extra.parsePropertyFunction = parsePropertyFunction;\n            extra.parseRelationalExpression = parseRelationalExpression;\n            extra.parseStatement = parseStatement;\n            extra.parseShiftExpression = parseShiftExpression;\n            extra.parseSwitchCase = parseSwitchCase;\n            extra.parseUnaryExpression = parseUnaryExpression;\n            extra.parseVariableDeclaration = parseVariableDeclaration;\n            extra.parseVariableIdentifier = parseVariableIdentifier;\n\n            parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);\n            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);\n            parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);\n            parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);\n            parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);\n            parseBlock = wrapTracking(extra.parseBlock);\n            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);\n            parseCatchClause = wrapTracking(extra.parseCatchClause);\n            parseComputedMember = wrapTracking(extra.parseComputedMember);\n            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);\n            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);\n            parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);\n            parseExpression = wrapTracking(extra.parseExpression);\n            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);\n            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);\n            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);\n            parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);\n            parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);\n            parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);\n            parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);\n            parseNewExpression = wrapTracking(extra.parseNewExpression);\n            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);\n            parseObjectProperty = wrapTracking(extra.parseObjectProperty);\n            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);\n            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);\n            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);\n            parseProgram = wrapTracking(extra.parseProgram);\n            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);\n            parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);\n            parseStatement = wrapTracking(extra.parseStatement);\n            parseShiftExpression = wrapTracking(extra.parseShiftExpression);\n            parseSwitchCase = wrapTracking(extra.parseSwitchCase);\n            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);\n            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);\n            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);\n        }\n\n        if (typeof extra.tokens !== 'undefined') {\n            extra.advance = advance;\n            extra.scanRegExp = scanRegExp;\n\n            advance = collectToken;\n            scanRegExp = collectRegex;\n        }\n    }\n\n    function unpatch() {\n        if (typeof extra.skipComment === 'function') {\n            skipComment = extra.skipComment;\n        }\n\n        if (extra.raw) {\n            createLiteral = extra.createLiteral;\n        }\n\n        if (extra.range || extra.loc) {\n            parseAdditiveExpression = extra.parseAdditiveExpression;\n            parseAssignmentExpression = extra.parseAssignmentExpression;\n            parseBitwiseANDExpression = extra.parseBitwiseANDExpression;\n            parseBitwiseORExpression = extra.parseBitwiseORExpression;\n            parseBitwiseXORExpression = extra.parseBitwiseXORExpression;\n            parseBlock = extra.parseBlock;\n            parseFunctionSourceElements = extra.parseFunctionSourceElements;\n            parseCatchClause = extra.parseCatchClause;\n            parseComputedMember = extra.parseComputedMember;\n            parseConditionalExpression = extra.parseConditionalExpression;\n            parseConstLetDeclaration = extra.parseConstLetDeclaration;\n            parseEqualityExpression = extra.parseEqualityExpression;\n            parseExpression = extra.parseExpression;\n            parseForVariableDeclaration = extra.parseForVariableDeclaration;\n            parseFunctionDeclaration = extra.parseFunctionDeclaration;\n            parseFunctionExpression = extra.parseFunctionExpression;\n            parseGroupExpression = extra.parseGroupExpression;\n            parseLeftHandSideExpression = extra.parseLeftHandSideExpression;\n            parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;\n            parseLogicalANDExpression = extra.parseLogicalANDExpression;\n            parseLogicalORExpression = extra.parseLogicalORExpression;\n            parseMultiplicativeExpression = extra.parseMultiplicativeExpression;\n            parseNewExpression = extra.parseNewExpression;\n            parseNonComputedProperty = extra.parseNonComputedProperty;\n            parseObjectProperty = extra.parseObjectProperty;\n            parseObjectPropertyKey = extra.parseObjectPropertyKey;\n            parsePrimaryExpression = extra.parsePrimaryExpression;\n            parsePostfixExpression = extra.parsePostfixExpression;\n            parseProgram = extra.parseProgram;\n            parsePropertyFunction = extra.parsePropertyFunction;\n            parseRelationalExpression = extra.parseRelationalExpression;\n            parseStatement = extra.parseStatement;\n            parseShiftExpression = extra.parseShiftExpression;\n            parseSwitchCase = extra.parseSwitchCase;\n            parseUnaryExpression = extra.parseUnaryExpression;\n            parseVariableDeclaration = extra.parseVariableDeclaration;\n            parseVariableIdentifier = extra.parseVariableIdentifier;\n        }\n\n        if (typeof extra.scanRegExp === 'function') {\n            advance = extra.advance;\n            scanRegExp = extra.scanRegExp;\n        }\n    }\n\n    function stringToArray(str) {\n        var length = str.length,\n            result = [],\n            i;\n        for (i = 0; i < length; ++i) {\n            result[i] = str.charAt(i);\n        }\n        return result;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        buffer = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.raw = (typeof options.raw === 'boolean') && options.raw;\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n\n                // Force accessing the characters via an array.\n                if (typeof source[0] === 'undefined') {\n                    source = stringToArray(code);\n                }\n            }\n        }\n\n        patch();\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                filterCommentLocation();\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n            if (extra.range || extra.loc) {\n                program.body = filterGroup(program.body);\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with package.json.\n    exports.version = '1.0.4';\n\n    exports.parse = parse;\n\n    // Deep copy.\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n"]},"metadata":{},"sourceType":"script"}