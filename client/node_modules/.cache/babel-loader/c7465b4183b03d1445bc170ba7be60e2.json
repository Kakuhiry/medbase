{"ast":null,"code":"// Basic Lexer implemented using JavaScript regular expressions\n// MIT Licensed\nvar RegExpLexer = function () {\n  \"use strict\";\n\n  var lexParser = require('lex-parser');\n\n  var version = require('./package.json').version; // expand macros and convert matchers to RegExp's\n\n\n  function prepareRules(rules, macros, actions, tokens, startConditions, caseless) {\n    var m,\n        i,\n        k,\n        action,\n        conditions,\n        newRules = [];\n\n    if (macros) {\n      macros = prepareMacros(macros);\n    }\n\n    function tokenNumberReplacement(str, token) {\n      return \"return \" + (tokens[token] || \"'\" + token + \"'\");\n    }\n\n    actions.push('switch($avoiding_name_collisions) {');\n\n    for (i = 0; i < rules.length; i++) {\n      if (Object.prototype.toString.apply(rules[i][0]) !== '[object Array]') {\n        // implicit add to all inclusive start conditions\n        for (k in startConditions) {\n          if (startConditions[k].inclusive) {\n            startConditions[k].rules.push(i);\n          }\n        }\n      } else if (rules[i][0][0] === '*') {\n        // Add to ALL start conditions\n        for (k in startConditions) {\n          startConditions[k].rules.push(i);\n        }\n\n        rules[i].shift();\n      } else {\n        // Add to explicit start conditions\n        conditions = rules[i].shift();\n\n        for (k = 0; k < conditions.length; k++) {\n          startConditions[conditions[k]].rules.push(i);\n        }\n      }\n\n      m = rules[i][0];\n\n      if (typeof m === 'string') {\n        for (k in macros) {\n          if (macros.hasOwnProperty(k)) {\n            m = m.split(\"{\" + k + \"}\").join('(' + macros[k] + ')');\n          }\n        }\n\n        m = new RegExp(\"^(?:\" + m + \")\", caseless ? 'i' : '');\n      }\n\n      newRules.push(m);\n\n      if (typeof rules[i][1] === 'function') {\n        rules[i][1] = String(rules[i][1]).replace(/^\\s*function \\(\\)\\s?\\{/, '').replace(/\\}\\s*$/, '');\n      }\n\n      action = rules[i][1];\n\n      if (tokens && action.match(/return '[^']+'/)) {\n        action = action.replace(/return '([^']+)'/g, tokenNumberReplacement);\n      }\n\n      actions.push('case ' + i + ':' + action + '\\nbreak;');\n    }\n\n    actions.push(\"}\");\n    return newRules;\n  } // expand macros within macros\n\n\n  function prepareMacros(macros) {\n    var cont = true,\n        m,\n        i,\n        k,\n        mnew;\n\n    while (cont) {\n      cont = false;\n\n      for (i in macros) if (macros.hasOwnProperty(i)) {\n        m = macros[i];\n\n        for (k in macros) if (macros.hasOwnProperty(k) && i !== k) {\n          mnew = m.split(\"{\" + k + \"}\").join('(' + macros[k] + ')');\n\n          if (mnew !== m) {\n            cont = true;\n            macros[i] = mnew;\n          }\n        }\n      }\n    }\n\n    return macros;\n  }\n\n  function prepareStartConditions(conditions) {\n    var sc,\n        hash = {};\n\n    for (sc in conditions) if (conditions.hasOwnProperty(sc)) {\n      hash[sc] = {\n        rules: [],\n        inclusive: !!!conditions[sc]\n      };\n    }\n\n    return hash;\n  }\n\n  function buildActions(dict, tokens) {\n    var actions = [dict.actionInclude || '', \"var YYSTATE=YY_START;\"];\n    var tok;\n    var toks = {};\n\n    for (tok in tokens) {\n      toks[tokens[tok]] = tok;\n    }\n\n    if (dict.options && dict.options.flex) {\n      dict.rules.push([\".\", \"console.log(yytext);\"]);\n    }\n\n    this.rules = prepareRules(dict.rules, dict.macros, actions, tokens && toks, this.conditions, this.options[\"case-insensitive\"]);\n    var fun = actions.join(\"\\n\");\n    \"yytext yyleng yylineno yylloc\".split(' ').forEach(function (yy) {\n      fun = fun.replace(new RegExp(\"\\\\b(\" + yy + \")\\\\b\", \"g\"), \"yy_.$1\");\n    }); // first try to create the performAction function the old way,\n    // but this will break for some legal constructs in the user action code:\n\n    try {\n      return Function(\"yy,yy_,$avoiding_name_collisions,YY_START\", fun);\n    } catch (e) {\n      return \"function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\" + fun + \"\\n}\";\n    }\n  }\n\n  function RegExpLexer(dict, input, tokens) {\n    if (typeof dict === 'string') {\n      dict = lexParser.parse(dict);\n    }\n\n    dict = dict || {};\n    this.options = dict.options || {};\n    this.conditions = prepareStartConditions(dict.startConditions);\n    this.conditions.INITIAL = {\n      rules: [],\n      inclusive: true\n    };\n    this.performAction = buildActions.call(this, dict, tokens);\n    this.conditionStack = ['INITIAL'];\n    this.moduleInclude = (dict.moduleInclude || '').trim();\n    this.yy = {};\n\n    if (input) {\n      this.setInput(input);\n    }\n  }\n\n  RegExpLexer.prototype = {\n    EOF: 1,\n    parseError: function parseError(str, hash) {\n      if (this.yy.parser) {\n        this.yy.parser.parseError(str, hash);\n      } else {\n        throw new Error(str);\n      }\n    },\n    // resets the lexer, sets new input\n    setInput: function (input) {\n      this._input = input;\n      this._more = this._backtrack = this.done = false;\n      this.yylineno = this.yyleng = 0;\n      this.yytext = this.matched = this.match = '';\n      this.conditionStack = ['INITIAL'];\n      this.yylloc = {\n        first_line: 1,\n        first_column: 0,\n        last_line: 1,\n        last_column: 0\n      };\n\n      if (this.options.ranges) {\n        this.yylloc.range = [0, 0];\n      }\n\n      this.offset = 0;\n      return this;\n    },\n    // consumes and returns one char from the input\n    input: function () {\n      var ch = this._input[0];\n      this.yytext += ch;\n      this.yyleng++;\n      this.offset++;\n      this.match += ch;\n      this.matched += ch;\n      var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n\n      if (lines) {\n        this.yylineno++;\n        this.yylloc.last_line++;\n      } else {\n        this.yylloc.last_column++;\n      }\n\n      if (this.options.ranges) {\n        this.yylloc.range[1]++;\n      }\n\n      this._input = this._input.slice(1);\n      return ch;\n    },\n    // unshifts one char (or a string) into the input\n    unput: function (ch) {\n      var len = ch.length;\n      var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n      this._input = ch + this._input;\n      this.yytext = this.yytext.substr(0, this.yytext.length - len - 1); //this.yyleng -= len;\n\n      this.offset -= len;\n      var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n      this.match = this.match.substr(0, this.match.length - 1);\n      this.matched = this.matched.substr(0, this.matched.length - 1);\n\n      if (lines.length - 1) {\n        this.yylineno -= lines.length - 1;\n      }\n\n      var r = this.yylloc.range;\n      this.yylloc = {\n        first_line: this.yylloc.first_line,\n        last_line: this.yylineno + 1,\n        first_column: this.yylloc.first_column,\n        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n      };\n\n      if (this.options.ranges) {\n        this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n      }\n\n      this.yyleng = this.yytext.length;\n      return this;\n    },\n    // When called from action, caches matched text and appends it on next action\n    more: function () {\n      this._more = true;\n      return this;\n    },\n    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n    reject: function () {\n      if (this.options.backtrack_lexer) {\n        this._backtrack = true;\n      } else {\n        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n          text: \"\",\n          token: null,\n          line: this.yylineno\n        });\n      }\n\n      return this;\n    },\n    // retain first n characters of the match\n    less: function (n) {\n      this.unput(this.match.slice(n));\n    },\n    // displays already matched input, i.e. for error messages\n    pastInput: function () {\n      var past = this.matched.substr(0, this.matched.length - this.match.length);\n      return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n    // displays upcoming input, i.e. for error messages\n    upcomingInput: function () {\n      var next = this.match;\n\n      if (next.length < 20) {\n        next += this._input.substr(0, 20 - next.length);\n      }\n\n      return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n    // displays the character position where the lexing error occurred, i.e. for error messages\n    showPosition: function () {\n      var pre = this.pastInput();\n      var c = new Array(pre.length + 1).join(\"-\");\n      return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n    // test the lexed token: return FALSE when not a match, otherwise return token\n    test_match: function (match, indexed_rule) {\n      var token, lines, backup;\n\n      if (this.options.backtrack_lexer) {\n        // save context\n        backup = {\n          yylineno: this.yylineno,\n          yylloc: {\n            first_line: this.yylloc.first_line,\n            last_line: this.last_line,\n            first_column: this.yylloc.first_column,\n            last_column: this.yylloc.last_column\n          },\n          yytext: this.yytext,\n          match: this.match,\n          matches: this.matches,\n          matched: this.matched,\n          yyleng: this.yyleng,\n          offset: this.offset,\n          _more: this._more,\n          _input: this._input,\n          yy: this.yy,\n          conditionStack: this.conditionStack.slice(0),\n          done: this.done\n        };\n\n        if (this.options.ranges) {\n          backup.yylloc.range = this.yylloc.range.slice(0);\n        }\n      }\n\n      lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n\n      if (lines) {\n        this.yylineno += lines.length;\n      }\n\n      this.yylloc = {\n        first_line: this.yylloc.last_line,\n        last_line: this.yylineno + 1,\n        first_column: this.yylloc.last_column,\n        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n      };\n      this.yytext += match[0];\n      this.match += match[0];\n      this.matches = match;\n      this.yyleng = this.yytext.length;\n\n      if (this.options.ranges) {\n        this.yylloc.range = [this.offset, this.offset += this.yyleng];\n      }\n\n      this._more = false;\n      this._backtrack = false;\n      this._input = this._input.slice(match[0].length);\n      this.matched += match[0];\n      token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n\n      if (this.done && this._input) {\n        this.done = false;\n      }\n\n      if (token) {\n        return token;\n      } else if (this._backtrack) {\n        // recover context\n        for (var k in backup) {\n          this[k] = backup[k];\n        }\n\n        return false; // rule action called reject() implying the next rule should be tested instead.\n      }\n\n      return false;\n    },\n    // return next match in input\n    next: function () {\n      if (this.done) {\n        return this.EOF;\n      }\n\n      if (!this._input) {\n        this.done = true;\n      }\n\n      var token, match, tempMatch, index;\n\n      if (!this._more) {\n        this.yytext = '';\n        this.match = '';\n      }\n\n      var rules = this._currentRules();\n\n      for (var i = 0; i < rules.length; i++) {\n        tempMatch = this._input.match(this.rules[rules[i]]);\n\n        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n          match = tempMatch;\n          index = i;\n\n          if (this.options.backtrack_lexer) {\n            token = this.test_match(tempMatch, rules[i]);\n\n            if (token !== false) {\n              return token;\n            } else if (this._backtrack) {\n              match = false;\n              continue; // rule action called reject() implying a rule MISmatch.\n            } else {\n              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n              return false;\n            }\n          } else if (!this.options.flex) {\n            break;\n          }\n        }\n      }\n\n      if (match) {\n        token = this.test_match(match, rules[index]);\n\n        if (token !== false) {\n          return token;\n        } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n\n\n        return false;\n      }\n\n      if (this._input === \"\") {\n        return this.EOF;\n      } else {\n        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n          text: \"\",\n          token: null,\n          line: this.yylineno\n        });\n      }\n    },\n    // return next match that has a token\n    lex: function lex() {\n      var r = this.next();\n\n      if (r) {\n        return r;\n      } else {\n        return this.lex();\n      }\n    },\n    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n    begin: function begin(condition) {\n      this.conditionStack.push(condition);\n    },\n    // pop the previously active lexer condition state off the condition stack\n    popState: function popState() {\n      var n = this.conditionStack.length - 1;\n\n      if (n > 0) {\n        return this.conditionStack.pop();\n      } else {\n        return this.conditionStack[0];\n      }\n    },\n    // produce the lexer rule set which is active for the currently active lexer condition state\n    _currentRules: function _currentRules() {\n      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n      } else {\n        return this.conditions[\"INITIAL\"].rules;\n      }\n    },\n    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n    topState: function topState(n) {\n      n = this.conditionStack.length - 1 - Math.abs(n || 0);\n\n      if (n >= 0) {\n        return this.conditionStack[n];\n      } else {\n        return \"INITIAL\";\n      }\n    },\n    // alias for begin(condition)\n    pushState: function pushState(condition) {\n      this.begin(condition);\n    },\n    // return the number of states pushed\n    stateStackSize: function stateStackSize() {\n      return this.conditionStack.length;\n    },\n    generate: function generate(opt) {\n      var code = \"\";\n\n      if (opt.moduleType === 'commonjs') {\n        code = this.generateCommonJSModule(opt);\n      } else if (opt.moduleType === 'amd') {\n        code = this.generateAMDModule(opt);\n      } else {\n        code = this.generateModule(opt);\n      }\n\n      return code;\n    },\n    generateModuleBody: function generateModule() {\n      var function_descriptions = {\n        setInput: \"resets the lexer, sets new input\",\n        input: \"consumes and returns one char from the input\",\n        unput: \"unshifts one char (or a string) into the input\",\n        more: \"When called from action, caches matched text and appends it on next action\",\n        reject: \"When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\",\n        less: \"retain first n characters of the match\",\n        pastInput: \"displays already matched input, i.e. for error messages\",\n        upcomingInput: \"displays upcoming input, i.e. for error messages\",\n        showPosition: \"displays the character position where the lexing error occurred, i.e. for error messages\",\n        test_match: \"test the lexed token: return FALSE when not a match, otherwise return token\",\n        next: \"return next match in input\",\n        lex: \"return next match that has a token\",\n        begin: \"activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\",\n        popState: \"pop the previously active lexer condition state off the condition stack\",\n        _currentRules: \"produce the lexer rule set which is active for the currently active lexer condition state\",\n        topState: \"return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\",\n        pushState: \"alias for begin(condition)\",\n        stateStackSize: \"return the number of states currently on the stack\"\n      };\n      var out = \"{\\n\";\n      var p = [];\n      var descr;\n\n      for (var k in RegExpLexer.prototype) {\n        if (RegExpLexer.prototype.hasOwnProperty(k) && k.indexOf(\"generate\") === -1) {\n          // copy the function description as a comment before the implementation; supports multi-line descriptions\n          descr = \"\\n\";\n\n          if (function_descriptions[k]) {\n            descr += \"// \" + function_descriptions[k].replace(/\\n/g, \"\\n\\/\\/ \") + \"\\n\";\n          }\n\n          p.push(descr + k + \":\" + (RegExpLexer.prototype[k].toString() || '\"\"'));\n        }\n      }\n\n      out += p.join(\",\\n\");\n\n      if (this.options) {\n        out += \",\\noptions: \" + JSON.stringify(this.options);\n      }\n\n      out += \",\\nperformAction: \" + String(this.performAction);\n      out += \",\\nrules: [\" + this.rules + \"]\";\n      out += \",\\nconditions: \" + JSON.stringify(this.conditions);\n      out += \"\\n}\";\n      return out;\n    },\n    generateModule: function generateModule(opt) {\n      opt = opt || {};\n      var out = \"/* generated by jison-lex \" + version + \" */\";\n      var moduleName = opt.moduleName || \"lexer\";\n      out += \"\\nvar \" + moduleName + \" = (function(){\\nvar lexer = \" + this.generateModuleBody();\n      if (this.moduleInclude) out += \";\\n\" + this.moduleInclude;\n      out += \";\\nreturn lexer;\\n})();\";\n      return out;\n    },\n    generateAMDModule: function generateAMDModule() {\n      var out = \"/* generated by jison-lex \" + version + \" */\";\n      out += \"define([], function(){\\nvar lexer = \" + this.generateModuleBody();\n      if (this.moduleInclude) out += \";\\n\" + this.moduleInclude;\n      out += \";\\nreturn lexer;\" + \"\\n})();\";\n      return out;\n    },\n    generateCommonJSModule: function generateCommonJSModule(opt) {\n      opt = opt || {};\n      var out = \"\";\n      var moduleName = opt.moduleName || \"lexer\";\n      out += this.generateModule(opt);\n      out += \"\\nexports.lexer = \" + moduleName;\n      out += \";\\nexports.lex = function () { return \" + moduleName + \".lex.apply(lexer, arguments); };\";\n      return out;\n    }\n  };\n  return RegExpLexer;\n}();\n\nmodule.exports = RegExpLexer;","map":{"version":3,"sources":["/home/elvis/Documents/GitHub/medbase/mern-auth/node_modules/jison-lex/regexp-lexer.js"],"names":["RegExpLexer","lexParser","require","version","prepareRules","rules","macros","actions","tokens","startConditions","caseless","m","i","k","action","conditions","newRules","prepareMacros","tokenNumberReplacement","str","token","push","length","Object","prototype","toString","apply","inclusive","shift","hasOwnProperty","split","join","RegExp","String","replace","match","cont","mnew","prepareStartConditions","sc","hash","buildActions","dict","actionInclude","tok","toks","options","flex","fun","forEach","yy","Function","e","input","parse","INITIAL","performAction","call","conditionStack","moduleInclude","trim","setInput","EOF","parseError","parser","Error","_input","_more","_backtrack","done","yylineno","yyleng","yytext","matched","yylloc","first_line","first_column","last_line","last_column","ranges","range","offset","ch","lines","slice","unput","len","substr","oldLines","r","more","reject","backtrack_lexer","showPosition","text","line","less","n","pastInput","past","upcomingInput","next","pre","c","Array","test_match","indexed_rule","backup","matches","tempMatch","index","_currentRules","lex","begin","condition","popState","pop","topState","Math","abs","pushState","stateStackSize","generate","opt","code","moduleType","generateCommonJSModule","generateAMDModule","generateModule","generateModuleBody","function_descriptions","out","p","descr","indexOf","JSON","stringify","moduleName","module","exports"],"mappings":"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","sourcesContent":["// Basic Lexer implemented using JavaScript regular expressions\n// MIT Licensed\n\nvar RegExpLexer = (function () {\n\"use strict\";\n\nvar lexParser = require('lex-parser');\nvar version = require('./package.json').version;\n\n// expand macros and convert matchers to RegExp's\nfunction prepareRules(rules, macros, actions, tokens, startConditions, caseless) {\n    var m,i,k,action,conditions,\n        newRules = [];\n\n    if (macros) {\n        macros = prepareMacros(macros);\n    }\n\n    function tokenNumberReplacement (str, token) {\n        return \"return \"+(tokens[token] || \"'\"+token+\"'\");\n    }\n\n    actions.push('switch($avoiding_name_collisions) {');\n\n    for (i=0;i < rules.length; i++) {\n        if (Object.prototype.toString.apply(rules[i][0]) !== '[object Array]') {\n            // implicit add to all inclusive start conditions\n            for (k in startConditions) {\n                if (startConditions[k].inclusive) {\n                    startConditions[k].rules.push(i);\n                }\n            }\n        } else if (rules[i][0][0] === '*') {\n            // Add to ALL start conditions\n            for (k in startConditions) {\n                startConditions[k].rules.push(i);\n            }\n            rules[i].shift();\n        } else {\n            // Add to explicit start conditions\n            conditions = rules[i].shift();\n            for (k=0;k<conditions.length;k++) {\n                startConditions[conditions[k]].rules.push(i);\n            }\n        }\n\n        m = rules[i][0];\n        if (typeof m === 'string') {\n            for (k in macros) {\n                if (macros.hasOwnProperty(k)) {\n                    m = m.split(\"{\"+k+\"}\").join('(' + macros[k] + ')');\n                }\n            }\n            m = new RegExp(\"^(?:\"+m+\")\", caseless ? 'i':'');\n        }\n        newRules.push(m);\n        if (typeof rules[i][1] === 'function') {\n            rules[i][1] = String(rules[i][1]).replace(/^\\s*function \\(\\)\\s?\\{/, '').replace(/\\}\\s*$/, '');\n        }\n        action = rules[i][1];\n        if (tokens && action.match(/return '[^']+'/)) {\n            action = action.replace(/return '([^']+)'/g, tokenNumberReplacement);\n        }\n        actions.push('case '+i+':' +action+'\\nbreak;');\n    }\n    actions.push(\"}\");\n\n    return newRules;\n}\n\n// expand macros within macros\nfunction prepareMacros (macros) {\n    var cont = true,\n        m,i,k,mnew;\n    while (cont) {\n        cont = false;\n        for (i in macros) if (macros.hasOwnProperty(i)) {\n            m = macros[i];\n            for (k in macros) if (macros.hasOwnProperty(k) && i !== k) {\n                mnew = m.split(\"{\"+k+\"}\").join('(' + macros[k] + ')');\n                if (mnew !== m) {\n                    cont = true;\n                    macros[i] = mnew;\n                }\n            }\n        }\n    }\n    return macros;\n}\n\nfunction prepareStartConditions (conditions) {\n    var sc,\n        hash = {};\n    for (sc in conditions) if (conditions.hasOwnProperty(sc)) {\n        hash[sc] = {rules:[],inclusive:!!!conditions[sc]};\n    }\n    return hash;\n}\n\nfunction buildActions (dict, tokens) {\n    var actions = [dict.actionInclude || '', \"var YYSTATE=YY_START;\"];\n    var tok;\n    var toks = {};\n\n    for (tok in tokens) {\n        toks[tokens[tok]] = tok;\n    }\n\n    if (dict.options && dict.options.flex) {\n        dict.rules.push([\".\", \"console.log(yytext);\"]);\n    }\n\n    this.rules = prepareRules(dict.rules, dict.macros, actions, tokens && toks, this.conditions, this.options[\"case-insensitive\"]);\n    var fun = actions.join(\"\\n\");\n    \"yytext yyleng yylineno yylloc\".split(' ').forEach(function (yy) {\n        fun = fun.replace(new RegExp(\"\\\\b(\"+yy+\")\\\\b\", \"g\"), \"yy_.$1\");\n    });\n\n\n    // first try to create the performAction function the old way,\n    // but this will break for some legal constructs in the user action code:\n    try {\n        return Function(\"yy,yy_,$avoiding_name_collisions,YY_START\", fun);\n    } catch (e) {\n        return \"function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\" + fun + \"\\n}\";\n    }\n}\n\nfunction RegExpLexer (dict, input, tokens) {\n    if (typeof dict === 'string') {\n        dict = lexParser.parse(dict);\n    }\n    dict = dict || {};\n    this.options = dict.options || {};\n\n    this.conditions = prepareStartConditions(dict.startConditions);\n    this.conditions.INITIAL = {rules:[],inclusive:true};\n\n    this.performAction = buildActions.call(this, dict, tokens);\n    this.conditionStack = ['INITIAL'];\n\n    this.moduleInclude = (dict.moduleInclude || '').trim();\n\n    this.yy = {};\n    if (input) {\n        this.setInput(input);\n    }\n}\n\nRegExpLexer.prototype = {\n    EOF: 1,\n    parseError: function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n    // resets the lexer, sets new input\n    setInput: function (input) {\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n    // consumes and returns one char from the input\n    input: function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n    // unshifts one char (or a string) into the input\n    unput: function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n    // When called from action, caches matched text and appends it on next action\n    more: function () {\n        this._more = true;\n        return this;\n    },\n\n    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n    reject: function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n    // retain first n characters of the match\n    less: function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n    // displays already matched input, i.e. for error messages\n    pastInput: function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n    // displays upcoming input, i.e. for error messages\n    upcomingInput: function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n    // displays the character position where the lexing error occurred, i.e. for error messages\n    showPosition: function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n    // test the lexed token: return FALSE when not a match, otherwise return token\n    test_match: function(match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n    // return next match in input\n    next: function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n    // return next match that has a token\n    lex: function lex () {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n    begin: function begin (condition) {\n        this.conditionStack.push(condition);\n    },\n\n    // pop the previously active lexer condition state off the condition stack\n    popState: function popState () {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n    // produce the lexer rule set which is active for the currently active lexer condition state\n    _currentRules: function _currentRules () {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n    topState: function topState (n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n    // alias for begin(condition)\n    pushState: function pushState (condition) {\n        this.begin(condition);\n    },\n\n    // return the number of states pushed\n    stateStackSize: function stateStackSize() {\n        return this.conditionStack.length;\n    },\n\n    generate:  function generate(opt) {\n        var code = \"\";\n        if (opt.moduleType === 'commonjs') {\n            code = this.generateCommonJSModule(opt);\n        } else if (opt.moduleType === 'amd') {\n            code = this.generateAMDModule(opt);\n        } else {\n            code = this.generateModule(opt);\n        }\n\n        return code;\n    },\n    generateModuleBody: function generateModule() {\n        var function_descriptions = {\n            setInput: \"resets the lexer, sets new input\",\n            input: \"consumes and returns one char from the input\",\n            unput: \"unshifts one char (or a string) into the input\",\n            more: \"When called from action, caches matched text and appends it on next action\",\n            reject: \"When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\",\n            less: \"retain first n characters of the match\",\n            pastInput: \"displays already matched input, i.e. for error messages\",\n            upcomingInput: \"displays upcoming input, i.e. for error messages\",\n            showPosition: \"displays the character position where the lexing error occurred, i.e. for error messages\",\n            test_match: \"test the lexed token: return FALSE when not a match, otherwise return token\",\n            next: \"return next match in input\",\n            lex: \"return next match that has a token\",\n            begin: \"activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\",\n            popState: \"pop the previously active lexer condition state off the condition stack\",\n            _currentRules: \"produce the lexer rule set which is active for the currently active lexer condition state\",\n            topState: \"return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\",\n            pushState: \"alias for begin(condition)\",\n            stateStackSize: \"return the number of states currently on the stack\"\n        };\n        var out = \"{\\n\";\n        var p = [];\n        var descr;\n        for (var k in RegExpLexer.prototype) {\n            if (RegExpLexer.prototype.hasOwnProperty(k) && k.indexOf(\"generate\") === -1) {\n                // copy the function description as a comment before the implementation; supports multi-line descriptions\n                descr = \"\\n\";\n                if (function_descriptions[k]) {\n                    descr += \"// \" + function_descriptions[k].replace(/\\n/g, \"\\n\\/\\/ \") + \"\\n\";\n                }\n                p.push(descr + k + \":\" + (RegExpLexer.prototype[k].toString() || '\"\"'));\n            }\n        }\n        out += p.join(\",\\n\");\n\n        if (this.options) {\n            out += \",\\noptions: \" + JSON.stringify(this.options);\n        }\n\n        out += \",\\nperformAction: \" + String(this.performAction);\n        out += \",\\nrules: [\" + this.rules + \"]\";\n        out += \",\\nconditions: \" + JSON.stringify(this.conditions);\n        out += \"\\n}\";\n\n        return out;\n    },\n    generateModule: function generateModule(opt) {\n        opt = opt || {};\n\n        var out = \"/* generated by jison-lex \" + version + \" */\";\n        var moduleName = opt.moduleName || \"lexer\";\n\n        out += \"\\nvar \" + moduleName + \" = (function(){\\nvar lexer = \"\n              + this.generateModuleBody();\n\n        if (this.moduleInclude) out += \";\\n\"+this.moduleInclude;\n        out += \";\\nreturn lexer;\\n})();\";\n        return out;\n    },\n    generateAMDModule: function generateAMDModule() {\n        var out = \"/* generated by jison-lex \" + version + \" */\";\n\n        out += \"define([], function(){\\nvar lexer = \"\n              + this.generateModuleBody();\n\n        if (this.moduleInclude) out += \";\\n\"+this.moduleInclude;\n        out += \";\\nreturn lexer;\"\n             + \"\\n})();\";\n        return out;\n    },\n    generateCommonJSModule: function generateCommonJSModule(opt) {\n        opt = opt || {};\n\n        var out = \"\";\n        var moduleName = opt.moduleName || \"lexer\";\n\n        out += this.generateModule(opt);\n        out += \"\\nexports.lexer = \"+moduleName;\n        out += \";\\nexports.lex = function () { return \"+moduleName+\".lex.apply(lexer, arguments); };\";\n        return out;\n    }\n};\n\nreturn RegExpLexer;\n\n})();\n\nmodule.exports = RegExpLexer;\n\n"]},"metadata":{},"sourceType":"script"}