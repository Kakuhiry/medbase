{"ast":null,"code":"if (typeof module === \"object\" && typeof module.exports === \"object\") module.exports = Lexer;\n\nLexer.defunct = function (char) {\n  throw new Error(\"Unexpected character at index \" + (this.index - 1) + \": \" + char);\n};\n\nfunction Lexer(defunct) {\n  if (typeof defunct !== \"function\") defunct = Lexer.defunct;\n  var tokens = [];\n  var rules = [];\n  var remove = 0;\n  this.state = 0;\n  this.index = 0;\n  this.input = \"\";\n\n  this.addRule = function (pattern, action, start) {\n    var global = pattern.global;\n\n    if (!global) {\n      var flags = \"g\";\n      if (pattern.multiline) flags += \"m\";\n      if (pattern.ignoreCase) flags += \"i\";\n      pattern = new RegExp(pattern.source, flags);\n    }\n\n    if (Object.prototype.toString.call(start) !== \"[object Array]\") start = [0];\n    rules.push({\n      pattern: pattern,\n      global: global,\n      action: action,\n      start: start\n    });\n    return this;\n  };\n\n  this.setInput = function (input) {\n    remove = 0;\n    this.state = 0;\n    this.index = 0;\n    this.input = input;\n    return this;\n  };\n\n  this.lex = function () {\n    if (tokens.length) return tokens.shift();\n    this.reject = true;\n\n    while (this.index <= this.input.length) {\n      var matches = scan.call(this).splice(remove);\n      var index = this.index;\n\n      while (matches.length) {\n        if (this.reject) {\n          var match = matches.shift();\n          var result = match.result;\n          var length = match.length;\n          this.index += length;\n          this.reject = false;\n          remove++;\n          var token = match.action.apply(this, result);\n          if (this.reject) this.index = result.index;else if (typeof token !== \"undefined\") {\n            switch (Object.prototype.toString.call(token)) {\n              case \"[object Array]\":\n                tokens = token.slice(1);\n                token = token[0];\n\n              default:\n                if (length) remove = 0;\n                return token;\n            }\n          }\n        } else break;\n      }\n\n      var input = this.input;\n\n      if (index < input.length) {\n        if (this.reject) {\n          remove = 0;\n          var token = defunct.call(this, input.charAt(this.index++));\n\n          if (typeof token !== \"undefined\") {\n            if (Object.prototype.toString.call(token) === \"[object Array]\") {\n              tokens = token.slice(1);\n              return token[0];\n            } else return token;\n          }\n        } else {\n          if (this.index !== index) remove = 0;\n          this.reject = true;\n        }\n      } else if (matches.length) this.reject = true;else break;\n    }\n  };\n\n  function scan() {\n    var matches = [];\n    var index = 0;\n    var state = this.state;\n    var lastIndex = this.index;\n    var input = this.input;\n\n    for (var i = 0, length = rules.length; i < length; i++) {\n      var rule = rules[i];\n      var start = rule.start;\n      var states = start.length;\n\n      if (!states || start.indexOf(state) >= 0 || state % 2 && states === 1 && !start[0]) {\n        var pattern = rule.pattern;\n        pattern.lastIndex = lastIndex;\n        var result = pattern.exec(input);\n\n        if (result && result.index === lastIndex) {\n          var j = matches.push({\n            result: result,\n            action: rule.action,\n            length: result[0].length\n          });\n          if (rule.global) index = j;\n\n          while (--j > index) {\n            var k = j - 1;\n\n            if (matches[j].length > matches[k].length) {\n              var temple = matches[j];\n              matches[j] = matches[k];\n              matches[k] = temple;\n            }\n          }\n        }\n      }\n    }\n\n    return matches;\n  }\n}","map":{"version":3,"sources":["/home/elvis/Documents/GitHub/medbase/mern-auth/node_modules/lex/lib/lexer.js"],"names":["module","exports","Lexer","defunct","char","Error","index","tokens","rules","remove","state","input","addRule","pattern","action","start","global","flags","multiline","ignoreCase","RegExp","source","Object","prototype","toString","call","push","setInput","lex","length","shift","reject","matches","scan","splice","match","result","token","apply","slice","charAt","lastIndex","i","rule","states","indexOf","exec","j","k","temple"],"mappings":"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","sourcesContent":["if (typeof module === \"object\" && typeof module.exports === \"object\") module.exports = Lexer;\n\nLexer.defunct = function (char) {\n    throw new Error(\"Unexpected character at index \" + (this.index - 1) + \": \" + char);\n};\n\nfunction Lexer(defunct) {\n    if (typeof defunct !== \"function\") defunct = Lexer.defunct;\n\n    var tokens = [];\n    var rules = [];\n    var remove = 0;\n    this.state = 0;\n    this.index = 0;\n    this.input = \"\";\n\n    this.addRule = function (pattern, action, start) {\n        var global = pattern.global;\n\n        if (!global) {\n            var flags = \"g\";\n            if (pattern.multiline) flags += \"m\";\n            if (pattern.ignoreCase) flags += \"i\";\n            pattern = new RegExp(pattern.source, flags);\n        }\n\n        if (Object.prototype.toString.call(start) !== \"[object Array]\") start = [0];\n\n        rules.push({\n            pattern: pattern,\n            global: global,\n            action: action,\n            start: start\n        });\n\n        return this;\n    };\n\n    this.setInput = function (input) {\n        remove = 0;\n        this.state = 0;\n        this.index = 0;\n        this.input = input;\n        return this;\n    };\n\n    this.lex = function () {\n        if (tokens.length) return tokens.shift();\n\n        this.reject = true;\n\n        while (this.index <= this.input.length) {\n            var matches = scan.call(this).splice(remove);\n            var index = this.index;\n\n            while (matches.length) {\n                if (this.reject) {\n                    var match = matches.shift();\n                    var result = match.result;\n                    var length = match.length;\n                    this.index += length;\n                    this.reject = false;\n                    remove++;\n\n                    var token = match.action.apply(this, result);\n                    if (this.reject) this.index = result.index;\n                    else if (typeof token !== \"undefined\") {\n                        switch (Object.prototype.toString.call(token)) {\n                        case \"[object Array]\":\n                            tokens = token.slice(1);\n                            token = token[0];\n                        default:\n                            if (length) remove = 0;\n                            return token;\n                        }\n                    }\n                } else break;\n            }\n\n            var input = this.input;\n\n            if (index < input.length) {\n                if (this.reject) {\n                    remove = 0;\n                    var token = defunct.call(this, input.charAt(this.index++));\n                    if (typeof token !== \"undefined\") {\n                        if (Object.prototype.toString.call(token) === \"[object Array]\") {\n                            tokens = token.slice(1);\n                            return token[0];\n                        } else return token;\n                    }\n                } else {\n                    if (this.index !== index) remove = 0;\n                    this.reject = true;\n                }\n            } else if (matches.length)\n                this.reject = true;\n            else break;\n        }\n    };\n\n    function scan() {\n        var matches = [];\n        var index = 0;\n\n        var state = this.state;\n        var lastIndex = this.index;\n        var input = this.input;\n\n        for (var i = 0, length = rules.length; i < length; i++) {\n            var rule = rules[i];\n            var start = rule.start;\n            var states = start.length;\n\n            if ((!states || start.indexOf(state) >= 0) ||\n                (state % 2 && states === 1 && !start[0])) {\n                var pattern = rule.pattern;\n                pattern.lastIndex = lastIndex;\n                var result = pattern.exec(input);\n\n                if (result && result.index === lastIndex) {\n                    var j = matches.push({\n                        result: result,\n                        action: rule.action,\n                        length: result[0].length\n                    });\n\n                    if (rule.global) index = j;\n\n                    while (--j > index) {\n                        var k = j - 1;\n\n                        if (matches[j].length > matches[k].length) {\n                            var temple = matches[j];\n                            matches[j] = matches[k];\n                            matches[k] = temple;\n                        }\n                    }\n                }\n            }\n        }\n\n        return matches;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}