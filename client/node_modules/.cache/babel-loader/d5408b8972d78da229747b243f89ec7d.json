{"ast":null,"code":"if (typeof require === \"function\") {\n  var StateMachine = require(\"statemachines\");\n\n  var parse = require(\"./parse\");\n\n  require(\"augment\");\n}\n\nvar nfa = Function.bindable(StateMachine.Nondeterministic, null);\nif (typeof module === \"object\") module.exports = Regex;\nRegex.convert = convert;\nRegex.parse = parse;\n\nfunction Regex(regexp) {\n  var graph = parse(regexp instanceof RegExp ? regexp.source : regexp);\n  var dfa = new (nfa.apply(null, convert(graph)))().subset();\n  this.test = dfa.test.bind(dfa);\n}\n\nfunction convert(graph) {\n  var states = [graph.start];\n  var transition = [];\n  var cursor = 0;\n\n  while (cursor < states.length) {\n    var state = states[cursor++];\n    var symbols = Object.keys(state);\n    var length = symbols.length;\n    var tuple = {};\n\n    for (var i = 0; i < length; i++) {\n      var symbol = symbols[i];\n      var moves = state[symbol];\n      var degree = moves.length;\n      var transitions = [];\n\n      for (var j = 0; j < degree; j++) {\n        var move = moves[j];\n        var index = states.indexOf(move);\n\n        if (index < 0) {\n          index = states.length;\n          states.push(move);\n        }\n\n        transitions.push(index);\n      }\n\n      tuple[symbol] = transitions;\n    }\n\n    transition.push(tuple);\n  }\n\n  return [transition, [states.indexOf(graph.final)]];\n}","map":{"version":3,"sources":["/home/elvis/Documents/GitHub/medbase/mern-auth/node_modules/regex/lib/regex.js"],"names":["require","StateMachine","parse","nfa","Function","bindable","Nondeterministic","module","exports","Regex","convert","regexp","graph","RegExp","source","dfa","apply","subset","test","bind","states","start","transition","cursor","length","state","symbols","Object","keys","tuple","i","symbol","moves","degree","transitions","j","move","index","indexOf","push","final"],"mappings":"AAAA,IAAI,OAAOA,OAAP,KAAmB,UAAvB,EAAmC;AAC/B,MAAIC,YAAY,GAAGD,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAIE,KAAK,GAAGF,OAAO,CAAC,SAAD,CAAnB;;AACAA,EAAAA,OAAO,CAAC,SAAD,CAAP;AACH;;AAED,IAAIG,GAAG,GAAGC,QAAQ,CAACC,QAAT,CAAkBJ,YAAY,CAACK,gBAA/B,EAAiD,IAAjD,CAAV;AACA,IAAI,OAAOC,MAAP,KAAkB,QAAtB,EAAgCA,MAAM,CAACC,OAAP,GAAiBC,KAAjB;AAChCA,KAAK,CAACC,OAAN,GAAgBA,OAAhB;AACAD,KAAK,CAACP,KAAN,GAAcA,KAAd;;AAEA,SAASO,KAAT,CAAeE,MAAf,EAAuB;AACnB,MAAIC,KAAK,GAAGV,KAAK,CAACS,MAAM,YAAYE,MAAlB,GAA2BF,MAAM,CAACG,MAAlC,GAA2CH,MAA5C,CAAjB;AACA,MAAII,GAAG,GAAI,KAAKZ,GAAG,CAACa,KAAJ,CAAU,IAAV,EAAgBN,OAAO,CAACE,KAAD,CAAvB,CAAL,GAAD,CAAwCK,MAAxC,EAAV;AACA,OAAKC,IAAL,GAAYH,GAAG,CAACG,IAAJ,CAASC,IAAT,CAAcJ,GAAd,CAAZ;AACH;;AAED,SAASL,OAAT,CAAiBE,KAAjB,EAAwB;AACpB,MAAIQ,MAAM,GAAG,CAACR,KAAK,CAACS,KAAP,CAAb;AACA,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,MAAM,GAAG,CAAb;;AAEA,SAAOA,MAAM,GAAGH,MAAM,CAACI,MAAvB,EAA+B;AAC3B,QAAIC,KAAK,GAAGL,MAAM,CAACG,MAAM,EAAP,CAAlB;AACA,QAAIG,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYH,KAAZ,CAAd;AACA,QAAID,MAAM,GAAGE,OAAO,CAACF,MAArB;AACA,QAAIK,KAAK,GAAG,EAAZ;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,MAApB,EAA4BM,CAAC,EAA7B,EAAiC;AAC7B,UAAIC,MAAM,GAAGL,OAAO,CAACI,CAAD,CAApB;AACA,UAAIE,KAAK,GAAGP,KAAK,CAACM,MAAD,CAAjB;AACA,UAAIE,MAAM,GAAGD,KAAK,CAACR,MAAnB;AACA,UAAIU,WAAW,GAAG,EAAlB;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAApB,EAA4BE,CAAC,EAA7B,EAAiC;AAC7B,YAAIC,IAAI,GAAGJ,KAAK,CAACG,CAAD,CAAhB;AACA,YAAIE,KAAK,GAAGjB,MAAM,CAACkB,OAAP,CAAeF,IAAf,CAAZ;;AAEA,YAAIC,KAAK,GAAG,CAAZ,EAAe;AACXA,UAAAA,KAAK,GAAGjB,MAAM,CAACI,MAAf;AACAJ,UAAAA,MAAM,CAACmB,IAAP,CAAYH,IAAZ;AACH;;AAEDF,QAAAA,WAAW,CAACK,IAAZ,CAAiBF,KAAjB;AACH;;AAEDR,MAAAA,KAAK,CAACE,MAAD,CAAL,GAAgBG,WAAhB;AACH;;AAEDZ,IAAAA,UAAU,CAACiB,IAAX,CAAgBV,KAAhB;AACH;;AAED,SAAO,CAACP,UAAD,EAAa,CAACF,MAAM,CAACkB,OAAP,CAAe1B,KAAK,CAAC4B,KAArB,CAAD,CAAb,CAAP;AACH","sourcesContent":["if (typeof require === \"function\") {\n    var StateMachine = require(\"statemachines\");\n    var parse = require(\"./parse\");\n    require(\"augment\");\n}\n\nvar nfa = Function.bindable(StateMachine.Nondeterministic, null);\nif (typeof module === \"object\") module.exports = Regex;\nRegex.convert = convert;\nRegex.parse = parse;\n\nfunction Regex(regexp) {\n    var graph = parse(regexp instanceof RegExp ? regexp.source : regexp);\n    var dfa = (new (nfa.apply(null, convert(graph)))).subset();\n    this.test = dfa.test.bind(dfa);\n}\n\nfunction convert(graph) {\n    var states = [graph.start];\n    var transition = [];\n    var cursor = 0;\n\n    while (cursor < states.length) {\n        var state = states[cursor++];\n        var symbols = Object.keys(state);\n        var length = symbols.length;\n        var tuple = {};\n\n        for (var i = 0; i < length; i++) {\n            var symbol = symbols[i];\n            var moves = state[symbol];\n            var degree = moves.length;\n            var transitions = [];\n\n            for (var j = 0; j < degree; j++) {\n                var move = moves[j];\n                var index = states.indexOf(move);\n\n                if (index < 0) {\n                    index = states.length;\n                    states.push(move);\n                }\n\n                transitions.push(index);\n            }\n\n            tuple[symbol] = transitions;\n        }\n\n        transition.push(tuple);\n    }\n\n    return [transition, [states.indexOf(graph.final)]];\n}\n"]},"metadata":{},"sourceType":"script"}