{"ast":null,"code":"/*! Copyright (c) 2011, Lloyd Hilaiel, ISC License */\n\n/*\n * This is the JSONSelect reference implementation, in javascript.  This\n * code is designed to run under node.js or in a browser.  In the former\n * case, the \"public API\" is exposed as properties on the `export` object,\n * in the latter, as properties on `window.JSONSelect`.  That API is thus:\n *\n * Selector formating and parameter escaping:\n *\n * Anywhere where a string selector is selected, it may be followed by an\n * optional array of values.  When provided, they will be escaped and\n * inserted into the selector string properly escaped.  i.e.:\n *\n *   .match(':has(?)', [ 'foo' ], {}) \n * \n * would result in the seclector ':has(\"foo\")' being matched against {}.\n *\n * This feature makes dynamically generated selectors more readable.\n *\n * .match(selector, [ values ], object)\n *\n *   Parses and \"compiles\" the selector, then matches it against the object\n *   argument.  Matches are returned in an array.  Throws an error when\n *   there's a problem parsing the selector.\n *\n * .forEach(selector, [ values ], object, callback)\n *\n *   Like match, but rather than returning an array, invokes the provided\n *   callback once per match as the matches are discovered. \n * \n * .compile(selector, [ values ]) \n *\n *   Parses the selector and compiles it to an internal form, and returns\n *   an object which contains the compiled selector and has two properties:\n *   `match` and `forEach`.  These two functions work identically to the\n *   above, except they do not take a selector as an argument and instead\n *   use the compiled selector.\n *\n *   For cases where a complex selector is repeatedly used, this method\n *   should be faster as it will avoid recompiling the selector each time. \n */\n(function (exports) {\n  var // localize references\n  toString = Object.prototype.toString;\n\n  function jsonParse(str) {\n    try {\n      if (JSON && JSON.parse) {\n        return JSON.parse(str);\n      }\n\n      return new Function(\"return \" + str)();\n    } catch (e) {\n      te(\"ijs\", e.message);\n    }\n  } // emitted error codes.\n\n\n  var errorCodes = {\n    \"bop\": \"binary operator expected\",\n    \"ee\": \"expression expected\",\n    \"epex\": \"closing paren expected ')'\",\n    \"ijs\": \"invalid json string\",\n    \"mcp\": \"missing closing paren\",\n    \"mepf\": \"malformed expression in pseudo-function\",\n    \"mexp\": \"multiple expressions not allowed\",\n    \"mpc\": \"multiple pseudo classes (:xxx) not allowed\",\n    \"nmi\": \"multiple ids not allowed\",\n    \"pex\": \"opening paren expected '('\",\n    \"se\": \"selector expected\",\n    \"sex\": \"string expected\",\n    \"sra\": \"string required after '.'\",\n    \"uc\": \"unrecognized char\",\n    \"ucp\": \"unexpected closing paren\",\n    \"ujs\": \"unclosed json string\",\n    \"upc\": \"unrecognized pseudo class\"\n  }; // throw an error message\n\n  function te(ec, context) {\n    throw new Error(errorCodes[ec] + (context && \" in '\" + context + \"'\"));\n  } // THE LEXER\n\n\n  var toks = {\n    psc: 1,\n    // pseudo class\n    psf: 2,\n    // pseudo class function\n    typ: 3,\n    // type\n    str: 4,\n    // string\n    ide: 5 // identifiers (or \"classes\", stuff after a dot)\n\n  }; // The primary lexing regular expression in jsonselect\n\n  var pat = new RegExp(\"^(?:\" + // (1) whitespace\n  \"([\\\\r\\\\n\\\\t\\\\ ]+)|\" + // (2) one-char ops\n  \"([~*,>\\\\)\\\\(])|\" + // (3) types names\n  \"(string|boolean|null|array|object|number)|\" + // (4) pseudo classes\n  \"(:(?:root|first-child|last-child|only-child))|\" + // (5) pseudo functions\n  \"(:(?:nth-child|nth-last-child|has|expr|val|contains))|\" + // (6) bogusly named pseudo something or others\n  \"(:\\\\w+)|\" + // (7 & 8) identifiers and JSON strings\n  \"(?:(\\\\.)?(\\\\\\\"(?:[^\\\\\\\\\\\\\\\"]|\\\\\\\\[^\\\\\\\"])*\\\\\\\"))|\" + // (8) bogus JSON strings missing a trailing quote\n  \"(\\\\\\\")|\" + // (9) identifiers (unquoted)\n  \"\\\\.((?:[_a-zA-Z]|[^\\\\0-\\\\0177]|\\\\\\\\[^\\\\r\\\\n\\\\f0-9a-fA-F])(?:[_a-zA-Z0-9\\\\-]|[^\\\\u0000-\\\\u0177]|(?:\\\\\\\\[^\\\\r\\\\n\\\\f0-9a-fA-F]))*)\" + \")\"); // A regular expression for matching \"nth expressions\" (see grammar, what :nth-child() eats)\n\n  var nthPat = /^\\s*\\(\\s*(?:([+\\-]?)([0-9]*)n\\s*(?:([+\\-])\\s*([0-9]))?|(odd|even)|([+\\-]?[0-9]+))\\s*\\)/;\n\n  function lex(str, off) {\n    if (!off) off = 0;\n    var m = pat.exec(str.substr(off));\n    if (!m) return undefined;\n    off += m[0].length;\n    var a;\n    if (m[1]) a = [off, \" \"];else if (m[2]) a = [off, m[0]];else if (m[3]) a = [off, toks.typ, m[0]];else if (m[4]) a = [off, toks.psc, m[0]];else if (m[5]) a = [off, toks.psf, m[0]];else if (m[6]) te(\"upc\", str);else if (m[8]) a = [off, m[7] ? toks.ide : toks.str, jsonParse(m[8])];else if (m[9]) te(\"ujs\", str);else if (m[10]) a = [off, toks.ide, m[10].replace(/\\\\([^\\r\\n\\f0-9a-fA-F])/g, \"$1\")];\n    return a;\n  } // THE EXPRESSION SUBSYSTEM\n\n\n  var exprPat = new RegExp( // skip and don't capture leading whitespace\n  \"^\\\\s*(?:\" + // (1) simple vals\n  \"(true|false|null)|\" + // (2) numbers\n  \"(-?\\\\d+(?:\\\\.\\\\d*)?(?:[eE][+\\\\-]?\\\\d+)?)|\" + // (3) strings\n  \"(\\\"(?:[^\\\\]|\\\\[^\\\"])*\\\")|\" + // (4) the 'x' value placeholder\n  \"(x)|\" + // (5) binops\n  \"(&&|\\\\|\\\\||[\\\\$\\\\^<>!\\\\*]=|[=+\\\\-*/%<>])|\" + // (6) parens\n  \"([\\\\(\\\\)])\" + \")\");\n\n  function is(o, t) {\n    return typeof o === t;\n  }\n\n  var operators = {\n    '*': [9, function (lhs, rhs) {\n      return lhs * rhs;\n    }],\n    '/': [9, function (lhs, rhs) {\n      return lhs / rhs;\n    }],\n    '%': [9, function (lhs, rhs) {\n      return lhs % rhs;\n    }],\n    '+': [7, function (lhs, rhs) {\n      return lhs + rhs;\n    }],\n    '-': [7, function (lhs, rhs) {\n      return lhs - rhs;\n    }],\n    '<=': [5, function (lhs, rhs) {\n      return is(lhs, 'number') && is(rhs, 'number') && lhs <= rhs;\n    }],\n    '>=': [5, function (lhs, rhs) {\n      return is(lhs, 'number') && is(rhs, 'number') && lhs >= rhs;\n    }],\n    '$=': [5, function (lhs, rhs) {\n      return is(lhs, 'string') && is(rhs, 'string') && lhs.lastIndexOf(rhs) === lhs.length - rhs.length;\n    }],\n    '^=': [5, function (lhs, rhs) {\n      return is(lhs, 'string') && is(rhs, 'string') && lhs.indexOf(rhs) === 0;\n    }],\n    '*=': [5, function (lhs, rhs) {\n      return is(lhs, 'string') && is(rhs, 'string') && lhs.indexOf(rhs) !== -1;\n    }],\n    '>': [5, function (lhs, rhs) {\n      return is(lhs, 'number') && is(rhs, 'number') && lhs > rhs;\n    }],\n    '<': [5, function (lhs, rhs) {\n      return is(lhs, 'number') && is(rhs, 'number') && lhs < rhs;\n    }],\n    '=': [3, function (lhs, rhs) {\n      return lhs === rhs;\n    }],\n    '!=': [3, function (lhs, rhs) {\n      return lhs !== rhs;\n    }],\n    '&&': [2, function (lhs, rhs) {\n      return lhs && rhs;\n    }],\n    '||': [1, function (lhs, rhs) {\n      return lhs || rhs;\n    }]\n  };\n\n  function exprLex(str, off) {\n    var v,\n        m = exprPat.exec(str.substr(off));\n\n    if (m) {\n      off += m[0].length;\n      v = m[1] || m[2] || m[3] || m[5] || m[6];\n      if (m[1] || m[2] || m[3]) return [off, 0, jsonParse(v)];else if (m[4]) return [off, 0, undefined];\n      return [off, v];\n    }\n  }\n\n  function exprParse2(str, off) {\n    if (!off) off = 0; // first we expect a value or a '('\n\n    var l = exprLex(str, off),\n        lhs;\n\n    if (l && l[1] === '(') {\n      lhs = exprParse2(str, l[0]);\n      var p = exprLex(str, lhs[0]);\n      if (!p || p[1] !== ')') te('epex', str);\n      off = p[0];\n      lhs = ['(', lhs[1]];\n    } else if (!l || l[1] && l[1] != 'x') {\n      te(\"ee\", str + \" - \" + (l[1] && l[1]));\n    } else {\n      lhs = l[1] === 'x' ? undefined : l[2];\n      off = l[0];\n    } // now we expect a binary operator or a ')'\n\n\n    var op = exprLex(str, off);\n    if (!op || op[1] == ')') return [off, lhs];else if (op[1] == 'x' || !op[1]) {\n      te('bop', str + \" - \" + (op[1] && op[1]));\n    } // tail recursion to fetch the rhs expression\n\n    var rhs = exprParse2(str, op[0]);\n    off = rhs[0];\n    rhs = rhs[1]; // and now precedence!  how shall we put everything together?\n\n    var v;\n\n    if (typeof rhs !== 'object' || rhs[0] === '(' || operators[op[1]][0] < operators[rhs[1]][0]) {\n      v = [lhs, op[1], rhs];\n    } else {\n      v = rhs;\n\n      while (typeof rhs[0] === 'object' && rhs[0][0] != '(' && operators[op[1]][0] >= operators[rhs[0][1]][0]) {\n        rhs = rhs[0];\n      }\n\n      rhs[0] = [lhs, op[1], rhs[0]];\n    }\n\n    return [off, v];\n  }\n\n  function exprParse(str, off) {\n    function deparen(v) {\n      if (typeof v !== 'object' || v === null) return v;else if (v[0] === '(') return deparen(v[1]);else return [deparen(v[0]), v[1], deparen(v[2])];\n    }\n\n    var e = exprParse2(str, off ? off : 0);\n    return [e[0], deparen(e[1])];\n  }\n\n  function exprEval(expr, x) {\n    if (expr === undefined) return x;else if (expr === null || typeof expr !== 'object') {\n      return expr;\n    }\n    var lhs = exprEval(expr[0], x),\n        rhs = exprEval(expr[2], x);\n    return operators[expr[1]][1](lhs, rhs);\n  } // THE PARSER\n\n\n  function parse(str, off, nested, hints) {\n    if (!nested) hints = {};\n    var a = [],\n        am,\n        readParen;\n    if (!off) off = 0;\n\n    while (true) {\n      var s = parse_selector(str, off, hints);\n      a.push(s[1]);\n      s = lex(str, off = s[0]);\n      if (s && s[1] === \" \") s = lex(str, off = s[0]);\n      if (!s) break; // now we've parsed a selector, and have something else...\n\n      if (s[1] === \">\" || s[1] === \"~\") {\n        if (s[1] === \"~\") hints.usesSiblingOp = true;\n        a.push(s[1]);\n        off = s[0];\n      } else if (s[1] === \",\") {\n        if (am === undefined) am = [\",\", a];else am.push(a);\n        a = [];\n        off = s[0];\n      } else if (s[1] === \")\") {\n        if (!nested) te(\"ucp\", s[1]);\n        readParen = 1;\n        off = s[0];\n        break;\n      }\n    }\n\n    if (nested && !readParen) te(\"mcp\", str);\n    if (am) am.push(a);\n    var rv;\n\n    if (!nested && hints.usesSiblingOp) {\n      rv = normalize(am ? am : a);\n    } else {\n      rv = am ? am : a;\n    }\n\n    return [off, rv];\n  }\n\n  function normalizeOne(sel) {\n    var sels = [],\n        s;\n\n    for (var i = 0; i < sel.length; i++) {\n      if (sel[i] === '~') {\n        // `A ~ B` maps to `:has(:root > A) > B`\n        // `Z A ~ B` maps to `Z :has(:root > A) > B, Z:has(:root > A) > B`\n        // This first clause, takes care of the first case, and the first half of the latter case.\n        if (i < 2 || sel[i - 2] != '>') {\n          s = sel.slice(0, i - 1);\n          s = s.concat([{\n            has: [[{\n              pc: \":root\"\n            }, \">\", sel[i - 1]]]\n          }, \">\"]);\n          s = s.concat(sel.slice(i + 1));\n          sels.push(s);\n        } // here we take care of the second half of above:\n        // (`Z A ~ B` maps to `Z :has(:root > A) > B, Z :has(:root > A) > B`)\n        // and a new case:\n        // Z > A ~ B maps to Z:has(:root > A) > B\n\n\n        if (i > 1) {\n          var at = sel[i - 2] === '>' ? i - 3 : i - 2;\n          s = sel.slice(0, at);\n          var z = {};\n\n          for (var k in sel[at]) if (sel[at].hasOwnProperty(k)) z[k] = sel[at][k];\n\n          if (!z.has) z.has = [];\n          z.has.push([{\n            pc: \":root\"\n          }, \">\", sel[i - 1]]);\n          s = s.concat(z, '>', sel.slice(i + 1));\n          sels.push(s);\n        }\n\n        break;\n      }\n    }\n\n    if (i == sel.length) return sel;\n    return sels.length > 1 ? [','].concat(sels) : sels[0];\n  }\n\n  function normalize(sels) {\n    if (sels[0] === ',') {\n      var r = [\",\"];\n\n      for (var i = i; i < sels.length; i++) {\n        var s = normalizeOne(s[i]);\n        r = r.concat(s[0] === \",\" ? s.slice(1) : s);\n      }\n\n      return r;\n    } else {\n      return normalizeOne(sels);\n    }\n  }\n\n  function parse_selector(str, off, hints) {\n    var soff = off;\n    var s = {};\n    var l = lex(str, off); // skip space\n\n    if (l && l[1] === \" \") {\n      soff = off = l[0];\n      l = lex(str, off);\n    }\n\n    if (l && l[1] === toks.typ) {\n      s.type = l[2];\n      l = lex(str, off = l[0]);\n    } else if (l && l[1] === \"*\") {\n      // don't bother representing the universal sel, '*' in the\n      // parse tree, cause it's the default\n      l = lex(str, off = l[0]);\n    } // now support either an id or a pc\n\n\n    while (true) {\n      if (l === undefined) {\n        break;\n      } else if (l[1] === toks.ide) {\n        if (s.id) te(\"nmi\", l[1]);\n        s.id = l[2];\n      } else if (l[1] === toks.psc) {\n        if (s.pc || s.pf) te(\"mpc\", l[1]); // collapse first-child and last-child into nth-child expressions\n\n        if (l[2] === \":first-child\") {\n          s.pf = \":nth-child\";\n          s.a = 0;\n          s.b = 1;\n        } else if (l[2] === \":last-child\") {\n          s.pf = \":nth-last-child\";\n          s.a = 0;\n          s.b = 1;\n        } else {\n          s.pc = l[2];\n        }\n      } else if (l[1] === toks.psf) {\n        if (l[2] === \":val\" || l[2] === \":contains\") {\n          s.expr = [undefined, l[2] === \":val\" ? \"=\" : \"*=\", undefined]; // any amount of whitespace, followed by paren, string, paren\n\n          l = lex(str, off = l[0]);\n          if (l && l[1] === \" \") l = lex(str, off = l[0]);\n          if (!l || l[1] !== \"(\") te(\"pex\", str);\n          l = lex(str, off = l[0]);\n          if (l && l[1] === \" \") l = lex(str, off = l[0]);\n          if (!l || l[1] !== toks.str) te(\"sex\", str);\n          s.expr[2] = l[2];\n          l = lex(str, off = l[0]);\n          if (l && l[1] === \" \") l = lex(str, off = l[0]);\n          if (!l || l[1] !== \")\") te(\"epex\", str);\n        } else if (l[2] === \":has\") {\n          // any amount of whitespace, followed by paren\n          l = lex(str, off = l[0]);\n          if (l && l[1] === \" \") l = lex(str, off = l[0]);\n          if (!l || l[1] !== \"(\") te(\"pex\", str);\n          var h = parse(str, l[0], true);\n          l[0] = h[0];\n          if (!s.has) s.has = [];\n          s.has.push(h[1]);\n        } else if (l[2] === \":expr\") {\n          if (s.expr) te(\"mexp\", str);\n          var e = exprParse(str, l[0]);\n          l[0] = e[0];\n          s.expr = e[1];\n        } else {\n          if (s.pc || s.pf) te(\"mpc\", str);\n          s.pf = l[2];\n          var m = nthPat.exec(str.substr(l[0]));\n          if (!m) te(\"mepf\", str);\n\n          if (m[5]) {\n            s.a = 2;\n            s.b = m[5] === \"odd\" ? 1 : 0;\n          } else if (m[6]) {\n            s.a = 0;\n            s.b = parseInt(m[6], 10);\n          } else {\n            s.a = parseInt((m[1] ? m[1] : \"+\") + (m[2] ? m[2] : \"1\"), 10);\n            s.b = m[3] ? parseInt(m[3] + m[4], 10) : 0;\n          }\n\n          l[0] += m[0].length;\n        }\n      } else {\n        break;\n      }\n\n      l = lex(str, off = l[0]);\n    } // now if we didn't actually parse anything it's an error\n\n\n    if (soff === off) te(\"se\", str);\n    return [off, s];\n  } // THE EVALUATOR\n\n\n  function isArray(o) {\n    return Array.isArray ? Array.isArray(o) : toString.call(o) === \"[object Array]\";\n  }\n\n  function mytypeof(o) {\n    if (o === null) return \"null\";\n    var to = typeof o;\n    if (to === \"object\" && isArray(o)) to = \"array\";\n    return to;\n  }\n\n  function mn(node, sel, id, num, tot) {\n    var sels = [];\n    var cs = sel[0] === \">\" ? sel[1] : sel[0];\n    var m = true,\n        mod;\n    if (cs.type) m = m && cs.type === mytypeof(node);\n    if (cs.id) m = m && cs.id === id;\n\n    if (m && cs.pf) {\n      if (cs.pf === \":nth-last-child\") num = tot - num;else num++;\n\n      if (cs.a === 0) {\n        m = cs.b === num;\n      } else {\n        mod = (num - cs.b) % cs.a;\n        m = !mod && num * cs.a + cs.b >= 0;\n      }\n    }\n\n    if (m && cs.has) {\n      // perhaps we should augment forEach to handle a return value\n      // that indicates \"client cancels traversal\"?\n      var bail = function () {\n        throw 42;\n      };\n\n      for (var i = 0; i < cs.has.length; i++) {\n        try {\n          forEach(cs.has[i], node, bail);\n        } catch (e) {\n          if (e === 42) continue;\n        }\n\n        m = false;\n        break;\n      }\n    }\n\n    if (m && cs.expr) {\n      m = exprEval(cs.expr, node);\n    } // should we repeat this selector for descendants?\n\n\n    if (sel[0] !== \">\" && sel[0].pc !== \":root\") sels.push(sel);\n\n    if (m) {\n      // is there a fragment that we should pass down?\n      if (sel[0] === \">\") {\n        if (sel.length > 2) {\n          m = false;\n          sels.push(sel.slice(2));\n        }\n      } else if (sel.length > 1) {\n        m = false;\n        sels.push(sel.slice(1));\n      }\n    }\n\n    return [m, sels];\n  }\n\n  function forEach(sel, obj, fun, id, num, tot) {\n    var a = sel[0] === \",\" ? sel.slice(1) : [sel],\n        a0 = [],\n        call = false,\n        i = 0,\n        j = 0,\n        k,\n        x;\n\n    for (i = 0; i < a.length; i++) {\n      x = mn(obj, a[i], id, num, tot);\n\n      if (x[0]) {\n        call = true;\n      }\n\n      for (j = 0; j < x[1].length; j++) {\n        a0.push(x[1][j]);\n      }\n    }\n\n    if (a0.length && typeof obj === \"object\") {\n      if (a0.length >= 1) {\n        a0.unshift(\",\");\n      }\n\n      if (isArray(obj)) {\n        for (i = 0; i < obj.length; i++) {\n          forEach(a0, obj[i], fun, undefined, i, obj.length);\n        }\n      } else {\n        for (k in obj) {\n          if (obj.hasOwnProperty(k)) {\n            forEach(a0, obj[k], fun, k);\n          }\n        }\n      }\n    }\n\n    if (call && fun) {\n      fun(obj);\n    }\n  }\n\n  function match(sel, obj) {\n    var a = [];\n    forEach(sel, obj, function (x) {\n      a.push(x);\n    });\n    return a;\n  }\n\n  function format(sel, arr) {\n    sel = sel.replace(/\\?/g, function () {\n      if (arr.length === 0) throw \"too few parameters given\";\n      var p = arr.shift();\n      return typeof p === 'string' ? JSON.stringify(p) : p;\n    });\n    if (arr.length) throw \"too many parameters supplied\";\n    return sel;\n  }\n\n  function compile(sel, arr) {\n    if (arr) sel = format(sel, arr);\n    return {\n      sel: parse(sel)[1],\n      match: function (obj) {\n        return match(this.sel, obj);\n      },\n      forEach: function (obj, fun) {\n        return forEach(this.sel, obj, fun);\n      }\n    };\n  }\n\n  exports._lex = lex;\n  exports._parse = parse;\n\n  exports.match = function (sel, arr, obj) {\n    if (!obj) {\n      obj = arr;\n      arr = undefined;\n    }\n\n    return compile(sel, arr).match(obj);\n  };\n\n  exports.forEach = function (sel, arr, obj, fun) {\n    if (!fun) {\n      fun = obj;\n      obj = arr;\n      arr = undefined;\n    }\n\n    return compile(sel, arr).forEach(obj, fun);\n  };\n\n  exports.compile = compile;\n})(typeof exports === \"undefined\" ? window.JSONSelect = {} : exports);","map":{"version":3,"sources":["/home/elvis/Documents/GitHub/medbase/mern-auth/node_modules/JSONSelect/src/jsonselect.js"],"names":["exports","toString","Object","prototype","jsonParse","str","JSON","parse","Function","e","te","message","errorCodes","ec","context","Error","toks","psc","psf","typ","ide","pat","RegExp","nthPat","lex","off","m","exec","substr","undefined","length","a","replace","exprPat","is","o","t","operators","lhs","rhs","lastIndexOf","indexOf","exprLex","v","exprParse2","l","p","op","exprParse","deparen","exprEval","expr","x","nested","hints","am","readParen","s","parse_selector","push","usesSiblingOp","rv","normalize","normalizeOne","sel","sels","i","slice","concat","has","pc","at","z","k","hasOwnProperty","r","soff","type","id","pf","b","h","parseInt","isArray","Array","call","mytypeof","to","mn","node","num","tot","cs","mod","bail","forEach","obj","fun","a0","j","unshift","match","format","arr","shift","stringify","compile","_lex","_parse","window","JSONSelect"],"mappings":"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","sourcesContent":["/*! Copyright (c) 2011, Lloyd Hilaiel, ISC License */\n/*\n * This is the JSONSelect reference implementation, in javascript.  This\n * code is designed to run under node.js or in a browser.  In the former\n * case, the \"public API\" is exposed as properties on the `export` object,\n * in the latter, as properties on `window.JSONSelect`.  That API is thus:\n *\n * Selector formating and parameter escaping:\n *\n * Anywhere where a string selector is selected, it may be followed by an\n * optional array of values.  When provided, they will be escaped and\n * inserted into the selector string properly escaped.  i.e.:\n *\n *   .match(':has(?)', [ 'foo' ], {}) \n * \n * would result in the seclector ':has(\"foo\")' being matched against {}.\n *\n * This feature makes dynamically generated selectors more readable.\n *\n * .match(selector, [ values ], object)\n *\n *   Parses and \"compiles\" the selector, then matches it against the object\n *   argument.  Matches are returned in an array.  Throws an error when\n *   there's a problem parsing the selector.\n *\n * .forEach(selector, [ values ], object, callback)\n *\n *   Like match, but rather than returning an array, invokes the provided\n *   callback once per match as the matches are discovered. \n * \n * .compile(selector, [ values ]) \n *\n *   Parses the selector and compiles it to an internal form, and returns\n *   an object which contains the compiled selector and has two properties:\n *   `match` and `forEach`.  These two functions work identically to the\n *   above, except they do not take a selector as an argument and instead\n *   use the compiled selector.\n *\n *   For cases where a complex selector is repeatedly used, this method\n *   should be faster as it will avoid recompiling the selector each time. \n */\n(function(exports) {\n\n    var // localize references\n    toString = Object.prototype.toString;\n\n    function jsonParse(str) {\n      try {\n          if(JSON && JSON.parse){\n              return JSON.parse(str);\n          }\n          return (new Function(\"return \" + str))();\n      } catch(e) {\n        te(\"ijs\", e.message);\n      }\n    }\n\n    // emitted error codes.\n    var errorCodes = {\n        \"bop\":  \"binary operator expected\",\n        \"ee\":   \"expression expected\",\n        \"epex\": \"closing paren expected ')'\",\n        \"ijs\":  \"invalid json string\",\n        \"mcp\":  \"missing closing paren\",\n        \"mepf\": \"malformed expression in pseudo-function\",\n        \"mexp\": \"multiple expressions not allowed\",\n        \"mpc\":  \"multiple pseudo classes (:xxx) not allowed\",\n        \"nmi\":  \"multiple ids not allowed\",\n        \"pex\":  \"opening paren expected '('\",\n        \"se\":   \"selector expected\",\n        \"sex\":  \"string expected\",\n        \"sra\":  \"string required after '.'\",\n        \"uc\":   \"unrecognized char\",\n        \"ucp\":  \"unexpected closing paren\",\n        \"ujs\":  \"unclosed json string\",\n        \"upc\":  \"unrecognized pseudo class\"\n    };\n\n    // throw an error message\n    function te(ec, context) {\n      throw new Error(errorCodes[ec] + ( context && \" in '\" + context + \"'\"));\n    }\n\n    // THE LEXER\n    var toks = {\n        psc: 1, // pseudo class\n        psf: 2, // pseudo class function\n        typ: 3, // type\n        str: 4, // string\n        ide: 5  // identifiers (or \"classes\", stuff after a dot)\n    };\n\n    // The primary lexing regular expression in jsonselect\n    var pat = new RegExp(\n        \"^(?:\" +\n        // (1) whitespace\n        \"([\\\\r\\\\n\\\\t\\\\ ]+)|\" +\n        // (2) one-char ops\n        \"([~*,>\\\\)\\\\(])|\" +\n        // (3) types names\n        \"(string|boolean|null|array|object|number)|\" +\n        // (4) pseudo classes\n        \"(:(?:root|first-child|last-child|only-child))|\" +\n        // (5) pseudo functions\n        \"(:(?:nth-child|nth-last-child|has|expr|val|contains))|\" +\n        // (6) bogusly named pseudo something or others\n        \"(:\\\\w+)|\" +\n        // (7 & 8) identifiers and JSON strings\n        \"(?:(\\\\.)?(\\\\\\\"(?:[^\\\\\\\\\\\\\\\"]|\\\\\\\\[^\\\\\\\"])*\\\\\\\"))|\" +\n        // (8) bogus JSON strings missing a trailing quote\n        \"(\\\\\\\")|\" +\n        // (9) identifiers (unquoted)\n        \"\\\\.((?:[_a-zA-Z]|[^\\\\0-\\\\0177]|\\\\\\\\[^\\\\r\\\\n\\\\f0-9a-fA-F])(?:[_a-zA-Z0-9\\\\-]|[^\\\\u0000-\\\\u0177]|(?:\\\\\\\\[^\\\\r\\\\n\\\\f0-9a-fA-F]))*)\" +\n        \")\"\n    );\n\n    // A regular expression for matching \"nth expressions\" (see grammar, what :nth-child() eats)\n    var nthPat = /^\\s*\\(\\s*(?:([+\\-]?)([0-9]*)n\\s*(?:([+\\-])\\s*([0-9]))?|(odd|even)|([+\\-]?[0-9]+))\\s*\\)/;\n    function lex(str, off) {\n        if (!off) off = 0;\n        var m = pat.exec(str.substr(off));\n        if (!m) return undefined;\n        off+=m[0].length;\n        var a;\n        if (m[1]) a = [off, \" \"];\n        else if (m[2]) a = [off, m[0]];\n        else if (m[3]) a = [off, toks.typ, m[0]];\n        else if (m[4]) a = [off, toks.psc, m[0]];\n        else if (m[5]) a = [off, toks.psf, m[0]];\n        else if (m[6]) te(\"upc\", str);\n        else if (m[8]) a = [off, m[7] ? toks.ide : toks.str, jsonParse(m[8])];\n        else if (m[9]) te(\"ujs\", str);\n        else if (m[10]) a = [off, toks.ide, m[10].replace(/\\\\([^\\r\\n\\f0-9a-fA-F])/g,\"$1\")];\n        return a;\n    }\n\n    // THE EXPRESSION SUBSYSTEM\n\n    var exprPat = new RegExp(\n            // skip and don't capture leading whitespace\n            \"^\\\\s*(?:\" +\n            // (1) simple vals\n            \"(true|false|null)|\" + \n            // (2) numbers\n            \"(-?\\\\d+(?:\\\\.\\\\d*)?(?:[eE][+\\\\-]?\\\\d+)?)|\" +\n            // (3) strings\n            \"(\\\"(?:[^\\\\]|\\\\[^\\\"])*\\\")|\" +\n            // (4) the 'x' value placeholder\n            \"(x)|\" +\n            // (5) binops\n            \"(&&|\\\\|\\\\||[\\\\$\\\\^<>!\\\\*]=|[=+\\\\-*/%<>])|\" +\n            // (6) parens\n            \"([\\\\(\\\\)])\" +\n            \")\"\n    );\n\n    function is(o, t) { return typeof o === t; }\n    var operators = {\n        '*':  [ 9, function(lhs, rhs) { return lhs * rhs; } ],\n        '/':  [ 9, function(lhs, rhs) { return lhs / rhs; } ],\n        '%':  [ 9, function(lhs, rhs) { return lhs % rhs; } ],\n        '+':  [ 7, function(lhs, rhs) { return lhs + rhs; } ],\n        '-':  [ 7, function(lhs, rhs) { return lhs - rhs; } ],\n        '<=': [ 5, function(lhs, rhs) { return is(lhs, 'number') && is(rhs, 'number') && lhs <= rhs; } ],\n        '>=': [ 5, function(lhs, rhs) { return is(lhs, 'number') && is(rhs, 'number') && lhs >= rhs; } ],\n        '$=': [ 5, function(lhs, rhs) { return is(lhs, 'string') && is(rhs, 'string') && lhs.lastIndexOf(rhs) === lhs.length - rhs.length; } ],\n        '^=': [ 5, function(lhs, rhs) { return is(lhs, 'string') && is(rhs, 'string') && lhs.indexOf(rhs) === 0; } ],\n        '*=': [ 5, function(lhs, rhs) { return is(lhs, 'string') && is(rhs, 'string') && lhs.indexOf(rhs) !== -1; } ],\n        '>':  [ 5, function(lhs, rhs) { return is(lhs, 'number') && is(rhs, 'number') && lhs > rhs; } ],\n        '<':  [ 5, function(lhs, rhs) { return is(lhs, 'number') && is(rhs, 'number') && lhs < rhs; } ],\n        '=':  [ 3, function(lhs, rhs) { return lhs === rhs; } ],\n        '!=': [ 3, function(lhs, rhs) { return lhs !== rhs; } ],\n        '&&': [ 2, function(lhs, rhs) { return lhs && rhs; } ],\n        '||': [ 1, function(lhs, rhs) { return lhs || rhs; } ]\n    };\n\n    function exprLex(str, off) {\n        var v, m = exprPat.exec(str.substr(off));\n        if (m) {\n            off += m[0].length;\n            v = m[1] || m[2] || m[3] || m[5] || m[6];\n            if (m[1] || m[2] || m[3]) return [off, 0, jsonParse(v)];\n            else if (m[4]) return [off, 0, undefined];\n            return [off, v];\n        }\n    }\n\n    function exprParse2(str, off) {\n        if (!off) off = 0;\n        // first we expect a value or a '('\n        var l = exprLex(str, off),\n            lhs;\n        if (l && l[1] === '(') {\n            lhs = exprParse2(str, l[0]);\n            var p = exprLex(str, lhs[0]);\n            if (!p || p[1] !== ')') te('epex', str);\n            off = p[0];\n            lhs = [ '(', lhs[1] ];\n        } else if (!l || (l[1] && l[1] != 'x')) {\n            te(\"ee\", str + \" - \" + ( l[1] && l[1] ));\n        } else {\n            lhs = ((l[1] === 'x') ? undefined : l[2]);\n            off = l[0];\n        }\n\n        // now we expect a binary operator or a ')'\n        var op = exprLex(str, off);\n        if (!op || op[1] == ')') return [off, lhs];\n        else if (op[1] == 'x' || !op[1]) {\n            te('bop', str + \" - \" + ( op[1] && op[1] ));\n        }\n\n        // tail recursion to fetch the rhs expression\n        var rhs = exprParse2(str, op[0]);\n        off = rhs[0];\n        rhs = rhs[1];\n\n        // and now precedence!  how shall we put everything together?\n        var v;\n        if (typeof rhs !== 'object' || rhs[0] === '(' || operators[op[1]][0] < operators[rhs[1]][0] ) {\n            v = [lhs, op[1], rhs];\n        }\n        else {\n            v = rhs;\n            while (typeof rhs[0] === 'object' && rhs[0][0] != '(' && operators[op[1]][0] >= operators[rhs[0][1]][0]) {\n                rhs = rhs[0];\n            }\n            rhs[0] = [lhs, op[1], rhs[0]];\n        }\n        return [off, v];\n    }\n\n    function exprParse(str, off) {\n        function deparen(v) {\n            if (typeof v !== 'object' || v === null) return v;\n            else if (v[0] === '(') return deparen(v[1]);\n            else return [deparen(v[0]), v[1], deparen(v[2])];\n        }\n        var e = exprParse2(str, off ? off : 0);\n        return [e[0], deparen(e[1])];\n    }\n\n    function exprEval(expr, x) {\n        if (expr === undefined) return x;\n        else if (expr === null || typeof expr !== 'object') {\n            return expr;\n        }\n        var lhs = exprEval(expr[0], x),\n            rhs = exprEval(expr[2], x);\n        return operators[expr[1]][1](lhs, rhs);\n    }\n\n    // THE PARSER\n\n    function parse(str, off, nested, hints) {\n        if (!nested) hints = {};\n\n        var a = [], am, readParen;\n        if (!off) off = 0; \n\n        while (true) {\n            var s = parse_selector(str, off, hints);\n            a.push(s[1]);\n            s = lex(str, off = s[0]);\n            if (s && s[1] === \" \") s = lex(str, off = s[0]);\n            if (!s) break;\n            // now we've parsed a selector, and have something else...\n            if (s[1] === \">\" || s[1] === \"~\") {\n                if (s[1] === \"~\") hints.usesSiblingOp = true;\n                a.push(s[1]);\n                off = s[0];\n            } else if (s[1] === \",\") {\n                if (am === undefined) am = [ \",\", a ];\n                else am.push(a);\n                a = [];\n                off = s[0];\n            } else if (s[1] === \")\") {\n                if (!nested) te(\"ucp\", s[1]);\n                readParen = 1;\n                off = s[0];\n                break;\n            }\n        }\n        if (nested && !readParen) te(\"mcp\", str);\n        if (am) am.push(a);\n        var rv;\n        if (!nested && hints.usesSiblingOp) {\n            rv = normalize(am ? am : a);\n        } else {\n            rv = am ? am : a;\n        }\n        return [off, rv];\n    }\n\n    function normalizeOne(sel) {\n        var sels = [], s;\n        for (var i = 0; i < sel.length; i++) {\n            if (sel[i] === '~') {\n                // `A ~ B` maps to `:has(:root > A) > B`\n                // `Z A ~ B` maps to `Z :has(:root > A) > B, Z:has(:root > A) > B`\n                // This first clause, takes care of the first case, and the first half of the latter case.\n                if (i < 2 || sel[i-2] != '>') {\n                    s = sel.slice(0,i-1);\n                    s = s.concat([{has:[[{pc: \":root\"}, \">\", sel[i-1]]]}, \">\"]);\n                    s = s.concat(sel.slice(i+1));\n                    sels.push(s);\n                }\n                // here we take care of the second half of above:\n                // (`Z A ~ B` maps to `Z :has(:root > A) > B, Z :has(:root > A) > B`)\n                // and a new case:\n                // Z > A ~ B maps to Z:has(:root > A) > B\n                if (i > 1) {\n                    var at = sel[i-2] === '>' ? i-3 : i-2;\n                    s = sel.slice(0,at);\n                    var z = {};\n                    for (var k in sel[at]) if (sel[at].hasOwnProperty(k)) z[k] = sel[at][k];\n                    if (!z.has) z.has = [];\n                    z.has.push([{pc: \":root\"}, \">\", sel[i-1]]);\n                    s = s.concat(z, '>', sel.slice(i+1));\n                    sels.push(s);\n                }\n                break;\n            }\n        }\n        if (i == sel.length) return sel;\n        return sels.length > 1 ? [','].concat(sels) : sels[0];\n    }\n\n    function normalize(sels) {\n        if (sels[0] === ',') {\n            var r = [\",\"];\n            for (var i = i; i < sels.length; i++) {\n                var s = normalizeOne(s[i]);\n                r = r.concat(s[0] === \",\" ? s.slice(1) : s);\n            }\n            return r;\n        } else {\n            return normalizeOne(sels);\n        }\n    }\n\n    function parse_selector(str, off, hints) {\n        var soff = off;\n        var s = { };\n        var l = lex(str, off);\n        // skip space\n        if (l && l[1] === \" \") { soff = off = l[0]; l = lex(str, off); }\n        if (l && l[1] === toks.typ) {\n            s.type = l[2];\n            l = lex(str, (off = l[0]));\n        } else if (l && l[1] === \"*\") {\n            // don't bother representing the universal sel, '*' in the\n            // parse tree, cause it's the default\n            l = lex(str, (off = l[0]));\n        }\n\n        // now support either an id or a pc\n        while (true) {\n            if (l === undefined) {\n                break;\n            } else if (l[1] === toks.ide) {\n                if (s.id) te(\"nmi\", l[1]);\n                s.id = l[2];\n            } else if (l[1] === toks.psc) {\n                if (s.pc || s.pf) te(\"mpc\", l[1]);\n                // collapse first-child and last-child into nth-child expressions\n                if (l[2] === \":first-child\") {\n                    s.pf = \":nth-child\";\n                    s.a = 0;\n                    s.b = 1;\n                } else if (l[2] === \":last-child\") {\n                    s.pf = \":nth-last-child\";\n                    s.a = 0;\n                    s.b = 1;\n                } else {\n                    s.pc = l[2];\n                }\n            } else if (l[1] === toks.psf) {\n                if (l[2] === \":val\" || l[2] === \":contains\") {\n                    s.expr = [ undefined, l[2] === \":val\" ? \"=\" : \"*=\", undefined];\n                    // any amount of whitespace, followed by paren, string, paren\n                    l = lex(str, (off = l[0]));\n                    if (l && l[1] === \" \") l = lex(str, off = l[0]);\n                    if (!l || l[1] !== \"(\") te(\"pex\", str);\n                    l = lex(str, (off = l[0]));\n                    if (l && l[1] === \" \") l = lex(str, off = l[0]);\n                    if (!l || l[1] !== toks.str) te(\"sex\", str);\n                    s.expr[2] = l[2];\n                    l = lex(str, (off = l[0]));\n                    if (l && l[1] === \" \") l = lex(str, off = l[0]);\n                    if (!l || l[1] !== \")\") te(\"epex\", str);\n                } else if (l[2] === \":has\") {\n                    // any amount of whitespace, followed by paren\n                    l = lex(str, (off = l[0]));\n                    if (l && l[1] === \" \") l = lex(str, off = l[0]);\n                    if (!l || l[1] !== \"(\") te(\"pex\", str);\n                    var h = parse(str, l[0], true);\n                    l[0] = h[0];\n                    if (!s.has) s.has = [];\n                    s.has.push(h[1]);\n                } else if (l[2] === \":expr\") {\n                    if (s.expr) te(\"mexp\", str);\n                    var e = exprParse(str, l[0]);\n                    l[0] = e[0];\n                    s.expr = e[1];\n                } else {\n                    if (s.pc || s.pf ) te(\"mpc\", str);\n                    s.pf = l[2];\n                    var m = nthPat.exec(str.substr(l[0]));\n                    if (!m) te(\"mepf\", str);\n                    if (m[5]) {\n                        s.a = 2;\n                        s.b = (m[5] === \"odd\") ? 1 : 0;\n                    } else if (m[6]) {\n                        s.a = 0;\n                        s.b = parseInt(m[6], 10);\n                    } else {\n                        s.a = parseInt((m[1] ? m[1] : \"+\") + (m[2] ? m[2] : \"1\"),10);\n                        s.b = m[3] ? parseInt(m[3] + m[4],10) : 0;\n                    }\n                    l[0] += m[0].length;\n                }\n            } else {\n                break;\n            }\n            l = lex(str, (off = l[0]));\n        }\n\n        // now if we didn't actually parse anything it's an error\n        if (soff === off) te(\"se\", str);\n\n        return [off, s];\n    }\n\n    // THE EVALUATOR\n\n    function isArray(o) {\n        return Array.isArray ? Array.isArray(o) : \n          toString.call(o) === \"[object Array]\";\n    }\n\n    function mytypeof(o) {\n        if (o === null) return \"null\";\n        var to = typeof o;\n        if (to === \"object\" && isArray(o)) to = \"array\";\n        return to;\n    }\n\n    function mn(node, sel, id, num, tot) {\n        var sels = [];\n        var cs = (sel[0] === \">\") ? sel[1] : sel[0];\n        var m = true, mod;\n        if (cs.type) m = m && (cs.type === mytypeof(node));\n        if (cs.id)   m = m && (cs.id === id);\n        if (m && cs.pf) {\n            if (cs.pf === \":nth-last-child\") num = tot - num;\n            else num++;\n            if (cs.a === 0) {\n                m = cs.b === num;\n            } else {\n                mod = ((num - cs.b) % cs.a);\n\n                m = (!mod && ((num*cs.a + cs.b) >= 0));\n            }\n        }\n        if (m && cs.has) {\n            // perhaps we should augment forEach to handle a return value\n            // that indicates \"client cancels traversal\"?\n            var bail = function() { throw 42; };\n            for (var i = 0; i < cs.has.length; i++) {\n                try {\n                    forEach(cs.has[i], node, bail);\n                } catch (e) {\n                    if (e === 42) continue;\n                }\n                m = false;\n                break;\n            }\n        }\n        if (m && cs.expr) {\n            m = exprEval(cs.expr, node);\n        }\n        // should we repeat this selector for descendants?\n        if (sel[0] !== \">\" && sel[0].pc !== \":root\") sels.push(sel);\n\n        if (m) {\n            // is there a fragment that we should pass down?\n            if (sel[0] === \">\") { if (sel.length > 2) { m = false; sels.push(sel.slice(2)); } }\n            else if (sel.length > 1) { m = false; sels.push(sel.slice(1)); }\n        }\n\n        return [m, sels];\n    }\n\n    function forEach(sel, obj, fun, id, num, tot) {\n        var a = (sel[0] === \",\") ? sel.slice(1) : [sel],\n        a0 = [],\n        call = false,\n        i = 0, j = 0, k, x;\n        for (i = 0; i < a.length; i++) {\n            x = mn(obj, a[i], id, num, tot);\n            if (x[0]) {\n                call = true;\n            }\n            for (j = 0; j < x[1].length; j++) {\n                a0.push(x[1][j]);\n            }\n        }\n        if (a0.length && typeof obj === \"object\") {\n            if (a0.length >= 1) {\n                a0.unshift(\",\");\n            }\n            if (isArray(obj)) {\n                for (i = 0; i < obj.length; i++) {\n                    forEach(a0, obj[i], fun, undefined, i, obj.length);\n                }\n            } else {\n                for (k in obj) {\n                    if (obj.hasOwnProperty(k)) {\n                        forEach(a0, obj[k], fun, k);\n                    }\n                }\n            }\n        }\n        if (call && fun) {\n            fun(obj);\n        }\n    }\n\n    function match(sel, obj) {\n        var a = [];\n        forEach(sel, obj, function(x) {\n            a.push(x);\n        });\n        return a;\n    }\n\n    function format(sel, arr) {\n        sel = sel.replace(/\\?/g, function() {\n            if (arr.length === 0) throw \"too few parameters given\";\n            var p = arr.shift();\n            return ((typeof p === 'string') ? JSON.stringify(p) : p);\n        });\n        if (arr.length) throw \"too many parameters supplied\";\n        return sel;\n    } \n\n    function compile(sel, arr) {\n        if (arr) sel = format(sel, arr);\n        return {\n            sel: parse(sel)[1],\n            match: function(obj){\n                return match(this.sel, obj);\n            },\n            forEach: function(obj, fun) {\n                return forEach(this.sel, obj, fun);\n            }\n        };\n    }\n\n    exports._lex = lex;\n    exports._parse = parse;\n    exports.match = function (sel, arr, obj) {\n        if (!obj) { obj = arr; arr = undefined; }\n        return compile(sel, arr).match(obj);\n    };\n    exports.forEach = function(sel, arr, obj, fun) {\n        if (!fun) { fun = obj;  obj = arr; arr = undefined }\n        return compile(sel, arr).forEach(obj, fun);\n    };\n    exports.compile = compile;\n})(typeof exports === \"undefined\" ? (window.JSONSelect = {}) : exports);\n"]},"metadata":{},"sourceType":"script"}