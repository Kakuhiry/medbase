{"ast":null,"code":"/*\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true */\n\n/*global exports:true, define:true, window:true */\n(function (factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // and plain browser loading,\n\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(window.estraverse = {});\n  }\n})(function (exports) {\n  'use strict';\n\n  var Syntax, isArray, VisitorOption, VisitorKeys, wrappers;\n  Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    ArrayExpression: 'ArrayExpression',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    DirectiveStatement: 'DirectiveStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    Program: 'Program',\n    Property: 'Property',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SwitchStatement: 'SwitchStatement',\n    SwitchCase: 'SwitchCase',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement'\n  };\n  isArray = Array.isArray;\n\n  if (!isArray) {\n    isArray = function isArray(array) {\n      return Object.prototype.toString.call(array) === '[object Array]';\n    };\n  }\n\n  VisitorKeys = {\n    AssignmentExpression: ['left', 'right'],\n    ArrayExpression: ['elements'],\n    BlockStatement: ['body'],\n    BinaryExpression: ['left', 'right'],\n    BreakStatement: ['label'],\n    CallExpression: ['callee', 'arguments'],\n    CatchClause: ['param', 'body'],\n    ConditionalExpression: ['test', 'consequent', 'alternate'],\n    ContinueStatement: ['label'],\n    DebuggerStatement: [],\n    DirectiveStatement: [],\n    DoWhileStatement: ['body', 'test'],\n    EmptyStatement: [],\n    ExpressionStatement: ['expression'],\n    ForStatement: ['init', 'test', 'update', 'body'],\n    ForInStatement: ['left', 'right', 'body'],\n    FunctionDeclaration: ['id', 'params', 'body'],\n    FunctionExpression: ['id', 'params', 'body'],\n    Identifier: [],\n    IfStatement: ['test', 'consequent', 'alternate'],\n    Literal: [],\n    LabeledStatement: ['label', 'body'],\n    LogicalExpression: ['left', 'right'],\n    MemberExpression: ['object', 'property'],\n    NewExpression: ['callee', 'arguments'],\n    ObjectExpression: ['properties'],\n    Program: ['body'],\n    Property: ['key', 'value'],\n    ReturnStatement: ['argument'],\n    SequenceExpression: ['expressions'],\n    SwitchStatement: ['discriminant', 'cases'],\n    SwitchCase: ['test', 'consequent'],\n    ThisExpression: [],\n    ThrowStatement: ['argument'],\n    TryStatement: ['block', 'handlers', 'finalizer'],\n    UnaryExpression: ['argument'],\n    UpdateExpression: ['argument'],\n    VariableDeclaration: ['declarations'],\n    VariableDeclarator: ['id', 'init'],\n    WhileStatement: ['test', 'body'],\n    WithStatement: ['object', 'body']\n  };\n  VisitorOption = {\n    Break: 1,\n    Skip: 2\n  };\n  wrappers = {\n    PropertyWrapper: 'Property'\n  };\n\n  function traverse(top, visitor) {\n    var worklist,\n        leavelist,\n        node,\n        nodeType,\n        ret,\n        current,\n        current2,\n        candidates,\n        candidate,\n        marker = {};\n    worklist = [top];\n    leavelist = [null];\n\n    while (worklist.length) {\n      node = worklist.pop();\n      nodeType = node.type;\n\n      if (node === marker) {\n        node = leavelist.pop();\n\n        if (visitor.leave) {\n          ret = visitor.leave(node, leavelist[leavelist.length - 1]);\n        } else {\n          ret = undefined;\n        }\n\n        if (ret === VisitorOption.Break) {\n          return;\n        }\n      } else if (node) {\n        if (wrappers.hasOwnProperty(nodeType)) {\n          node = node.node;\n          nodeType = wrappers[nodeType];\n        }\n\n        if (visitor.enter) {\n          ret = visitor.enter(node, leavelist[leavelist.length - 1]);\n        } else {\n          ret = undefined;\n        }\n\n        if (ret === VisitorOption.Break) {\n          return;\n        }\n\n        worklist.push(marker);\n        leavelist.push(node);\n\n        if (ret !== VisitorOption.Skip) {\n          candidates = VisitorKeys[nodeType];\n          current = candidates.length;\n\n          while ((current -= 1) >= 0) {\n            candidate = node[candidates[current]];\n\n            if (candidate) {\n              if (isArray(candidate)) {\n                current2 = candidate.length;\n\n                while ((current2 -= 1) >= 0) {\n                  if (candidate[current2]) {\n                    if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current] && null == candidates[current].type) {\n                      worklist.push({\n                        type: 'PropertyWrapper',\n                        node: candidate[current2]\n                      });\n                    } else {\n                      worklist.push(candidate[current2]);\n                    }\n                  }\n                }\n              } else {\n                worklist.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function replace(top, visitor) {\n    var worklist,\n        leavelist,\n        node,\n        nodeType,\n        target,\n        tuple,\n        ret,\n        current,\n        current2,\n        candidates,\n        candidate,\n        marker = {},\n        result;\n    result = {\n      top: top\n    };\n    tuple = [top, result, 'top'];\n    worklist = [tuple];\n    leavelist = [tuple];\n\n    function notify(v) {\n      ret = v;\n    }\n\n    while (worklist.length) {\n      tuple = worklist.pop();\n\n      if (tuple === marker) {\n        tuple = leavelist.pop();\n        ret = undefined;\n\n        if (visitor.leave) {\n          node = tuple[0];\n          target = visitor.leave(tuple[0], leavelist[leavelist.length - 1][0], notify);\n\n          if (target !== undefined) {\n            node = target;\n          }\n\n          tuple[1][tuple[2]] = node;\n        }\n\n        if (ret === VisitorOption.Break) {\n          return result.top;\n        }\n      } else if (tuple[0]) {\n        ret = undefined;\n        node = tuple[0];\n        nodeType = node.type;\n\n        if (wrappers.hasOwnProperty(nodeType)) {\n          tuple[0] = node = node.node;\n          nodeType = wrappers[nodeType];\n        }\n\n        if (visitor.enter) {\n          target = visitor.enter(tuple[0], leavelist[leavelist.length - 1][0], notify);\n\n          if (target !== undefined) {\n            node = target;\n          }\n\n          tuple[1][tuple[2]] = node;\n          tuple[0] = node;\n        }\n\n        if (ret === VisitorOption.Break) {\n          return result.top;\n        }\n\n        if (tuple[0]) {\n          worklist.push(marker);\n          leavelist.push(tuple);\n\n          if (ret !== VisitorOption.Skip) {\n            candidates = VisitorKeys[nodeType];\n            current = candidates.length;\n\n            while ((current -= 1) >= 0) {\n              candidate = node[candidates[current]];\n\n              if (candidate) {\n                if (isArray(candidate)) {\n                  current2 = candidate.length;\n\n                  while ((current2 -= 1) >= 0) {\n                    if (candidate[current2]) {\n                      if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current] && null == candidates[current].type) {\n                        worklist.push([{\n                          type: 'PropertyWrapper',\n                          node: candidate[current2]\n                        }, candidate, current2]);\n                      } else {\n                        worklist.push([candidate[current2], candidate, current2]);\n                      }\n                    }\n                  }\n                } else {\n                  worklist.push([candidate, node, candidates[current]]);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return result.top;\n  }\n\n  exports.version = '0.0.4';\n  exports.Syntax = Syntax;\n  exports.traverse = traverse;\n  exports.replace = replace;\n  exports.VisitorKeys = VisitorKeys;\n  exports.VisitorOption = VisitorOption;\n});\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"sources":["/home/elvis/Documents/GitHub/medbase/mern-auth/node_modules/estraverse/estraverse.js"],"names":["factory","define","amd","exports","window","estraverse","Syntax","isArray","VisitorOption","VisitorKeys","wrappers","AssignmentExpression","ArrayExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ConditionalExpression","ContinueStatement","DebuggerStatement","DirectiveStatement","DoWhileStatement","EmptyStatement","ExpressionStatement","ForStatement","ForInStatement","FunctionDeclaration","FunctionExpression","Identifier","IfStatement","Literal","LabeledStatement","LogicalExpression","MemberExpression","NewExpression","ObjectExpression","Program","Property","ReturnStatement","SequenceExpression","SwitchStatement","SwitchCase","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","Array","array","Object","prototype","toString","call","Break","Skip","PropertyWrapper","traverse","top","visitor","worklist","leavelist","node","nodeType","ret","current","current2","candidates","candidate","marker","length","pop","type","leave","undefined","hasOwnProperty","enter","push","replace","target","tuple","result","notify","v","version"],"mappings":"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","sourcesContent":["/*\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true */\n/*global exports:true, define:true, window:true */\n(function (factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // and plain browser loading,\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((window.estraverse = {}));\n    }\n}(function (exports) {\n    'use strict';\n\n    var Syntax,\n        isArray,\n        VisitorOption,\n        VisitorKeys,\n        wrappers;\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    isArray = Array.isArray;\n    if (!isArray) {\n        isArray = function isArray(array) {\n            return Object.prototype.toString.call(array) === '[object Array]';\n        };\n    }\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handlers', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body']\n    };\n\n    VisitorOption = {\n        Break: 1,\n        Skip: 2\n    };\n\n    wrappers = {\n        PropertyWrapper: 'Property'\n    };\n\n    function traverse(top, visitor) {\n        var worklist, leavelist, node, nodeType, ret, current, current2, candidates, candidate, marker = {};\n\n        worklist = [ top ];\n        leavelist = [ null ];\n\n        while (worklist.length) {\n            node = worklist.pop();\n            nodeType = node.type;\n\n            if (node === marker) {\n                node = leavelist.pop();\n                if (visitor.leave) {\n                    ret = visitor.leave(node, leavelist[leavelist.length - 1]);\n                } else {\n                    ret = undefined;\n                }\n                if (ret === VisitorOption.Break) {\n                    return;\n                }\n            } else if (node) {\n                if (wrappers.hasOwnProperty(nodeType)) {\n                    node = node.node;\n                    nodeType = wrappers[nodeType];\n                }\n\n                if (visitor.enter) {\n                    ret = visitor.enter(node, leavelist[leavelist.length - 1]);\n                } else {\n                    ret = undefined;\n                }\n\n                if (ret === VisitorOption.Break) {\n                    return;\n                }\n\n                worklist.push(marker);\n                leavelist.push(node);\n\n                if (ret !== VisitorOption.Skip) {\n                    candidates = VisitorKeys[nodeType];\n                    current = candidates.length;\n                    while ((current -= 1) >= 0) {\n                        candidate = node[candidates[current]];\n                        if (candidate) {\n                            if (isArray(candidate)) {\n                                current2 = candidate.length;\n                                while ((current2 -= 1) >= 0) {\n                                    if (candidate[current2]) {\n                                        if(nodeType === Syntax.ObjectExpression && 'properties' === candidates[current] && null == candidates[current].type) {\n                                            worklist.push({type: 'PropertyWrapper', node: candidate[current2]});\n                                        } else {\n                                            worklist.push(candidate[current2]);\n                                        }\n                                    }\n                                }\n                            } else {\n                                worklist.push(candidate);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function replace(top, visitor) {\n        var worklist, leavelist, node, nodeType, target, tuple, ret, current, current2, candidates, candidate, marker = {}, result;\n\n        result = {\n            top: top\n        };\n\n        tuple = [ top, result, 'top' ];\n        worklist = [ tuple ];\n        leavelist = [ tuple ];\n\n        function notify(v) {\n            ret = v;\n        }\n\n        while (worklist.length) {\n            tuple = worklist.pop();\n\n            if (tuple === marker) {\n                tuple = leavelist.pop();\n                ret = undefined;\n                if (visitor.leave) {\n                    node = tuple[0];\n                    target = visitor.leave(tuple[0], leavelist[leavelist.length - 1][0], notify);\n                    if (target !== undefined) {\n                        node = target;\n                    }\n                    tuple[1][tuple[2]] = node;\n                }\n                if (ret === VisitorOption.Break) {\n                    return result.top;\n                }\n            } else if (tuple[0]) {\n                ret = undefined;\n                node = tuple[0];\n\n                nodeType = node.type;\n                if (wrappers.hasOwnProperty(nodeType)) {\n                    tuple[0] = node = node.node;\n                    nodeType = wrappers[nodeType];\n                }\n\n                if (visitor.enter) {\n                    target = visitor.enter(tuple[0], leavelist[leavelist.length - 1][0], notify);\n                    if (target !== undefined) {\n                        node = target;\n                    }\n                    tuple[1][tuple[2]] = node;\n                    tuple[0] = node;\n                }\n\n                if (ret === VisitorOption.Break) {\n                    return result.top;\n                }\n\n                if (tuple[0]) {\n                    worklist.push(marker);\n                    leavelist.push(tuple);\n\n                    if (ret !== VisitorOption.Skip) {\n                        candidates = VisitorKeys[nodeType];\n                        current = candidates.length;\n                        while ((current -= 1) >= 0) {\n                            candidate = node[candidates[current]];\n                            if (candidate) {\n                                if (isArray(candidate)) {\n                                    current2 = candidate.length;\n                                    while ((current2 -= 1) >= 0) {\n                                        if (candidate[current2]) {\n                                            if(nodeType === Syntax.ObjectExpression && 'properties' === candidates[current] && null == candidates[current].type) {\n                                                worklist.push([{type: 'PropertyWrapper', node: candidate[current2]}, candidate, current2]);\n                                            } else {\n                                                worklist.push([candidate[current2], candidate, current2]);\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    worklist.push([candidate, node, candidates[current]]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return result.top;\n    }\n\n    exports.version = '0.0.4';\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n"]},"metadata":{},"sourceType":"script"}