{"ast":null,"code":"/*\n * Introduces a typal object to make classical/prototypal patterns easier\n * Plus some AOP sugar\n *\n * By Zachary Carter <zach@carter.name>\n * MIT Licensed\n * */\nvar typal = function () {\n  var create = Object.create || function (o) {\n    function F() {}\n\n    F.prototype = o;\n    return new F();\n  };\n\n  var position = /^(before|after)/; // basic method layering\n  // always returns original method's return value\n\n  function layerMethod(k, fun) {\n    var pos = k.match(position)[0],\n        key = k.replace(position, ''),\n        prop = this[key];\n\n    if (pos === 'after') {\n      this[key] = function () {\n        var ret = prop.apply(this, arguments);\n        var args = [].slice.call(arguments);\n        args.splice(0, 0, ret);\n        fun.apply(this, args);\n        return ret;\n      };\n    } else if (pos === 'before') {\n      this[key] = function () {\n        fun.apply(this, arguments);\n        var ret = prop.apply(this, arguments);\n        return ret;\n      };\n    }\n  } // mixes each argument's own properties into calling object,\n  // overwriting them or layering them. i.e. an object method 'meth' is\n  // layered by mixin methods 'beforemeth' or 'aftermeth'\n\n\n  function typal_mix() {\n    var self = this;\n\n    for (var i = 0, o, k; i < arguments.length; i++) {\n      o = arguments[i];\n      if (!o) continue;\n      if (Object.prototype.hasOwnProperty.call(o, 'constructor')) this.constructor = o.constructor;\n      if (Object.prototype.hasOwnProperty.call(o, 'toString')) this.toString = o.toString;\n\n      for (k in o) {\n        if (Object.prototype.hasOwnProperty.call(o, k)) {\n          if (k.match(position) && typeof this[k.replace(position, '')] === 'function') layerMethod.call(this, k, o[k]);else this[k] = o[k];\n        }\n      }\n    }\n\n    return this;\n  }\n\n  return {\n    // extend object with own typalperties of each argument\n    mix: typal_mix,\n    // sugar for object begetting and mixing\n    // - Object.create(typal).mix(etc, etc);\n    // + typal.beget(etc, etc);\n    beget: function typal_beget() {\n      return arguments.length ? typal_mix.apply(create(this), arguments) : create(this);\n    },\n    // Creates a new Class function based on an object with a constructor method\n    construct: function typal_construct() {\n      var o = typal_mix.apply(create(this), arguments);\n      var constructor = o.constructor;\n\n      var Klass = o.constructor = function () {\n        return constructor.apply(this, arguments);\n      };\n\n      Klass.prototype = o;\n      Klass.mix = typal_mix; // allow for easy singleton property extension\n\n      return Klass;\n    },\n    // no op\n    constructor: function typal_constructor() {\n      return this;\n    }\n  };\n}();\n\nif (typeof exports !== 'undefined') exports.typal = typal;","map":{"version":3,"sources":["/home/elvis/Documents/GitHub/medbase/mern-auth/node_modules/jison/lib/util/typal.js"],"names":["typal","create","Object","o","F","prototype","position","layerMethod","k","fun","pos","match","key","replace","prop","ret","apply","arguments","args","slice","call","splice","typal_mix","self","i","length","hasOwnProperty","constructor","toString","mix","beget","typal_beget","construct","typal_construct","Klass","typal_constructor","exports"],"mappings":"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","sourcesContent":["/*\n * Introduces a typal object to make classical/prototypal patterns easier\n * Plus some AOP sugar\n *\n * By Zachary Carter <zach@carter.name>\n * MIT Licensed\n * */\n\nvar typal = (function () {\n\nvar create = Object.create || function (o) { function F(){} F.prototype = o; return new F(); };\nvar position = /^(before|after)/;\n\n// basic method layering\n// always returns original method's return value\nfunction layerMethod(k, fun) {\n    var pos = k.match(position)[0],\n        key = k.replace(position, ''),\n        prop = this[key];\n\n    if (pos === 'after') {\n        this[key] = function () {\n            var ret = prop.apply(this, arguments);\n            var args = [].slice.call(arguments);\n            args.splice(0, 0, ret);\n            fun.apply(this, args);\n            return ret;\n        };\n    } else if (pos === 'before') {\n        this[key] = function () {\n            fun.apply(this, arguments);\n            var ret = prop.apply(this, arguments);\n            return ret;\n        };\n    }\n}\n\n// mixes each argument's own properties into calling object,\n// overwriting them or layering them. i.e. an object method 'meth' is\n// layered by mixin methods 'beforemeth' or 'aftermeth'\nfunction typal_mix() {\n    var self = this;\n    for(var i=0,o,k; i<arguments.length; i++) {\n        o=arguments[i];\n        if (!o) continue;\n        if (Object.prototype.hasOwnProperty.call(o,'constructor'))\n            this.constructor = o.constructor;\n        if (Object.prototype.hasOwnProperty.call(o,'toString'))\n            this.toString = o.toString;\n        for(k in o) {\n            if (Object.prototype.hasOwnProperty.call(o, k)) {\n                if(k.match(position) && typeof this[k.replace(position, '')] === 'function')\n                    layerMethod.call(this, k, o[k]);\n                else\n                    this[k] = o[k];\n            }\n        }\n    }\n    return this;\n}\n\nreturn {\n    // extend object with own typalperties of each argument\n    mix: typal_mix,\n\n    // sugar for object begetting and mixing\n    // - Object.create(typal).mix(etc, etc);\n    // + typal.beget(etc, etc);\n    beget: function typal_beget() {\n        return arguments.length ? typal_mix.apply(create(this), arguments) : create(this);\n    },\n\n    // Creates a new Class function based on an object with a constructor method\n    construct: function typal_construct() {\n        var o = typal_mix.apply(create(this), arguments);\n        var constructor = o.constructor;\n        var Klass = o.constructor = function () { return constructor.apply(this, arguments); };\n        Klass.prototype = o;\n        Klass.mix = typal_mix; // allow for easy singleton property extension\n        return Klass;\n    },\n\n    // no op\n    constructor: function typal_constructor() { return this; }\n};\n\n})();\n\nif (typeof exports !== 'undefined')\n    exports.typal = typal;\n"]},"metadata":{},"sourceType":"script"}