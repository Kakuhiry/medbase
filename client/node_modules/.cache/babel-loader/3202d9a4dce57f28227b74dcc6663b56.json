{"ast":null,"code":"/*\n  Copyright (C) 2012 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true */\n\n/*global escodegen:true, exports:true, generateStatement:true, generateExpression:true, generateFunctionBody:true, process:true, require:true, define:true, global:true*/\n(function () {\n  'use strict';\n\n  var Syntax, Precedence, BinaryPrecedence, Regex, VisitorKeys, VisitorOption, SourceNode, isArray, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, traverse;\n  traverse = require('estraverse').traverse;\n  Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    ArrayExpression: 'ArrayExpression',\n    ArrayPattern: 'ArrayPattern',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ComprehensionBlock: 'ComprehensionBlock',\n    ComprehensionExpression: 'ComprehensionExpression',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DirectiveStatement: 'DirectiveStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    ObjectPattern: 'ObjectPattern',\n    Program: 'Program',\n    Property: 'Property',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SwitchStatement: 'SwitchStatement',\n    SwitchCase: 'SwitchCase',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement',\n    YieldExpression: 'YieldExpression'\n  };\n  Precedence = {\n    Sequence: 0,\n    Assignment: 1,\n    Conditional: 2,\n    LogicalOR: 3,\n    LogicalAND: 4,\n    BitwiseOR: 5,\n    BitwiseXOR: 6,\n    BitwiseAND: 7,\n    Equality: 8,\n    Relational: 9,\n    BitwiseSHIFT: 10,\n    Additive: 11,\n    Multiplicative: 12,\n    Unary: 13,\n    Postfix: 14,\n    Call: 15,\n    New: 16,\n    Member: 17,\n    Primary: 18\n  };\n  BinaryPrecedence = {\n    '||': Precedence.LogicalOR,\n    '&&': Precedence.LogicalAND,\n    '|': Precedence.BitwiseOR,\n    '^': Precedence.BitwiseXOR,\n    '&': Precedence.BitwiseAND,\n    '==': Precedence.Equality,\n    '!=': Precedence.Equality,\n    '===': Precedence.Equality,\n    '!==': Precedence.Equality,\n    'is': Precedence.Equality,\n    'isnt': Precedence.Equality,\n    '<': Precedence.Relational,\n    '>': Precedence.Relational,\n    '<=': Precedence.Relational,\n    '>=': Precedence.Relational,\n    'in': Precedence.Relational,\n    'instanceof': Precedence.Relational,\n    '<<': Precedence.BitwiseSHIFT,\n    '>>': Precedence.BitwiseSHIFT,\n    '>>>': Precedence.BitwiseSHIFT,\n    '+': Precedence.Additive,\n    '-': Precedence.Additive,\n    '*': Precedence.Multiplicative,\n    '%': Precedence.Multiplicative,\n    '/': Precedence.Multiplicative\n  };\n  Regex = {\n    NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n  };\n\n  function getDefaultOptions() {\n    // default options\n    return {\n      indent: null,\n      base: null,\n      parse: null,\n      comment: false,\n      format: {\n        indent: {\n          style: '    ',\n          base: 0,\n          adjustMultilineComment: false\n        },\n        json: false,\n        renumber: false,\n        hexadecimal: false,\n        quotes: 'single',\n        escapeless: false,\n        compact: false,\n        parentheses: true,\n        semicolons: true,\n        safeConcatenation: false\n      },\n      moz: {\n        starlessGenerator: false,\n        parenthesizedComprehensionBlock: false\n      },\n      sourceMap: null,\n      sourceMapRoot: null,\n      sourceMapWithCode: false,\n      directive: false,\n      verbatim: null\n    };\n  }\n\n  function stringToArray(str) {\n    var length = str.length,\n        result = [],\n        i;\n\n    for (i = 0; i < length; i += 1) {\n      result[i] = str.charAt(i);\n    }\n\n    return result;\n  }\n\n  function stringRepeat(str, num) {\n    var result = '';\n\n    for (num |= 0; num > 0; num >>>= 1, str += str) {\n      if (num & 1) {\n        result += str;\n      }\n    }\n\n    return result;\n  }\n\n  isArray = Array.isArray;\n\n  if (!isArray) {\n    isArray = function isArray(array) {\n      return Object.prototype.toString.call(array) === '[object Array]';\n    };\n  } // Fallback for the non SourceMap environment\n\n\n  function SourceNodeMock(line, column, filename, chunk) {\n    var result = [];\n\n    function flatten(input) {\n      var i, iz;\n\n      if (isArray(input)) {\n        for (i = 0, iz = input.length; i < iz; ++i) {\n          flatten(input[i]);\n        }\n      } else if (input instanceof SourceNodeMock) {\n        result.push(input);\n      } else if (typeof input === 'string' && input) {\n        result.push(input);\n      }\n    }\n\n    flatten(chunk);\n    this.children = result;\n  }\n\n  SourceNodeMock.prototype.toString = function toString() {\n    var res = '',\n        i,\n        iz,\n        node;\n\n    for (i = 0, iz = this.children.length; i < iz; ++i) {\n      node = this.children[i];\n\n      if (node instanceof SourceNodeMock) {\n        res += node.toString();\n      } else {\n        res += node;\n      }\n    }\n\n    return res;\n  };\n\n  SourceNodeMock.prototype.replaceRight = function replaceRight(pattern, replacement) {\n    var last = this.children[this.children.length - 1];\n\n    if (last instanceof SourceNodeMock) {\n      last.replaceRight(pattern, replacement);\n    } else if (typeof last === 'string') {\n      this.children[this.children.length - 1] = last.replace(pattern, replacement);\n    } else {\n      this.children.push(''.replace(pattern, replacement));\n    }\n\n    return this;\n  };\n\n  SourceNodeMock.prototype.join = function join(sep) {\n    var i, iz, result;\n    result = [];\n    iz = this.children.length;\n\n    if (iz > 0) {\n      for (i = 0, iz -= 1; i < iz; ++i) {\n        result.push(this.children[i], sep);\n      }\n\n      result.push(this.children[iz]);\n      this.children = result;\n    }\n\n    return this;\n  };\n\n  function hasLineTerminator(str) {\n    return /[\\r\\n]/g.test(str);\n  }\n\n  function endsWithLineTerminator(str) {\n    var ch = str.charAt(str.length - 1);\n    return ch === '\\r' || ch === '\\n';\n  }\n\n  function shallowCopy(obj) {\n    var ret = {},\n        key;\n\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        ret[key] = obj[key];\n      }\n    }\n\n    return ret;\n  }\n\n  function deepCopy(obj) {\n    var ret = {},\n        key,\n        val;\n\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        val = obj[key];\n\n        if (typeof val === 'object' && val !== null) {\n          ret[key] = deepCopy(val);\n        } else {\n          ret[key] = val;\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  function updateDeeply(target, override) {\n    var key, val;\n\n    function isHashObject(target) {\n      return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\n    }\n\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        val = override[key];\n\n        if (isHashObject(val)) {\n          if (isHashObject(target[key])) {\n            updateDeeply(target[key], val);\n          } else {\n            target[key] = updateDeeply({}, val);\n          }\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n\n    return target;\n  }\n\n  function generateNumber(value) {\n    var result, point, temp, exponent, pos;\n\n    if (value !== value) {\n      throw new Error('Numeric literal whose value is NaN');\n    }\n\n    if (value < 0 || value === 0 && 1 / value < 0) {\n      throw new Error('Numeric literal whose value is negative');\n    }\n\n    if (value === 1 / 0) {\n      return json ? 'null' : renumber ? '1e400' : '1e+400';\n    }\n\n    result = '' + value;\n\n    if (!renumber || result.length < 3) {\n      return result;\n    }\n\n    point = result.indexOf('.');\n\n    if (!json && result.charAt(0) === '0' && point === 1) {\n      point = 0;\n      result = result.slice(1);\n    }\n\n    temp = result;\n    result = result.replace('e+', 'e');\n    exponent = 0;\n\n    if ((pos = temp.indexOf('e')) > 0) {\n      exponent = +temp.slice(pos + 1);\n      temp = temp.slice(0, pos);\n    }\n\n    if (point >= 0) {\n      exponent -= temp.length - point - 1;\n      temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';\n    }\n\n    pos = 0;\n\n    while (temp.charAt(temp.length + pos - 1) === '0') {\n      pos -= 1;\n    }\n\n    if (pos !== 0) {\n      exponent -= pos;\n      temp = temp.slice(0, pos);\n    }\n\n    if (exponent !== 0) {\n      temp += 'e' + exponent;\n    }\n\n    if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {\n      result = temp;\n    }\n\n    return result;\n  } // Generate valid RegExp expression.\n  // This function is based on https://github.com/Constellation/iv Engine\n\n\n  function escapeRegExpCharacter(ch, previousIsBackslash) {\n    // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n    if ((ch & ~1) === 0x2028) {\n      return (previousIsBackslash ? 'u' : '\\\\u') + (ch === 0x2028 ? '2028' : '2029');\n    } else if (ch === 10 || ch === 13) {\n      // \\n, \\r\n      return (previousIsBackslash ? '' : '\\\\') + (ch === 10 ? 'n' : 'r');\n    }\n\n    return String.fromCharCode(ch);\n  }\n\n  function generateRegExp(reg) {\n    var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n    result = reg.toString();\n\n    if (reg.source) {\n      // extract flag from toString result\n      match = result.match(/\\/([^/]*)$/);\n\n      if (!match) {\n        return result;\n      }\n\n      flags = match[1];\n      result = '';\n      characterInBrack = false;\n      previousIsBackslash = false;\n\n      for (i = 0, iz = reg.source.length; i < iz; ++i) {\n        ch = reg.source.charCodeAt(i);\n\n        if (!previousIsBackslash) {\n          if (characterInBrack) {\n            if (ch === 93) {\n              // ]\n              characterInBrack = false;\n            }\n          } else {\n            if (ch === 47) {\n              // /\n              result += '\\\\';\n            } else if (ch === 91) {\n              // [\n              characterInBrack = true;\n            }\n          }\n\n          result += escapeRegExpCharacter(ch, previousIsBackslash);\n          previousIsBackslash = ch === 92; // \\\n        } else {\n          // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n          result += escapeRegExpCharacter(ch, previousIsBackslash); // prevent like /\\\\[/]/\n\n          previousIsBackslash = false;\n        }\n      }\n\n      return '/' + result + '/' + flags;\n    }\n\n    return result;\n  }\n\n  function escapeAllowedCharacter(ch, next) {\n    var code = ch.charCodeAt(0),\n        hex = code.toString(16),\n        result = '\\\\';\n\n    switch (ch) {\n      case '\\b':\n        result += 'b';\n        break;\n\n      case '\\f':\n        result += 'f';\n        break;\n\n      case '\\t':\n        result += 't';\n        break;\n\n      default:\n        if (json || code > 0xff) {\n          result += 'u' + '0000'.slice(hex.length) + hex;\n        } else if (ch === '\\u0000' && '0123456789'.indexOf(next) < 0) {\n          result += '0';\n        } else if (ch === '\\x0B') {\n          // '\\v'\n          result += 'x0B';\n        } else {\n          result += 'x' + '00'.slice(hex.length) + hex;\n        }\n\n        break;\n    }\n\n    return result;\n  }\n\n  function escapeDisallowedCharacter(ch) {\n    var result = '\\\\';\n\n    switch (ch) {\n      case '\\\\':\n        result += '\\\\';\n        break;\n\n      case '\\n':\n        result += 'n';\n        break;\n\n      case '\\r':\n        result += 'r';\n        break;\n\n      case '\\u2028':\n        result += 'u2028';\n        break;\n\n      case '\\u2029':\n        result += 'u2029';\n        break;\n\n      default:\n        throw new Error('Incorrectly classified character');\n    }\n\n    return result;\n  }\n\n  function escapeDirective(str) {\n    var i, iz, ch, single, buf, quote;\n    buf = str;\n\n    if (typeof buf[0] === 'undefined') {\n      buf = stringToArray(buf);\n    }\n\n    quote = quotes === 'double' ? '\"' : '\\'';\n\n    for (i = 0, iz = buf.length; i < iz; i += 1) {\n      ch = buf[i];\n\n      if (ch === '\\'') {\n        quote = '\"';\n        break;\n      } else if (ch === '\"') {\n        quote = '\\'';\n        break;\n      } else if (ch === '\\\\') {\n        i += 1;\n      }\n    }\n\n    return quote + str + quote;\n  }\n\n  function escapeString(str) {\n    var result = '',\n        i,\n        len,\n        ch,\n        next,\n        singleQuotes = 0,\n        doubleQuotes = 0,\n        single;\n\n    if (typeof str[0] === 'undefined') {\n      str = stringToArray(str);\n    }\n\n    for (i = 0, len = str.length; i < len; i += 1) {\n      ch = str[i];\n\n      if (ch === '\\'') {\n        singleQuotes += 1;\n      } else if (ch === '\"') {\n        doubleQuotes += 1;\n      } else if (ch === '/' && json) {\n        result += '\\\\';\n      } else if ('\\\\\\n\\r\\u2028\\u2029'.indexOf(ch) >= 0) {\n        result += escapeDisallowedCharacter(ch);\n        continue;\n      } else if (json && ch < ' ' || !(json || escapeless || ch >= ' ' && ch <= '~')) {\n        result += escapeAllowedCharacter(ch, str[i + 1]);\n        continue;\n      }\n\n      result += ch;\n    }\n\n    single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);\n    str = result;\n    result = single ? '\\'' : '\"';\n\n    if (typeof str[0] === 'undefined') {\n      str = stringToArray(str);\n    }\n\n    for (i = 0, len = str.length; i < len; i += 1) {\n      ch = str[i];\n\n      if (ch === '\\'' && single || ch === '\"' && !single) {\n        result += '\\\\';\n      }\n\n      result += ch;\n    }\n\n    return result + (single ? '\\'' : '\"');\n  }\n\n  function isWhiteSpace(ch) {\n    // Use `\\x0B` instead of `\\v` for IE < 9 compatibility\n    return '\\t\\x0B\\f \\xa0'.indexOf(ch) >= 0 || ch.charCodeAt(0) >= 0x1680 && '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\ufeff'.indexOf(ch) >= 0;\n  }\n\n  function isLineTerminator(ch) {\n    return '\\n\\r\\u2028\\u2029'.indexOf(ch) >= 0;\n  }\n\n  function isIdentifierPart(ch) {\n    return ch === '$' || ch === '_' || ch === '\\\\' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch.charCodeAt(0) >= 0x80 && Regex.NonAsciiIdentifierPart.test(ch);\n  }\n\n  function toSourceNode(generated, node) {\n    if (node == null) {\n      if (generated instanceof SourceNode) {\n        return generated;\n      } else {\n        node = {};\n      }\n    }\n\n    if (node.loc == null) {\n      return new SourceNode(null, null, sourceMap, generated);\n    }\n\n    return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated);\n  }\n\n  function join(left, right) {\n    var leftSource = toSourceNode(left).toString(),\n        rightSource = toSourceNode(right).toString(),\n        leftChar = leftSource.charAt(leftSource.length - 1),\n        rightChar = rightSource.charAt(0);\n\n    if ((leftChar === '+' || leftChar === '-') && leftChar === rightChar || isIdentifierPart(leftChar) && isIdentifierPart(rightChar)) {\n      return [left, ' ', right];\n    } else if (isWhiteSpace(leftChar) || isLineTerminator(leftChar) || isWhiteSpace(rightChar) || isLineTerminator(rightChar)) {\n      return [left, right];\n    }\n\n    return [left, space, right];\n  }\n\n  function addIndent(stmt) {\n    return [base, stmt];\n  }\n\n  function withIndent(fn) {\n    var previousBase, result;\n    previousBase = base;\n    base += indent;\n    result = fn.call(this, base);\n    base = previousBase;\n    return result;\n  }\n\n  function calculateSpaces(str) {\n    var i;\n\n    for (i = str.length - 1; i >= 0; i -= 1) {\n      if (isLineTerminator(str.charAt(i))) {\n        break;\n      }\n    }\n\n    return str.length - 1 - i;\n  }\n\n  function adjustMultilineComment(value, specialBase) {\n    var array, i, len, line, j, ch, spaces, previousBase;\n    array = value.split(/\\r\\n|[\\r\\n]/);\n    spaces = Number.MAX_VALUE; // first line doesn't have indentation\n\n    for (i = 1, len = array.length; i < len; i += 1) {\n      line = array[i];\n      j = 0;\n\n      while (j < line.length && isWhiteSpace(line[j])) {\n        j += 1;\n      }\n\n      if (spaces > j) {\n        spaces = j;\n      }\n    }\n\n    if (typeof specialBase !== 'undefined') {\n      // pattern like\n      // {\n      //   var t = 20;  /*\n      //                 * this is comment\n      //                 */\n      // }\n      previousBase = base;\n\n      if (array[1][spaces] === '*') {\n        specialBase += ' ';\n      }\n\n      base = specialBase;\n    } else {\n      if (spaces & 1) {\n        // /*\n        //  *\n        //  */\n        // If spaces are odd number, above pattern is considered.\n        // We waste 1 space.\n        spaces -= 1;\n      }\n\n      previousBase = base;\n    }\n\n    for (i = 1, len = array.length; i < len; i += 1) {\n      array[i] = toSourceNode(addIndent(array[i].slice(spaces))).join('');\n    }\n\n    base = previousBase;\n    return array.join('\\n');\n  }\n\n  function generateComment(comment, specialBase) {\n    if (comment.type === 'Line') {\n      if (endsWithLineTerminator(comment.value)) {\n        return '//' + comment.value;\n      } else {\n        // Always use LineTerminator\n        return '//' + comment.value + '\\n';\n      }\n    }\n\n    if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n      return adjustMultilineComment('/*' + comment.value + '*/', specialBase);\n    }\n\n    return '/*' + comment.value + '*/';\n  }\n\n  function addCommentsToStatement(stmt, result) {\n    var i, len, comment, save, node, tailingToStatement, specialBase, fragment;\n\n    if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n      save = result;\n      comment = stmt.leadingComments[0];\n      result = [];\n\n      if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n        result.push('\\n');\n      }\n\n      result.push(generateComment(comment));\n\n      if (!endsWithLineTerminator(toSourceNode(result).toString())) {\n        result.push('\\n');\n      }\n\n      for (i = 1, len = stmt.leadingComments.length; i < len; i += 1) {\n        comment = stmt.leadingComments[i];\n        fragment = [generateComment(comment)];\n\n        if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {\n          fragment.push('\\n');\n        }\n\n        result.push(addIndent(fragment));\n      }\n\n      result.push(addIndent(save));\n    }\n\n    if (stmt.trailingComments) {\n      tailingToStatement = !endsWithLineTerminator(toSourceNode(result).toString());\n      specialBase = stringRepeat(' ', calculateSpaces(toSourceNode([base, result, indent]).toString()));\n\n      for (i = 0, len = stmt.trailingComments.length; i < len; i += 1) {\n        comment = stmt.trailingComments[i];\n\n        if (tailingToStatement) {\n          // We assume target like following script\n          //\n          // var t = 20;  /**\n          //               * This is comment of t\n          //               */\n          if (i === 0) {\n            // first case\n            result = [result, indent];\n          } else {\n            result = [result, specialBase];\n          }\n\n          result.push(generateComment(comment, specialBase));\n        } else {\n          result = [result, addIndent(generateComment(comment))];\n        }\n\n        if (i !== len - 1 && !endsWithLineTerminator(toSourceNode(result).toString())) {\n          result = [result, '\\n'];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function parenthesize(text, current, should) {\n    if (current < should) {\n      return ['(', text, ')'];\n    }\n\n    return text;\n  }\n\n  function maybeBlock(stmt, semicolonOptional, functionBody) {\n    var result, noLeadingComment;\n    noLeadingComment = !extra.comment || !stmt.leadingComments;\n\n    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n      return [space, generateStatement(stmt, {\n        functionBody: functionBody\n      })];\n    }\n\n    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n      return ';';\n    }\n\n    withIndent(function () {\n      result = [newline, addIndent(generateStatement(stmt, {\n        semicolonOptional: semicolonOptional,\n        functionBody: functionBody\n      }))];\n    });\n    return result;\n  }\n\n  function maybeBlockSuffix(stmt, result) {\n    var ends = endsWithLineTerminator(toSourceNode(result).toString());\n\n    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n      return [result, space];\n    }\n\n    if (ends) {\n      return [result, base];\n    }\n\n    return [result, newline, base];\n  }\n\n  function generateVerbatim(expr, option) {\n    var i, result;\n    result = expr[extra.verbatim].split(/\\r\\n|\\n/);\n\n    for (i = 1; i < result.length; i++) {\n      result[i] = newline + base + result[i];\n    }\n\n    result = parenthesize(result, Precedence.Sequence, option.precedence);\n    return toSourceNode(result, expr);\n  }\n\n  function generateFunctionBody(node) {\n    var result, i, len, expr;\n    result = ['('];\n\n    for (i = 0, len = node.params.length; i < len; i += 1) {\n      result.push(node.params[i].name);\n\n      if (i + 1 < len) {\n        result.push(',' + space);\n      }\n    }\n\n    result.push(')');\n\n    if (node.expression) {\n      result.push(space);\n      expr = generateExpression(node.body, {\n        precedence: Precedence.Assignment,\n        allowIn: true,\n        allowCall: true\n      });\n\n      if (expr.toString().charAt(0) === '{') {\n        expr = ['(', expr, ')'];\n      }\n\n      result.push(expr);\n    } else {\n      result.push(maybeBlock(node.body, false, true));\n    }\n\n    return result;\n  }\n\n  function generateExpression(expr, option) {\n    var result, precedence, type, currentPrecedence, i, len, raw, fragment, multiline, leftChar, leftSource, rightChar, rightSource, allowIn, allowCall, allowUnparenthesizedNew, property, key, value;\n    precedence = option.precedence;\n    allowIn = option.allowIn;\n    allowCall = option.allowCall;\n    type = expr.type || option.type;\n\n    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n      return generateVerbatim(expr, option);\n    }\n\n    switch (type) {\n      case Syntax.SequenceExpression:\n        result = [];\n        allowIn |= Precedence.Sequence < precedence;\n\n        for (i = 0, len = expr.expressions.length; i < len; i += 1) {\n          result.push(generateExpression(expr.expressions[i], {\n            precedence: Precedence.Assignment,\n            allowIn: allowIn,\n            allowCall: true\n          }));\n\n          if (i + 1 < len) {\n            result.push(',' + space);\n          }\n        }\n\n        result = parenthesize(result, Precedence.Sequence, precedence);\n        break;\n\n      case Syntax.AssignmentExpression:\n        allowIn |= Precedence.Assignment < precedence;\n        result = parenthesize([generateExpression(expr.left, {\n          precedence: Precedence.Call,\n          allowIn: allowIn,\n          allowCall: true\n        }), space + expr.operator + space, generateExpression(expr.right, {\n          precedence: Precedence.Assignment,\n          allowIn: allowIn,\n          allowCall: true\n        })], Precedence.Assignment, precedence);\n        break;\n\n      case Syntax.ConditionalExpression:\n        allowIn |= Precedence.Conditional < precedence;\n        result = parenthesize([generateExpression(expr.test, {\n          precedence: Precedence.LogicalOR,\n          allowIn: allowIn,\n          allowCall: true\n        }), space + '?' + space, generateExpression(expr.consequent, {\n          precedence: Precedence.Assignment,\n          allowIn: allowIn,\n          allowCall: true\n        }), space + ':' + space, generateExpression(expr.alternate, {\n          precedence: Precedence.Assignment,\n          allowIn: allowIn,\n          allowCall: true\n        })], Precedence.Conditional, precedence);\n        break;\n\n      case Syntax.LogicalExpression:\n      case Syntax.BinaryExpression:\n        currentPrecedence = BinaryPrecedence[expr.operator];\n        allowIn |= currentPrecedence < precedence;\n        fragment = generateExpression(expr.left, {\n          precedence: currentPrecedence,\n          allowIn: allowIn,\n          allowCall: true\n        });\n        leftSource = fragment.toString();\n\n        if (leftSource.charAt(leftSource.length - 1) === '/' && isIdentifierPart(expr.operator.charAt(0))) {\n          result = [fragment, ' ', expr.operator];\n        } else {\n          result = join(fragment, expr.operator);\n        }\n\n        fragment = generateExpression(expr.right, {\n          precedence: currentPrecedence + 1,\n          allowIn: allowIn,\n          allowCall: true\n        });\n\n        if (expr.operator === '/' && fragment.toString().charAt(0) === '/') {\n          // If '/' concats with '/', it is interpreted as comment start\n          result.push(' ', fragment);\n        } else {\n          result = join(result, fragment);\n        }\n\n        if (expr.operator === 'in' && !allowIn) {\n          result = ['(', result, ')'];\n        } else {\n          result = parenthesize(result, currentPrecedence, precedence);\n        }\n\n        break;\n\n      case Syntax.CallExpression:\n        result = [generateExpression(expr.callee, {\n          precedence: Precedence.Call,\n          allowIn: true,\n          allowCall: true,\n          allowUnparenthesizedNew: false\n        })];\n        result.push('(');\n\n        for (i = 0, len = expr['arguments'].length; i < len; i += 1) {\n          result.push(generateExpression(expr['arguments'][i], {\n            precedence: Precedence.Assignment,\n            allowIn: true,\n            allowCall: true\n          }));\n\n          if (i + 1 < len) {\n            result.push(',' + space);\n          }\n        }\n\n        result.push(')');\n\n        if (!allowCall) {\n          result = ['(', result, ')'];\n        } else {\n          result = parenthesize(result, Precedence.Call, precedence);\n        }\n\n        break;\n\n      case Syntax.NewExpression:\n        len = expr['arguments'].length;\n        allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;\n        result = join('new', generateExpression(expr.callee, {\n          precedence: Precedence.New,\n          allowIn: true,\n          allowCall: false,\n          allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0\n        }));\n\n        if (!allowUnparenthesizedNew || parentheses || len > 0) {\n          result.push('(');\n\n          for (i = 0; i < len; i += 1) {\n            result.push(generateExpression(expr['arguments'][i], {\n              precedence: Precedence.Assignment,\n              allowIn: true,\n              allowCall: true\n            }));\n\n            if (i + 1 < len) {\n              result.push(',' + space);\n            }\n          }\n\n          result.push(')');\n        }\n\n        result = parenthesize(result, Precedence.New, precedence);\n        break;\n\n      case Syntax.MemberExpression:\n        result = [generateExpression(expr.object, {\n          precedence: Precedence.Call,\n          allowIn: true,\n          allowCall: allowCall,\n          allowUnparenthesizedNew: false\n        })];\n\n        if (expr.computed) {\n          result.push('[', generateExpression(expr.property, {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: allowCall\n          }), ']');\n        } else {\n          if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {\n            if (result.indexOf('.') < 0) {\n              if (!/[eExX]/.test(result) && !(result.length >= 2 && result[0] === '0')) {\n                result.push('.');\n              }\n            }\n          }\n\n          result.push('.' + expr.property.name);\n        }\n\n        result = parenthesize(result, Precedence.Member, precedence);\n        break;\n\n      case Syntax.UnaryExpression:\n        fragment = generateExpression(expr.argument, {\n          precedence: Precedence.Unary,\n          allowIn: true,\n          allowCall: true\n        });\n\n        if (space === '') {\n          result = join(expr.operator, fragment);\n        } else {\n          result = [expr.operator];\n\n          if (expr.operator.length > 2) {\n            // delete, void, typeof\n            // get `typeof []`, not `typeof[]`\n            result = join(result, fragment);\n          } else {\n            // Prevent inserting spaces between operator and argument if it is unnecessary\n            // like, `!cond`\n            leftSource = toSourceNode(result).toString();\n            leftChar = leftSource.charAt(leftSource.length - 1);\n            rightChar = fragment.toString().charAt(0);\n\n            if ((leftChar === '+' || leftChar === '-') && leftChar === rightChar || isIdentifierPart(leftChar) && isIdentifierPart(rightChar)) {\n              result.push(' ', fragment);\n            } else {\n              result.push(fragment);\n            }\n          }\n        }\n\n        result = parenthesize(result, Precedence.Unary, precedence);\n        break;\n\n      case Syntax.YieldExpression:\n        if (expr.delegate) {\n          result = 'yield*';\n        } else {\n          result = 'yield';\n        }\n\n        if (expr.argument) {\n          result = join(result, generateExpression(expr.argument, {\n            precedence: Precedence.Assignment,\n            allowIn: true,\n            allowCall: true\n          }));\n        }\n\n        break;\n\n      case Syntax.UpdateExpression:\n        if (expr.prefix) {\n          result = parenthesize([expr.operator, generateExpression(expr.argument, {\n            precedence: Precedence.Unary,\n            allowIn: true,\n            allowCall: true\n          })], Precedence.Unary, precedence);\n        } else {\n          result = parenthesize([generateExpression(expr.argument, {\n            precedence: Precedence.Postfix,\n            allowIn: true,\n            allowCall: true\n          }), expr.operator], Precedence.Postfix, precedence);\n        }\n\n        break;\n\n      case Syntax.FunctionExpression:\n        result = 'function';\n\n        if (expr.id) {\n          result += ' ' + expr.id.name;\n        } else {\n          result += space;\n        }\n\n        result = [result, generateFunctionBody(expr)];\n        break;\n\n      case Syntax.ArrayPattern:\n      case Syntax.ArrayExpression:\n        if (!expr.elements.length) {\n          result = '[]';\n          break;\n        }\n\n        multiline = expr.elements.length > 1;\n        result = ['[', multiline ? newline : ''];\n        withIndent(function (indent) {\n          for (i = 0, len = expr.elements.length; i < len; i += 1) {\n            if (!expr.elements[i]) {\n              if (multiline) {\n                result.push(indent);\n              }\n\n              if (i + 1 === len) {\n                result.push(',');\n              }\n            } else {\n              result.push(multiline ? indent : '', generateExpression(expr.elements[i], {\n                precedence: Precedence.Assignment,\n                allowIn: true,\n                allowCall: true\n              }));\n            }\n\n            if (i + 1 < len) {\n              result.push(',' + (multiline ? newline : space));\n            }\n          }\n        });\n\n        if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {\n          result.push(newline);\n        }\n\n        result.push(multiline ? base : '', ']');\n        break;\n\n      case Syntax.Property:\n        if (expr.kind === 'get' || expr.kind === 'set') {\n          result = [expr.kind + ' ', generateExpression(expr.key, {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: true\n          }), generateFunctionBody(expr.value)];\n        } else {\n          if (expr.shorthand) {\n            result = generateExpression(expr.key, {\n              precedence: Precedence.Sequence,\n              allowIn: true,\n              allowCall: true\n            });\n          } else if (expr.method) {\n            result = [];\n\n            if (expr.value.generator) {\n              result.push('*');\n            }\n\n            result.push(generateExpression(expr.key, {\n              precedence: Precedence.Sequence,\n              allowIn: true,\n              allowCall: true\n            }), generateFunctionBody(expr.value));\n          } else {\n            result = [generateExpression(expr.key, {\n              precedence: Precedence.Sequence,\n              allowIn: true,\n              allowCall: true\n            }), ':' + space, generateExpression(expr.value, {\n              precedence: Precedence.Assignment,\n              allowIn: true,\n              allowCall: true\n            })];\n          }\n        }\n\n        break;\n\n      case Syntax.ObjectExpression:\n        if (!expr.properties.length) {\n          result = '{}';\n          break;\n        }\n\n        multiline = expr.properties.length > 1;\n        withIndent(function (indent) {\n          fragment = generateExpression(expr.properties[0], {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: true,\n            type: Syntax.Property\n          });\n        });\n\n        if (!multiline) {\n          // issues 4\n          // Do not transform from\n          //   dejavu.Class.declare({\n          //       method2: function () {}\n          //   });\n          // to\n          //   dejavu.Class.declare({method2: function () {\n          //       }});\n          if (!hasLineTerminator(toSourceNode(fragment).toString())) {\n            result = ['{', space, fragment, space, '}'];\n            break;\n          }\n        }\n\n        withIndent(function (indent) {\n          result = ['{', newline, indent, fragment];\n\n          if (multiline) {\n            result.push(',' + newline);\n\n            for (i = 1, len = expr.properties.length; i < len; i += 1) {\n              result.push(indent, generateExpression(expr.properties[i], {\n                precedence: Precedence.Sequence,\n                allowIn: true,\n                allowCall: true,\n                type: Syntax.Property\n              }));\n\n              if (i + 1 < len) {\n                result.push(',' + newline);\n              }\n            }\n          }\n        });\n\n        if (!endsWithLineTerminator(toSourceNode(result).toString())) {\n          result.push(newline);\n        }\n\n        result.push(base, '}');\n        break;\n\n      case Syntax.ObjectPattern:\n        if (!expr.properties.length) {\n          result = '{}';\n          break;\n        }\n\n        multiline = false;\n\n        if (expr.properties.length === 1) {\n          property = expr.properties[0];\n\n          if (property.value.type !== Syntax.Identifier) {\n            multiline = true;\n          }\n        } else {\n          for (i = 0, len = expr.properties.length; i < len; i += 1) {\n            property = expr.properties[i];\n\n            if (!property.shorthand) {\n              multiline = true;\n              break;\n            }\n          }\n        }\n\n        result = ['{', multiline ? newline : ''];\n        withIndent(function (indent) {\n          for (i = 0, len = expr.properties.length; i < len; i += 1) {\n            result.push(multiline ? indent : '', generateExpression(expr.properties[i], {\n              precedence: Precedence.Sequence,\n              allowIn: true,\n              allowCall: true\n            }));\n\n            if (i + 1 < len) {\n              result.push(',' + (multiline ? newline : space));\n            }\n          }\n        });\n\n        if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {\n          result.push(newline);\n        }\n\n        result.push(multiline ? base : '', '}');\n        break;\n\n      case Syntax.ThisExpression:\n        result = 'this';\n        break;\n\n      case Syntax.Identifier:\n        result = expr.name;\n        break;\n\n      case Syntax.Literal:\n        if (expr.hasOwnProperty('raw') && parse) {\n          try {\n            raw = parse(expr.raw).body[0].expression;\n\n            if (raw.type === Syntax.Literal) {\n              if (raw.value === expr.value) {\n                result = expr.raw;\n                break;\n              }\n            }\n          } catch (e) {// not use raw property\n          }\n        }\n\n        if (expr.value === null) {\n          result = 'null';\n          break;\n        }\n\n        if (typeof expr.value === 'string') {\n          result = escapeString(expr.value);\n          break;\n        }\n\n        if (typeof expr.value === 'number') {\n          result = generateNumber(expr.value);\n          break;\n        }\n\n        if (typeof expr.value === 'boolean') {\n          result = expr.value ? 'true' : 'false';\n          break;\n        }\n\n        result = generateRegExp(expr.value);\n        break;\n\n      case Syntax.ComprehensionExpression:\n        result = ['[', generateExpression(expr.body, {\n          precedence: Precedence.Assignment,\n          allowIn: true,\n          allowCall: true\n        })];\n\n        if (expr.blocks) {\n          for (i = 0, len = expr.blocks.length; i < len; i += 1) {\n            fragment = generateExpression(expr.blocks[i], {\n              precedence: Precedence.Sequence,\n              allowIn: true,\n              allowCall: true\n            });\n            result = join(result, fragment);\n          }\n        }\n\n        if (expr.filter) {\n          result = join(result, 'if' + space);\n          fragment = generateExpression(expr.filter, {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: true\n          });\n\n          if (extra.moz.parenthesizedComprehensionBlock) {\n            result = join(result, ['(', fragment, ')']);\n          } else {\n            result = join(result, fragment);\n          }\n        }\n\n        result.push(']');\n        break;\n\n      case Syntax.ComprehensionBlock:\n        if (expr.left.type === Syntax.VariableDeclaration) {\n          fragment = [expr.left.kind + ' ', generateStatement(expr.left.declarations[0], {\n            allowIn: false\n          })];\n        } else {\n          fragment = generateExpression(expr.left, {\n            precedence: Precedence.Call,\n            allowIn: true,\n            allowCall: true\n          });\n        }\n\n        fragment = join(fragment, expr.of ? 'of' : 'in');\n        fragment = join(fragment, generateExpression(expr.right, {\n          precedence: Precedence.Sequence,\n          allowIn: true,\n          allowCall: true\n        }));\n\n        if (extra.moz.parenthesizedComprehensionBlock) {\n          result = ['for' + space + '(', fragment, ')'];\n        } else {\n          result = join('for' + space, fragment);\n        }\n\n        break;\n\n      default:\n        throw new Error('Unknown expression type: ' + expr.type);\n    }\n\n    return toSourceNode(result, expr);\n  }\n\n  function generateStatement(stmt, option) {\n    var i, len, result, node, allowIn, functionBody, directiveContext, fragment, semicolon;\n    allowIn = true;\n    semicolon = ';';\n    functionBody = false;\n    directiveContext = false;\n\n    if (option) {\n      allowIn = option.allowIn === undefined || option.allowIn;\n\n      if (!semicolons && option.semicolonOptional === true) {\n        semicolon = '';\n      }\n\n      functionBody = option.functionBody;\n      directiveContext = option.directiveContext;\n    }\n\n    switch (stmt.type) {\n      case Syntax.BlockStatement:\n        result = ['{', newline];\n        withIndent(function () {\n          for (i = 0, len = stmt.body.length; i < len; i += 1) {\n            fragment = addIndent(generateStatement(stmt.body[i], {\n              semicolonOptional: i === len - 1,\n              directiveContext: functionBody\n            }));\n            result.push(fragment);\n\n            if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {\n              result.push(newline);\n            }\n          }\n        });\n        result.push(addIndent('}'));\n        break;\n\n      case Syntax.BreakStatement:\n        if (stmt.label) {\n          result = 'break ' + stmt.label.name + semicolon;\n        } else {\n          result = 'break' + semicolon;\n        }\n\n        break;\n\n      case Syntax.ContinueStatement:\n        if (stmt.label) {\n          result = 'continue ' + stmt.label.name + semicolon;\n        } else {\n          result = 'continue' + semicolon;\n        }\n\n        break;\n\n      case Syntax.DirectiveStatement:\n        if (stmt.raw) {\n          result = stmt.raw + semicolon;\n        } else {\n          result = escapeDirective(stmt.directive) + semicolon;\n        }\n\n        break;\n\n      case Syntax.DoWhileStatement:\n        // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n        result = join('do', maybeBlock(stmt.body));\n        result = maybeBlockSuffix(stmt.body, result);\n        result = join(result, ['while' + space + '(', generateExpression(stmt.test, {\n          precedence: Precedence.Sequence,\n          allowIn: true,\n          allowCall: true\n        }), ')' + semicolon]);\n        break;\n\n      case Syntax.CatchClause:\n        withIndent(function () {\n          result = ['catch' + space + '(', generateExpression(stmt.param, {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: true\n          }), ')'];\n        });\n        result.push(maybeBlock(stmt.body));\n        break;\n\n      case Syntax.DebuggerStatement:\n        result = 'debugger' + semicolon;\n        break;\n\n      case Syntax.EmptyStatement:\n        result = ';';\n        break;\n\n      case Syntax.ExpressionStatement:\n        result = [generateExpression(stmt.expression, {\n          precedence: Precedence.Sequence,\n          allowIn: true,\n          allowCall: true\n        })]; // 12.4 '{', 'function' is not allowed in this position.\n        // wrap expression with parentheses\n\n        if (result.toString().charAt(0) === '{' || result.toString().slice(0, 8) === 'function' && \" (\".indexOf(result.toString().charAt(8)) >= 0 || directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {\n          result = ['(', result, ')' + semicolon];\n        } else {\n          result.push(semicolon);\n        }\n\n        break;\n\n      case Syntax.VariableDeclarator:\n        if (stmt.init) {\n          result = [generateExpression(stmt.id, {\n            precedence: Precedence.Assignment,\n            allowIn: allowIn,\n            allowCall: true\n          }) + space + '=' + space, generateExpression(stmt.init, {\n            precedence: Precedence.Assignment,\n            allowIn: allowIn,\n            allowCall: true\n          })];\n        } else {\n          result = stmt.id.name;\n        }\n\n        break;\n\n      case Syntax.VariableDeclaration:\n        result = [stmt.kind]; // special path for\n        // var x = function () {\n        // };\n\n        if (stmt.declarations.length === 1 && stmt.declarations[0].init && stmt.declarations[0].init.type === Syntax.FunctionExpression) {\n          result.push(' ', generateStatement(stmt.declarations[0], {\n            allowIn: allowIn\n          }));\n        } else {\n          // VariableDeclarator is typed as Statement,\n          // but joined with comma (not LineTerminator).\n          // So if comment is attached to target node, we should specialize.\n          withIndent(function () {\n            node = stmt.declarations[0];\n\n            if (extra.comment && node.leadingComments) {\n              result.push('\\n', addIndent(generateStatement(node, {\n                allowIn: allowIn\n              })));\n            } else {\n              result.push(' ', generateStatement(node, {\n                allowIn: allowIn\n              }));\n            }\n\n            for (i = 1, len = stmt.declarations.length; i < len; i += 1) {\n              node = stmt.declarations[i];\n\n              if (extra.comment && node.leadingComments) {\n                result.push(',' + newline, addIndent(generateStatement(node, {\n                  allowIn: allowIn\n                })));\n              } else {\n                result.push(',' + space, generateStatement(node, {\n                  allowIn: allowIn\n                }));\n              }\n            }\n          });\n        }\n\n        result.push(semicolon);\n        break;\n\n      case Syntax.ThrowStatement:\n        result = [join('throw', generateExpression(stmt.argument, {\n          precedence: Precedence.Sequence,\n          allowIn: true,\n          allowCall: true\n        })), semicolon];\n        break;\n\n      case Syntax.TryStatement:\n        result = ['try', maybeBlock(stmt.block)];\n        result = maybeBlockSuffix(stmt.block, result);\n\n        for (i = 0, len = stmt.handlers.length; i < len; i += 1) {\n          result = join(result, generateStatement(stmt.handlers[i]));\n\n          if (stmt.finalizer || i + 1 !== len) {\n            result = maybeBlockSuffix(stmt.handlers[i].body, result);\n          }\n        }\n\n        if (stmt.finalizer) {\n          result = join(result, ['finally', maybeBlock(stmt.finalizer)]);\n        }\n\n        break;\n\n      case Syntax.SwitchStatement:\n        withIndent(function () {\n          result = ['switch' + space + '(', generateExpression(stmt.discriminant, {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: true\n          }), ')' + space + '{' + newline];\n        });\n\n        if (stmt.cases) {\n          for (i = 0, len = stmt.cases.length; i < len; i += 1) {\n            fragment = addIndent(generateStatement(stmt.cases[i], {\n              semicolonOptional: i === len - 1\n            }));\n            result.push(fragment);\n\n            if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {\n              result.push(newline);\n            }\n          }\n        }\n\n        result.push(addIndent('}'));\n        break;\n\n      case Syntax.SwitchCase:\n        withIndent(function () {\n          if (stmt.test) {\n            result = [join('case', generateExpression(stmt.test, {\n              precedence: Precedence.Sequence,\n              allowIn: true,\n              allowCall: true\n            })), ':'];\n          } else {\n            result = ['default:'];\n          }\n\n          i = 0;\n          len = stmt.consequent.length;\n\n          if (len && stmt.consequent[0].type === Syntax.BlockStatement) {\n            fragment = maybeBlock(stmt.consequent[0]);\n            result.push(fragment);\n            i = 1;\n          }\n\n          if (i !== len && !endsWithLineTerminator(toSourceNode(result).toString())) {\n            result.push(newline);\n          }\n\n          for (; i < len; i += 1) {\n            fragment = addIndent(generateStatement(stmt.consequent[i], {\n              semicolonOptional: i === len - 1 && semicolon === ''\n            }));\n            result.push(fragment);\n\n            if (i + 1 !== len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {\n              result.push(newline);\n            }\n          }\n        });\n        break;\n\n      case Syntax.IfStatement:\n        withIndent(function () {\n          result = ['if' + space + '(', generateExpression(stmt.test, {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: true\n          }), ')'];\n        });\n\n        if (stmt.alternate) {\n          result.push(maybeBlock(stmt.consequent));\n          result = maybeBlockSuffix(stmt.consequent, result);\n\n          if (stmt.alternate.type === Syntax.IfStatement) {\n            result = join(result, ['else ', generateStatement(stmt.alternate, {\n              semicolonOptional: semicolon === ''\n            })]);\n          } else {\n            result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));\n          }\n        } else {\n          result.push(maybeBlock(stmt.consequent, semicolon === ''));\n        }\n\n        break;\n\n      case Syntax.ForStatement:\n        withIndent(function () {\n          result = ['for' + space + '('];\n\n          if (stmt.init) {\n            if (stmt.init.type === Syntax.VariableDeclaration) {\n              result.push(generateStatement(stmt.init, {\n                allowIn: false\n              }));\n            } else {\n              result.push(generateExpression(stmt.init, {\n                precedence: Precedence.Sequence,\n                allowIn: false,\n                allowCall: true\n              }), ';');\n            }\n          } else {\n            result.push(';');\n          }\n\n          if (stmt.test) {\n            result.push(space, generateExpression(stmt.test, {\n              precedence: Precedence.Sequence,\n              allowIn: true,\n              allowCall: true\n            }), ';');\n          } else {\n            result.push(';');\n          }\n\n          if (stmt.update) {\n            result.push(space, generateExpression(stmt.update, {\n              precedence: Precedence.Sequence,\n              allowIn: true,\n              allowCall: true\n            }), ')');\n          } else {\n            result.push(')');\n          }\n        });\n        result.push(maybeBlock(stmt.body, semicolon === ''));\n        break;\n\n      case Syntax.ForInStatement:\n        result = ['for' + space + '('];\n        withIndent(function () {\n          if (stmt.left.type === Syntax.VariableDeclaration) {\n            withIndent(function () {\n              result.push(stmt.left.kind + ' ', generateStatement(stmt.left.declarations[0], {\n                allowIn: false\n              }));\n            });\n          } else {\n            result.push(generateExpression(stmt.left, {\n              precedence: Precedence.Call,\n              allowIn: true,\n              allowCall: true\n            }));\n          }\n\n          result = join(result, 'in');\n          result = [join(result, generateExpression(stmt.right, {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: true\n          })), ')'];\n        });\n        result.push(maybeBlock(stmt.body, semicolon === ''));\n        break;\n\n      case Syntax.LabeledStatement:\n        result = [stmt.label.name + ':', maybeBlock(stmt.body, semicolon === '')];\n        break;\n\n      case Syntax.Program:\n        len = stmt.body.length;\n        result = [safeConcatenation && len > 0 ? '\\n' : ''];\n\n        for (i = 0; i < len; i += 1) {\n          fragment = addIndent(generateStatement(stmt.body[i], {\n            semicolonOptional: !safeConcatenation && i === len - 1,\n            directiveContext: true\n          }));\n          result.push(fragment);\n\n          if (i + 1 < len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {\n            result.push(newline);\n          }\n        }\n\n        break;\n\n      case Syntax.FunctionDeclaration:\n        result = [(stmt.generator && !extra.moz.starlessGenerator ? 'function* ' : 'function ') + stmt.id.name, generateFunctionBody(stmt)];\n        break;\n\n      case Syntax.ReturnStatement:\n        if (stmt.argument) {\n          result = [join('return', generateExpression(stmt.argument, {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: true\n          })), semicolon];\n        } else {\n          result = ['return' + semicolon];\n        }\n\n        break;\n\n      case Syntax.WhileStatement:\n        withIndent(function () {\n          result = ['while' + space + '(', generateExpression(stmt.test, {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: true\n          }), ')'];\n        });\n        result.push(maybeBlock(stmt.body, semicolon === ''));\n        break;\n\n      case Syntax.WithStatement:\n        withIndent(function () {\n          result = ['with' + space + '(', generateExpression(stmt.object, {\n            precedence: Precedence.Sequence,\n            allowIn: true,\n            allowCall: true\n          }), ')'];\n        });\n        result.push(maybeBlock(stmt.body, semicolon === ''));\n        break;\n\n      default:\n        throw new Error('Unknown statement type: ' + stmt.type);\n    } // Attach comments\n\n\n    if (extra.comment) {\n      result = addCommentsToStatement(stmt, result);\n    }\n\n    fragment = toSourceNode(result).toString();\n\n    if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\\n') {\n      result = toSourceNode(result).replaceRight(/\\s+$/, '');\n    }\n\n    return toSourceNode(result, stmt);\n  }\n\n  function generate(node, options) {\n    var defaultOptions = getDefaultOptions(),\n        result,\n        pair;\n\n    if (options != null) {\n      // Obsolete options\n      //\n      //   `options.indent`\n      //   `options.base`\n      //\n      // Instead of them, we can use `option.format.indent`.\n      if (typeof options.indent === 'string') {\n        defaultOptions.format.indent.style = options.indent;\n      }\n\n      if (typeof options.base === 'number') {\n        defaultOptions.format.indent.base = options.base;\n      }\n\n      options = updateDeeply(defaultOptions, options);\n      indent = options.format.indent.style;\n\n      if (typeof options.base === 'string') {\n        base = options.base;\n      } else {\n        base = stringRepeat(indent, options.format.indent.base);\n      }\n    } else {\n      options = defaultOptions;\n      indent = options.format.indent.style;\n      base = stringRepeat(indent, options.format.indent.base);\n    }\n\n    json = options.format.json;\n    renumber = options.format.renumber;\n    hexadecimal = json ? false : options.format.hexadecimal;\n    quotes = json ? 'double' : options.format.quotes;\n    escapeless = options.format.escapeless;\n\n    if (options.format.compact) {\n      newline = space = indent = base = '';\n    } else {\n      newline = '\\n';\n      space = ' ';\n    }\n\n    parentheses = options.format.parentheses;\n    semicolons = options.format.semicolons;\n    safeConcatenation = options.format.safeConcatenation;\n    directive = options.directive;\n    parse = json ? null : options.parse;\n    sourceMap = options.sourceMap;\n    extra = options;\n\n    if (sourceMap) {\n      if (!exports.browser) {\n        // We assume environment is node.js\n        // And prevent from including source-map by browserify\n        SourceNode = require('source-map').SourceNode;\n      } else {\n        SourceNode = global.sourceMap.SourceNode;\n      }\n    } else {\n      SourceNode = SourceNodeMock;\n    }\n\n    switch (node.type) {\n      case Syntax.BlockStatement:\n      case Syntax.BreakStatement:\n      case Syntax.CatchClause:\n      case Syntax.ContinueStatement:\n      case Syntax.DirectiveStatement:\n      case Syntax.DoWhileStatement:\n      case Syntax.DebuggerStatement:\n      case Syntax.EmptyStatement:\n      case Syntax.ExpressionStatement:\n      case Syntax.ForStatement:\n      case Syntax.ForInStatement:\n      case Syntax.FunctionDeclaration:\n      case Syntax.IfStatement:\n      case Syntax.LabeledStatement:\n      case Syntax.Program:\n      case Syntax.ReturnStatement:\n      case Syntax.SwitchStatement:\n      case Syntax.SwitchCase:\n      case Syntax.ThrowStatement:\n      case Syntax.TryStatement:\n      case Syntax.VariableDeclaration:\n      case Syntax.VariableDeclarator:\n      case Syntax.WhileStatement:\n      case Syntax.WithStatement:\n        result = generateStatement(node);\n        break;\n\n      case Syntax.AssignmentExpression:\n      case Syntax.ArrayExpression:\n      case Syntax.ArrayPattern:\n      case Syntax.BinaryExpression:\n      case Syntax.CallExpression:\n      case Syntax.ConditionalExpression:\n      case Syntax.FunctionExpression:\n      case Syntax.Identifier:\n      case Syntax.Literal:\n      case Syntax.LogicalExpression:\n      case Syntax.MemberExpression:\n      case Syntax.NewExpression:\n      case Syntax.ObjectExpression:\n      case Syntax.ObjectPattern:\n      case Syntax.Property:\n      case Syntax.SequenceExpression:\n      case Syntax.ThisExpression:\n      case Syntax.UnaryExpression:\n      case Syntax.UpdateExpression:\n      case Syntax.YieldExpression:\n        result = generateExpression(node, {\n          precedence: Precedence.Sequence,\n          allowIn: true,\n          allowCall: true\n        });\n        break;\n\n      default:\n        throw new Error('Unknown node type: ' + node.type);\n    }\n\n    if (!sourceMap) {\n      return result.toString();\n    }\n\n    pair = result.toStringWithSourceMap({\n      file: options.sourceMap,\n      sourceRoot: options.sourceMapRoot\n    });\n\n    if (options.sourceMapWithCode) {\n      return pair;\n    }\n\n    return pair.map.toString();\n  } // simple visitor implementation\n\n\n  VisitorKeys = {\n    AssignmentExpression: ['left', 'right'],\n    ArrayExpression: ['elements'],\n    ArrayPattern: ['elements'],\n    BlockStatement: ['body'],\n    BinaryExpression: ['left', 'right'],\n    BreakStatement: ['label'],\n    CallExpression: ['callee', 'arguments'],\n    CatchClause: ['param', 'body'],\n    ConditionalExpression: ['test', 'consequent', 'alternate'],\n    ContinueStatement: ['label'],\n    DirectiveStatement: [],\n    DoWhileStatement: ['body', 'test'],\n    DebuggerStatement: [],\n    EmptyStatement: [],\n    ExpressionStatement: ['expression'],\n    ForStatement: ['init', 'test', 'update', 'body'],\n    ForInStatement: ['left', 'right', 'body'],\n    FunctionDeclaration: ['id', 'params', 'body'],\n    FunctionExpression: ['id', 'params', 'body'],\n    Identifier: [],\n    IfStatement: ['test', 'consequent', 'alternate'],\n    Literal: [],\n    LabeledStatement: ['label', 'body'],\n    LogicalExpression: ['left', 'right'],\n    MemberExpression: ['object', 'property'],\n    NewExpression: ['callee', 'arguments'],\n    ObjectExpression: ['properties'],\n    ObjectPattern: ['properties'],\n    Program: ['body'],\n    Property: ['key', 'value'],\n    ReturnStatement: ['argument'],\n    SequenceExpression: ['expressions'],\n    SwitchStatement: ['discriminant', 'cases'],\n    SwitchCase: ['test', 'consequent'],\n    ThisExpression: [],\n    ThrowStatement: ['argument'],\n    TryStatement: ['block', 'handlers', 'finalizer'],\n    UnaryExpression: ['argument'],\n    UpdateExpression: ['argument'],\n    VariableDeclaration: ['declarations'],\n    VariableDeclarator: ['id', 'init'],\n    WhileStatement: ['test', 'body'],\n    WithStatement: ['object', 'body'],\n    YieldExpression: ['argument']\n  };\n  VisitorOption = {\n    Break: 1,\n    Skip: 2\n  }; // based on LLVM libc++ upper_bound / lower_bound\n  // MIT License\n\n  function upperBound(array, func) {\n    var diff, len, i, current;\n    len = array.length;\n    i = 0;\n\n    while (len) {\n      diff = len >>> 1;\n      current = i + diff;\n\n      if (func(array[current])) {\n        len = diff;\n      } else {\n        i = current + 1;\n        len -= diff + 1;\n      }\n    }\n\n    return i;\n  }\n\n  function lowerBound(array, func) {\n    var diff, len, i, current;\n    len = array.length;\n    i = 0;\n\n    while (len) {\n      diff = len >>> 1;\n      current = i + diff;\n\n      if (func(array[current])) {\n        i = current + 1;\n        len -= diff + 1;\n      } else {\n        len = diff;\n      }\n    }\n\n    return i;\n  }\n\n  function extendCommentRange(comment, tokens) {\n    var target, token;\n    target = upperBound(tokens, function search(token) {\n      return token.range[0] > comment.range[0];\n    });\n    comment.extendedRange = [comment.range[0], comment.range[1]];\n\n    if (target !== tokens.length) {\n      comment.extendedRange[1] = tokens[target].range[0];\n    }\n\n    target -= 1;\n\n    if (target >= 0) {\n      if (target < tokens.length) {\n        comment.extendedRange[0] = tokens[target].range[1];\n      } else if (token.length) {\n        comment.extendedRange[1] = tokens[tokens.length - 1].range[0];\n      }\n    }\n\n    return comment;\n  }\n\n  function attachComments(tree, providedComments, tokens) {\n    // At first, we should calculate extended comment ranges.\n    var comments = [],\n        comment,\n        len,\n        i;\n\n    if (!tree.range) {\n      throw new Error('attachComments needs range information');\n    } // tokens array is empty, we attach comments to tree as 'leadingComments'\n\n\n    if (!tokens.length) {\n      if (providedComments.length) {\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n          comment = deepCopy(providedComments[i]);\n          comment.extendedRange = [0, tree.range[0]];\n          comments.push(comment);\n        }\n\n        tree.leadingComments = comments;\n      }\n\n      return tree;\n    }\n\n    for (i = 0, len = providedComments.length; i < len; i += 1) {\n      comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n    } // This is based on John Freeman's implementation.\n\n\n    traverse(tree, {\n      cursor: 0,\n      enter: function (node) {\n        var comment;\n\n        while (this.cursor < comments.length) {\n          comment = comments[this.cursor];\n\n          if (comment.extendedRange[1] > node.range[0]) {\n            break;\n          }\n\n          if (comment.extendedRange[1] === node.range[0]) {\n            if (!node.leadingComments) {\n              node.leadingComments = [];\n            }\n\n            node.leadingComments.push(comment);\n            comments.splice(this.cursor, 1);\n          } else {\n            this.cursor += 1;\n          }\n        } // already out of owned node\n\n\n        if (this.cursor === comments.length) {\n          return VisitorOption.Break;\n        }\n\n        if (comments[this.cursor].extendedRange[0] > node.range[1]) {\n          return VisitorOption.Skip;\n        }\n      }\n    });\n    traverse(tree, {\n      cursor: 0,\n      leave: function (node) {\n        var comment;\n\n        while (this.cursor < comments.length) {\n          comment = comments[this.cursor];\n\n          if (node.range[1] < comment.extendedRange[0]) {\n            break;\n          }\n\n          if (node.range[1] === comment.extendedRange[0]) {\n            if (!node.trailingComments) {\n              node.trailingComments = [];\n            }\n\n            node.trailingComments.push(comment);\n            comments.splice(this.cursor, 1);\n          } else {\n            this.cursor += 1;\n          }\n        } // already out of owned node\n\n\n        if (this.cursor === comments.length) {\n          return VisitorOption.Break;\n        }\n\n        if (comments[this.cursor].extendedRange[0] > node.range[1]) {\n          return VisitorOption.Skip;\n        }\n      }\n    });\n    return tree;\n  }\n\n  exports.version = require('./package.json').version;\n  exports.generate = generate;\n  exports.attachComments = attachComments;\n  exports.browser = false;\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"sources":["/home/elvis/Documents/GitHub/medbase/mern-auth/node_modules/escodegen/escodegen.js"],"names":["Syntax","Precedence","BinaryPrecedence","Regex","VisitorKeys","VisitorOption","SourceNode","isArray","base","indent","json","renumber","hexadecimal","quotes","escapeless","newline","space","parentheses","semicolons","safeConcatenation","directive","extra","parse","sourceMap","traverse","require","AssignmentExpression","ArrayExpression","ArrayPattern","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ComprehensionBlock","ComprehensionExpression","ConditionalExpression","ContinueStatement","DirectiveStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExpressionStatement","ForStatement","ForInStatement","FunctionDeclaration","FunctionExpression","Identifier","IfStatement","Literal","LabeledStatement","LogicalExpression","MemberExpression","NewExpression","ObjectExpression","ObjectPattern","Program","Property","ReturnStatement","SequenceExpression","SwitchStatement","SwitchCase","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","Sequence","Assignment","Conditional","LogicalOR","LogicalAND","BitwiseOR","BitwiseXOR","BitwiseAND","Equality","Relational","BitwiseSHIFT","Additive","Multiplicative","Unary","Postfix","Call","New","Member","Primary","NonAsciiIdentifierPart","RegExp","getDefaultOptions","comment","format","style","adjustMultilineComment","compact","moz","starlessGenerator","parenthesizedComprehensionBlock","sourceMapRoot","sourceMapWithCode","verbatim","stringToArray","str","length","result","i","charAt","stringRepeat","num","Array","array","Object","prototype","toString","call","SourceNodeMock","line","column","filename","chunk","flatten","input","iz","push","children","res","node","replaceRight","pattern","replacement","last","replace","join","sep","hasLineTerminator","test","endsWithLineTerminator","ch","shallowCopy","obj","ret","key","hasOwnProperty","deepCopy","val","updateDeeply","target","override","isHashObject","generateNumber","value","point","temp","exponent","pos","Error","indexOf","slice","Math","floor","escapeRegExpCharacter","previousIsBackslash","String","fromCharCode","generateRegExp","reg","match","flags","characterInBrack","source","charCodeAt","escapeAllowedCharacter","next","code","hex","escapeDisallowedCharacter","escapeDirective","single","buf","quote","escapeString","len","singleQuotes","doubleQuotes","isWhiteSpace","isLineTerminator","isIdentifierPart","toSourceNode","generated","loc","start","left","right","leftSource","rightSource","leftChar","rightChar","addIndent","stmt","withIndent","fn","previousBase","calculateSpaces","specialBase","j","spaces","split","Number","MAX_VALUE","generateComment","type","addCommentsToStatement","save","tailingToStatement","fragment","leadingComments","body","trailingComments","parenthesize","text","current","should","maybeBlock","semicolonOptional","functionBody","noLeadingComment","generateStatement","maybeBlockSuffix","ends","generateVerbatim","expr","option","precedence","generateFunctionBody","params","name","expression","generateExpression","allowIn","allowCall","currentPrecedence","raw","multiline","allowUnparenthesizedNew","property","expressions","operator","consequent","alternate","callee","undefined","object","computed","argument","delegate","prefix","id","elements","kind","shorthand","method","generator","properties","e","blocks","filter","declarations","of","directiveContext","semicolon","label","param","init","block","handlers","finalizer","discriminant","cases","update","generate","options","defaultOptions","pair","exports","browser","global","toStringWithSourceMap","file","sourceRoot","map","Break","Skip","upperBound","func","diff","lowerBound","extendCommentRange","tokens","token","search","range","extendedRange","attachComments","tree","providedComments","comments","cursor","enter","splice","leave","version"],"mappings":"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","sourcesContent":["/*\n  Copyright (C) 2012 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true */\n/*global escodegen:true, exports:true, generateStatement:true, generateExpression:true, generateFunctionBody:true, process:true, require:true, define:true, global:true*/\n(function () {\n    'use strict';\n\n    var Syntax,\n        Precedence,\n        BinaryPrecedence,\n        Regex,\n        VisitorKeys,\n        VisitorOption,\n        SourceNode,\n        isArray,\n        base,\n        indent,\n        json,\n        renumber,\n        hexadecimal,\n        quotes,\n        escapeless,\n        newline,\n        space,\n        parentheses,\n        semicolons,\n        safeConcatenation,\n        directive,\n        extra,\n        parse,\n        sourceMap,\n        traverse;\n\n    traverse = require('estraverse').traverse;\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ComprehensionBlock: 'ComprehensionBlock',\n        ComprehensionExpression: 'ComprehensionExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n\n    };\n\n    Precedence = {\n        Sequence: 0,\n        Assignment: 1,\n        Conditional: 2,\n        LogicalOR: 3,\n        LogicalAND: 4,\n        BitwiseOR: 5,\n        BitwiseXOR: 6,\n        BitwiseAND: 7,\n        Equality: 8,\n        Relational: 9,\n        BitwiseSHIFT: 10,\n        Additive: 11,\n        Multiplicative: 12,\n        Unary: 13,\n        Postfix: 14,\n        Call: 15,\n        New: 16,\n        Member: 17,\n        Primary: 18\n    };\n\n    BinaryPrecedence = {\n        '||': Precedence.LogicalOR,\n        '&&': Precedence.LogicalAND,\n        '|': Precedence.BitwiseOR,\n        '^': Precedence.BitwiseXOR,\n        '&': Precedence.BitwiseAND,\n        '==': Precedence.Equality,\n        '!=': Precedence.Equality,\n        '===': Precedence.Equality,\n        '!==': Precedence.Equality,\n        'is': Precedence.Equality,\n        'isnt': Precedence.Equality,\n        '<': Precedence.Relational,\n        '>': Precedence.Relational,\n        '<=': Precedence.Relational,\n        '>=': Precedence.Relational,\n        'in': Precedence.Relational,\n        'instanceof': Precedence.Relational,\n        '<<': Precedence.BitwiseSHIFT,\n        '>>': Precedence.BitwiseSHIFT,\n        '>>>': Precedence.BitwiseSHIFT,\n        '+': Precedence.Additive,\n        '-': Precedence.Additive,\n        '*': Precedence.Multiplicative,\n        '%': Precedence.Multiplicative,\n        '/': Precedence.Multiplicative\n    };\n\n    Regex = {\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n    };\n\n    function getDefaultOptions() {\n        // default options\n        return {\n            indent: null,\n            base: null,\n            parse: null,\n            comment: false,\n            format: {\n                indent: {\n                    style: '    ',\n                    base: 0,\n                    adjustMultilineComment: false\n                },\n                json: false,\n                renumber: false,\n                hexadecimal: false,\n                quotes: 'single',\n                escapeless: false,\n                compact: false,\n                parentheses: true,\n                semicolons: true,\n                safeConcatenation: false\n            },\n            moz: {\n                starlessGenerator: false,\n                parenthesizedComprehensionBlock: false\n            },\n            sourceMap: null,\n            sourceMapRoot: null,\n            sourceMapWithCode: false,\n            directive: false,\n            verbatim: null\n        };\n    }\n\n    function stringToArray(str) {\n        var length = str.length,\n            result = [],\n            i;\n        for (i = 0; i < length; i += 1) {\n            result[i] = str.charAt(i);\n        }\n        return result;\n    }\n\n    function stringRepeat(str, num) {\n        var result = '';\n\n        for (num |= 0; num > 0; num >>>= 1, str += str) {\n            if (num & 1) {\n                result += str;\n            }\n        }\n\n        return result;\n    }\n\n    isArray = Array.isArray;\n    if (!isArray) {\n        isArray = function isArray(array) {\n            return Object.prototype.toString.call(array) === '[object Array]';\n        };\n    }\n\n    // Fallback for the non SourceMap environment\n    function SourceNodeMock(line, column, filename, chunk) {\n        var result = [];\n\n        function flatten(input) {\n            var i, iz;\n            if (isArray(input)) {\n                for (i = 0, iz = input.length; i < iz; ++i) {\n                    flatten(input[i]);\n                }\n            } else if (input instanceof SourceNodeMock) {\n                result.push(input);\n            } else if (typeof input === 'string' && input) {\n                result.push(input);\n            }\n        }\n\n        flatten(chunk);\n        this.children = result;\n    }\n\n    SourceNodeMock.prototype.toString = function toString() {\n        var res = '', i, iz, node;\n        for (i = 0, iz = this.children.length; i < iz; ++i) {\n            node = this.children[i];\n            if (node instanceof SourceNodeMock) {\n                res += node.toString();\n            } else {\n                res += node;\n            }\n        }\n        return res;\n    };\n\n    SourceNodeMock.prototype.replaceRight = function replaceRight(pattern, replacement) {\n        var last = this.children[this.children.length - 1];\n        if (last instanceof SourceNodeMock) {\n            last.replaceRight(pattern, replacement);\n        } else if (typeof last === 'string') {\n            this.children[this.children.length - 1] = last.replace(pattern, replacement);\n        } else {\n            this.children.push(''.replace(pattern, replacement));\n        }\n        return this;\n    };\n\n    SourceNodeMock.prototype.join = function join(sep) {\n        var i, iz, result;\n        result = [];\n        iz = this.children.length;\n        if (iz > 0) {\n            for (i = 0, iz -= 1; i < iz; ++i) {\n                result.push(this.children[i], sep);\n            }\n            result.push(this.children[iz]);\n            this.children = result;\n        }\n        return this;\n    };\n\n    function hasLineTerminator(str) {\n        return (/[\\r\\n]/g).test(str);\n    }\n\n    function endsWithLineTerminator(str) {\n        var ch = str.charAt(str.length - 1);\n        return ch === '\\r' || ch === '\\n';\n    }\n\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    function updateDeeply(target, override) {\n        var key, val;\n\n        function isHashObject(target) {\n            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\n        }\n\n        for (key in override) {\n            if (override.hasOwnProperty(key)) {\n                val = override[key];\n                if (isHashObject(val)) {\n                    if (isHashObject(target[key])) {\n                        updateDeeply(target[key], val);\n                    } else {\n                        target[key] = updateDeeply({}, val);\n                    }\n                } else {\n                    target[key] = val;\n                }\n            }\n        }\n        return target;\n    }\n\n    function generateNumber(value) {\n        var result, point, temp, exponent, pos;\n\n        if (value !== value) {\n            throw new Error('Numeric literal whose value is NaN');\n        }\n        if (value < 0 || (value === 0 && 1 / value < 0)) {\n            throw new Error('Numeric literal whose value is negative');\n        }\n\n        if (value === 1 / 0) {\n            return json ? 'null' : renumber ? '1e400' : '1e+400';\n        }\n\n        result = '' + value;\n        if (!renumber || result.length < 3) {\n            return result;\n        }\n\n        point = result.indexOf('.');\n        if (!json && result.charAt(0) === '0' && point === 1) {\n            point = 0;\n            result = result.slice(1);\n        }\n        temp = result;\n        result = result.replace('e+', 'e');\n        exponent = 0;\n        if ((pos = temp.indexOf('e')) > 0) {\n            exponent = +temp.slice(pos + 1);\n            temp = temp.slice(0, pos);\n        }\n        if (point >= 0) {\n            exponent -= temp.length - point - 1;\n            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';\n        }\n        pos = 0;\n        while (temp.charAt(temp.length + pos - 1) === '0') {\n            pos -= 1;\n        }\n        if (pos !== 0) {\n            exponent -= pos;\n            temp = temp.slice(0, pos);\n        }\n        if (exponent !== 0) {\n            temp += 'e' + exponent;\n        }\n        if ((temp.length < result.length ||\n                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&\n                +temp === value) {\n            result = temp;\n        }\n\n        return result;\n    }\n\n    // Generate valid RegExp expression.\n    // This function is based on https://github.com/Constellation/iv Engine\n\n    function escapeRegExpCharacter(ch, previousIsBackslash) {\n        // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n        if ((ch & ~1) === 0x2028) {\n            return (previousIsBackslash ? 'u' : '\\\\u') + ((ch === 0x2028) ? '2028' : '2029');\n        } else if (ch === 10 || ch === 13) {  // \\n, \\r\n            return (previousIsBackslash ? '' : '\\\\') + ((ch === 10) ? 'n' : 'r');\n        }\n        return String.fromCharCode(ch);\n    }\n\n    function generateRegExp(reg) {\n        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n\n        result = reg.toString();\n\n        if (reg.source) {\n            // extract flag from toString result\n            match = result.match(/\\/([^/]*)$/);\n            if (!match) {\n                return result;\n            }\n\n            flags = match[1];\n            result = '';\n\n            characterInBrack = false;\n            previousIsBackslash = false;\n            for (i = 0, iz = reg.source.length; i < iz; ++i) {\n                ch = reg.source.charCodeAt(i);\n\n                if (!previousIsBackslash) {\n                    if (characterInBrack) {\n                        if (ch === 93) {  // ]\n                            characterInBrack = false;\n                        }\n                    } else {\n                        if (ch === 47) {  // /\n                            result += '\\\\';\n                        } else if (ch === 91) {  // [\n                            characterInBrack = true;\n                        }\n                    }\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    previousIsBackslash = ch === 92;  // \\\n                } else {\n                    // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    // prevent like /\\\\[/]/\n                    previousIsBackslash = false;\n                }\n            }\n\n            return '/' + result + '/' + flags;\n        }\n\n        return result;\n    }\n\n    function escapeAllowedCharacter(ch, next) {\n        var code = ch.charCodeAt(0), hex = code.toString(16), result = '\\\\';\n\n        switch (ch) {\n        case '\\b':\n            result += 'b';\n            break;\n        case '\\f':\n            result += 'f';\n            break;\n        case '\\t':\n            result += 't';\n            break;\n        default:\n            if (json || code > 0xff) {\n                result += 'u' + '0000'.slice(hex.length) + hex;\n            } else if (ch === '\\u0000' && '0123456789'.indexOf(next) < 0) {\n                result += '0';\n            } else if (ch === '\\x0B') { // '\\v'\n                result += 'x0B';\n            } else {\n                result += 'x' + '00'.slice(hex.length) + hex;\n            }\n            break;\n        }\n\n        return result;\n    }\n\n    function escapeDisallowedCharacter(ch) {\n        var result = '\\\\';\n        switch (ch) {\n        case '\\\\':\n            result += '\\\\';\n            break;\n        case '\\n':\n            result += 'n';\n            break;\n        case '\\r':\n            result += 'r';\n            break;\n        case '\\u2028':\n            result += 'u2028';\n            break;\n        case '\\u2029':\n            result += 'u2029';\n            break;\n        default:\n            throw new Error('Incorrectly classified character');\n        }\n\n        return result;\n    }\n\n    function escapeDirective(str) {\n        var i, iz, ch, single, buf, quote;\n\n        buf = str;\n        if (typeof buf[0] === 'undefined') {\n            buf = stringToArray(buf);\n        }\n\n        quote = quotes === 'double' ? '\"' : '\\'';\n        for (i = 0, iz = buf.length; i < iz; i += 1) {\n            ch = buf[i];\n            if (ch === '\\'') {\n                quote = '\"';\n                break;\n            } else if (ch === '\"') {\n                quote = '\\'';\n                break;\n            } else if (ch === '\\\\') {\n                i += 1;\n            }\n        }\n\n        return quote + str + quote;\n    }\n\n    function escapeString(str) {\n        var result = '', i, len, ch, next, singleQuotes = 0, doubleQuotes = 0, single;\n\n        if (typeof str[0] === 'undefined') {\n            str = stringToArray(str);\n        }\n\n        for (i = 0, len = str.length; i < len; i += 1) {\n            ch = str[i];\n            if (ch === '\\'') {\n                singleQuotes += 1;\n            } else if (ch === '\"') {\n                doubleQuotes += 1;\n            } else if (ch === '/' && json) {\n                result += '\\\\';\n            } else if ('\\\\\\n\\r\\u2028\\u2029'.indexOf(ch) >= 0) {\n                result += escapeDisallowedCharacter(ch);\n                continue;\n            } else if ((json && ch < ' ') || !(json || escapeless || (ch >= ' ' && ch <= '~'))) {\n                result += escapeAllowedCharacter(ch, str[i + 1]);\n                continue;\n            }\n            result += ch;\n        }\n\n        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));\n        str = result;\n        result = single ? '\\'' : '\"';\n\n        if (typeof str[0] === 'undefined') {\n            str = stringToArray(str);\n        }\n\n        for (i = 0, len = str.length; i < len; i += 1) {\n            ch = str[i];\n            if ((ch === '\\'' && single) || (ch === '\"' && !single)) {\n                result += '\\\\';\n            }\n            result += ch;\n        }\n\n        return result + (single ? '\\'' : '\"');\n    }\n\n    function isWhiteSpace(ch) {\n        // Use `\\x0B` instead of `\\v` for IE < 9 compatibility\n        return '\\t\\x0B\\f \\xa0'.indexOf(ch) >= 0 || (ch.charCodeAt(0) >= 0x1680 && '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\ufeff'.indexOf(ch) >= 0);\n    }\n\n    function isLineTerminator(ch) {\n        return '\\n\\r\\u2028\\u2029'.indexOf(ch) >= 0;\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === '$') || (ch === '_') || (ch === '\\\\') ||\n            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n            ((ch >= '0') && (ch <= '9')) ||\n            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));\n    }\n\n    function toSourceNode(generated, node) {\n        if (node == null) {\n            if (generated instanceof SourceNode) {\n                return generated;\n            } else {\n                node = {};\n            }\n        }\n        if (node.loc == null) {\n            return new SourceNode(null, null, sourceMap, generated);\n        }\n        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated);\n    }\n\n    function join(left, right) {\n        var leftSource = toSourceNode(left).toString(),\n            rightSource = toSourceNode(right).toString(),\n            leftChar = leftSource.charAt(leftSource.length - 1),\n            rightChar = rightSource.charAt(0);\n\n        if (((leftChar === '+' || leftChar === '-') && leftChar === rightChar) || (isIdentifierPart(leftChar) && isIdentifierPart(rightChar))) {\n            return [left, ' ', right];\n        } else if (isWhiteSpace(leftChar) || isLineTerminator(leftChar) || isWhiteSpace(rightChar) || isLineTerminator(rightChar)) {\n            return [left, right];\n        }\n        return [left, space, right];\n    }\n\n    function addIndent(stmt) {\n        return [base, stmt];\n    }\n\n    function withIndent(fn) {\n        var previousBase, result;\n        previousBase = base;\n        base += indent;\n        result = fn.call(this, base);\n        base = previousBase;\n        return result;\n    }\n\n    function calculateSpaces(str) {\n        var i;\n        for (i = str.length - 1; i >= 0; i -= 1) {\n            if (isLineTerminator(str.charAt(i))) {\n                break;\n            }\n        }\n        return (str.length - 1) - i;\n    }\n\n    function adjustMultilineComment(value, specialBase) {\n        var array, i, len, line, j, ch, spaces, previousBase;\n\n        array = value.split(/\\r\\n|[\\r\\n]/);\n        spaces = Number.MAX_VALUE;\n\n        // first line doesn't have indentation\n        for (i = 1, len = array.length; i < len; i += 1) {\n            line = array[i];\n            j = 0;\n            while (j < line.length && isWhiteSpace(line[j])) {\n                j += 1;\n            }\n            if (spaces > j) {\n                spaces = j;\n            }\n        }\n\n        if (typeof specialBase !== 'undefined') {\n            // pattern like\n            // {\n            //   var t = 20;  /*\n            //                 * this is comment\n            //                 */\n            // }\n            previousBase = base;\n            if (array[1][spaces] === '*') {\n                specialBase += ' ';\n            }\n            base = specialBase;\n        } else {\n            if (spaces & 1) {\n                // /*\n                //  *\n                //  */\n                // If spaces are odd number, above pattern is considered.\n                // We waste 1 space.\n                spaces -= 1;\n            }\n            previousBase = base;\n        }\n\n        for (i = 1, len = array.length; i < len; i += 1) {\n            array[i] = toSourceNode(addIndent(array[i].slice(spaces))).join('');\n        }\n\n        base = previousBase;\n\n        return array.join('\\n');\n    }\n\n    function generateComment(comment, specialBase) {\n        if (comment.type === 'Line') {\n            if (endsWithLineTerminator(comment.value)) {\n                return '//' + comment.value;\n            } else {\n                // Always use LineTerminator\n                return '//' + comment.value + '\\n';\n            }\n        }\n        if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);\n        }\n        return '/*' + comment.value + '*/';\n    }\n\n    function addCommentsToStatement(stmt, result) {\n        var i, len, comment, save, node, tailingToStatement, specialBase, fragment;\n\n        if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n            save = result;\n\n            comment = stmt.leadingComments[0];\n            result = [];\n            if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n                result.push('\\n');\n            }\n            result.push(generateComment(comment));\n            if (!endsWithLineTerminator(toSourceNode(result).toString())) {\n                result.push('\\n');\n            }\n\n            for (i = 1, len = stmt.leadingComments.length; i < len; i += 1) {\n                comment = stmt.leadingComments[i];\n                fragment = [generateComment(comment)];\n                if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {\n                    fragment.push('\\n');\n                }\n                result.push(addIndent(fragment));\n            }\n\n            result.push(addIndent(save));\n        }\n\n        if (stmt.trailingComments) {\n            tailingToStatement = !endsWithLineTerminator(toSourceNode(result).toString());\n            specialBase = stringRepeat(' ', calculateSpaces(toSourceNode([base, result, indent]).toString()));\n            for (i = 0, len = stmt.trailingComments.length; i < len; i += 1) {\n                comment = stmt.trailingComments[i];\n                if (tailingToStatement) {\n                    // We assume target like following script\n                    //\n                    // var t = 20;  /**\n                    //               * This is comment of t\n                    //               */\n                    if (i === 0) {\n                        // first case\n                        result = [result, indent];\n                    } else {\n                        result = [result, specialBase];\n                    }\n                    result.push(generateComment(comment, specialBase));\n                } else {\n                    result = [result, addIndent(generateComment(comment))];\n                }\n                if (i !== len - 1 && !endsWithLineTerminator(toSourceNode(result).toString())) {\n                    result = [result, '\\n'];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    function parenthesize(text, current, should) {\n        if (current < should) {\n            return ['(', text, ')'];\n        }\n        return text;\n    }\n\n    function maybeBlock(stmt, semicolonOptional, functionBody) {\n        var result, noLeadingComment;\n\n        noLeadingComment = !extra.comment || !stmt.leadingComments;\n\n        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n            return [space, generateStatement(stmt, { functionBody: functionBody })];\n        }\n\n        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n            return ';';\n        }\n\n        withIndent(function () {\n            result = [newline, addIndent(generateStatement(stmt, { semicolonOptional: semicolonOptional, functionBody: functionBody }))];\n        });\n\n        return result;\n    }\n\n    function maybeBlockSuffix(stmt, result) {\n        var ends = endsWithLineTerminator(toSourceNode(result).toString());\n        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n            return [result, space];\n        }\n        if (ends) {\n            return [result, base];\n        }\n        return [result, newline, base];\n    }\n\n    function generateVerbatim(expr, option) {\n        var i, result;\n        result = expr[extra.verbatim].split(/\\r\\n|\\n/);\n        for (i = 1; i < result.length; i++) {\n            result[i] = newline + base + result[i];\n        }\n\n        result = parenthesize(result, Precedence.Sequence, option.precedence);\n        return toSourceNode(result, expr);\n    }\n\n    function generateFunctionBody(node) {\n        var result, i, len, expr;\n        result = ['('];\n        for (i = 0, len = node.params.length; i < len; i += 1) {\n            result.push(node.params[i].name);\n            if (i + 1 < len) {\n                result.push(',' + space);\n            }\n        }\n        result.push(')');\n\n        if (node.expression) {\n            result.push(space);\n            expr = generateExpression(node.body, {\n                precedence: Precedence.Assignment,\n                allowIn: true,\n                allowCall: true\n            });\n            if (expr.toString().charAt(0) === '{') {\n                expr = ['(', expr, ')'];\n            }\n            result.push(expr);\n        } else {\n            result.push(maybeBlock(node.body, false, true));\n        }\n        return result;\n    }\n\n    function generateExpression(expr, option) {\n        var result, precedence, type, currentPrecedence, i, len, raw, fragment, multiline, leftChar, leftSource, rightChar, rightSource, allowIn, allowCall, allowUnparenthesizedNew, property, key, value;\n\n        precedence = option.precedence;\n        allowIn = option.allowIn;\n        allowCall = option.allowCall;\n        type = expr.type || option.type;\n\n        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n            return generateVerbatim(expr, option);\n        }\n\n        switch (type) {\n        case Syntax.SequenceExpression:\n            result = [];\n            allowIn |= (Precedence.Sequence < precedence);\n            for (i = 0, len = expr.expressions.length; i < len; i += 1) {\n                result.push(generateExpression(expr.expressions[i], {\n                    precedence: Precedence.Assignment,\n                    allowIn: allowIn,\n                    allowCall: true\n                }));\n                if (i + 1 < len) {\n                    result.push(',' + space);\n                }\n            }\n            result = parenthesize(result, Precedence.Sequence, precedence);\n            break;\n\n        case Syntax.AssignmentExpression:\n            allowIn |= (Precedence.Assignment < precedence);\n            result = parenthesize(\n                [\n                    generateExpression(expr.left, {\n                        precedence: Precedence.Call,\n                        allowIn: allowIn,\n                        allowCall: true\n                    }),\n                    space + expr.operator + space,\n                    generateExpression(expr.right, {\n                        precedence: Precedence.Assignment,\n                        allowIn: allowIn,\n                        allowCall: true\n                    })\n                ],\n                Precedence.Assignment,\n                precedence\n            );\n            break;\n\n        case Syntax.ConditionalExpression:\n            allowIn |= (Precedence.Conditional < precedence);\n            result = parenthesize(\n                [\n                    generateExpression(expr.test, {\n                        precedence: Precedence.LogicalOR,\n                        allowIn: allowIn,\n                        allowCall: true\n                    }),\n                    space + '?' + space,\n                    generateExpression(expr.consequent, {\n                        precedence: Precedence.Assignment,\n                        allowIn: allowIn,\n                        allowCall: true\n                    }),\n                    space + ':' + space,\n                    generateExpression(expr.alternate, {\n                        precedence: Precedence.Assignment,\n                        allowIn: allowIn,\n                        allowCall: true\n                    })\n                ],\n                Precedence.Conditional,\n                precedence\n            );\n            break;\n\n        case Syntax.LogicalExpression:\n        case Syntax.BinaryExpression:\n            currentPrecedence = BinaryPrecedence[expr.operator];\n\n            allowIn |= (currentPrecedence < precedence);\n\n            fragment = generateExpression(expr.left, {\n                precedence: currentPrecedence,\n                allowIn: allowIn,\n                allowCall: true\n            });\n\n            leftSource = fragment.toString();\n\n            if (leftSource.charAt(leftSource.length - 1) === '/' && isIdentifierPart(expr.operator.charAt(0))) {\n                result = [fragment, ' ', expr.operator];\n            } else {\n                result = join(fragment, expr.operator);\n            }\n\n            fragment = generateExpression(expr.right, {\n                precedence: currentPrecedence + 1,\n                allowIn: allowIn,\n                allowCall: true\n            });\n\n            if (expr.operator === '/' && fragment.toString().charAt(0) === '/') {\n                // If '/' concats with '/', it is interpreted as comment start\n                result.push(' ', fragment);\n            } else {\n                result = join(result, fragment);\n            }\n\n            if (expr.operator === 'in' && !allowIn) {\n                result = ['(', result, ')'];\n            } else {\n                result = parenthesize(result, currentPrecedence, precedence);\n            }\n\n            break;\n\n        case Syntax.CallExpression:\n            result = [generateExpression(expr.callee, {\n                precedence: Precedence.Call,\n                allowIn: true,\n                allowCall: true,\n                allowUnparenthesizedNew: false\n            })];\n\n            result.push('(');\n            for (i = 0, len = expr['arguments'].length; i < len; i += 1) {\n                result.push(generateExpression(expr['arguments'][i], {\n                    precedence: Precedence.Assignment,\n                    allowIn: true,\n                    allowCall: true\n                }));\n                if (i + 1 < len) {\n                    result.push(',' + space);\n                }\n            }\n            result.push(')');\n\n            if (!allowCall) {\n                result = ['(', result, ')'];\n            } else {\n                result = parenthesize(result, Precedence.Call, precedence);\n            }\n            break;\n\n        case Syntax.NewExpression:\n            len = expr['arguments'].length;\n            allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;\n\n            result = join(\n                'new',\n                generateExpression(expr.callee, {\n                    precedence: Precedence.New,\n                    allowIn: true,\n                    allowCall: false,\n                    allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0\n                })\n            );\n\n            if (!allowUnparenthesizedNew || parentheses || len > 0) {\n                result.push('(');\n                for (i = 0; i < len; i += 1) {\n                    result.push(generateExpression(expr['arguments'][i], {\n                        precedence: Precedence.Assignment,\n                        allowIn: true,\n                        allowCall: true\n                    }));\n                    if (i + 1 < len) {\n                        result.push(',' + space);\n                    }\n                }\n                result.push(')');\n            }\n\n            result = parenthesize(result, Precedence.New, precedence);\n            break;\n\n        case Syntax.MemberExpression:\n            result = [generateExpression(expr.object, {\n                precedence: Precedence.Call,\n                allowIn: true,\n                allowCall: allowCall,\n                allowUnparenthesizedNew: false\n            })];\n\n            if (expr.computed) {\n                result.push('[', generateExpression(expr.property, {\n                    precedence: Precedence.Sequence,\n                    allowIn: true,\n                    allowCall: allowCall\n                }), ']');\n            } else {\n                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {\n                    if (result.indexOf('.') < 0) {\n                        if (!/[eExX]/.test(result) && !(result.length >= 2 && result[0] === '0')) {\n                            result.push('.');\n                        }\n                    }\n                }\n                result.push('.' + expr.property.name);\n            }\n\n            result = parenthesize(result, Precedence.Member, precedence);\n            break;\n\n        case Syntax.UnaryExpression:\n            fragment = generateExpression(expr.argument, {\n                precedence: Precedence.Unary,\n                allowIn: true,\n                allowCall: true\n            });\n\n            if (space === '') {\n                result = join(expr.operator, fragment);\n            } else {\n                result = [expr.operator];\n                if (expr.operator.length > 2) {\n                    // delete, void, typeof\n                    // get `typeof []`, not `typeof[]`\n                    result = join(result, fragment);\n                } else {\n                    // Prevent inserting spaces between operator and argument if it is unnecessary\n                    // like, `!cond`\n                    leftSource = toSourceNode(result).toString();\n                    leftChar = leftSource.charAt(leftSource.length - 1);\n                    rightChar = fragment.toString().charAt(0);\n\n                    if (((leftChar === '+' || leftChar === '-') && leftChar === rightChar) || (isIdentifierPart(leftChar) && isIdentifierPart(rightChar))) {\n                        result.push(' ', fragment);\n                    } else {\n                        result.push(fragment);\n                    }\n                }\n            }\n            result = parenthesize(result, Precedence.Unary, precedence);\n            break;\n\n        case Syntax.YieldExpression:\n            if (expr.delegate) {\n                result = 'yield*';\n            } else {\n                result = 'yield';\n            }\n            if (expr.argument) {\n                result = join(\n                    result,\n                    generateExpression(expr.argument, {\n                        precedence: Precedence.Assignment,\n                        allowIn: true,\n                        allowCall: true\n                    })\n                );\n            }\n            break;\n\n        case Syntax.UpdateExpression:\n            if (expr.prefix) {\n                result = parenthesize(\n                    [\n                        expr.operator,\n                        generateExpression(expr.argument, {\n                            precedence: Precedence.Unary,\n                            allowIn: true,\n                            allowCall: true\n                        })\n                    ],\n                    Precedence.Unary,\n                    precedence\n                );\n            } else {\n                result = parenthesize(\n                    [\n                        generateExpression(expr.argument, {\n                            precedence: Precedence.Postfix,\n                            allowIn: true,\n                            allowCall: true\n                        }),\n                        expr.operator\n                    ],\n                    Precedence.Postfix,\n                    precedence\n                );\n            }\n            break;\n\n        case Syntax.FunctionExpression:\n            result = 'function';\n            if (expr.id) {\n                result += ' ' + expr.id.name;\n            } else {\n                result += space;\n            }\n\n            result = [result, generateFunctionBody(expr)];\n            break;\n\n        case Syntax.ArrayPattern:\n        case Syntax.ArrayExpression:\n            if (!expr.elements.length) {\n                result = '[]';\n                break;\n            }\n            multiline = expr.elements.length > 1;\n            result = ['[', multiline ? newline : ''];\n            withIndent(function (indent) {\n                for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                    if (!expr.elements[i]) {\n                        if (multiline) {\n                            result.push(indent);\n                        }\n                        if (i + 1 === len) {\n                            result.push(',');\n                        }\n                    } else {\n                        result.push(multiline ? indent : '', generateExpression(expr.elements[i], {\n                            precedence: Precedence.Assignment,\n                            allowIn: true,\n                            allowCall: true\n                        }));\n                    }\n                    if (i + 1 < len) {\n                        result.push(',' + (multiline ? newline : space));\n                    }\n                }\n            });\n            if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : '', ']');\n            break;\n\n        case Syntax.Property:\n            if (expr.kind === 'get' || expr.kind === 'set') {\n                result = [\n                    expr.kind + ' ',\n                    generateExpression(expr.key, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    }),\n                    generateFunctionBody(expr.value)\n                ];\n            } else {\n                if (expr.shorthand) {\n                    result = generateExpression(expr.key, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    });\n                } else if (expr.method) {\n                    result = [];\n                    if (expr.value.generator) {\n                        result.push('*');\n                    }\n                    result.push(generateExpression(expr.key, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    }), generateFunctionBody(expr.value));\n                } else {\n                    result = [\n                        generateExpression(expr.key, {\n                            precedence: Precedence.Sequence,\n                            allowIn: true,\n                            allowCall: true\n                        }),\n                        ':' + space,\n                        generateExpression(expr.value, {\n                            precedence: Precedence.Assignment,\n                            allowIn: true,\n                            allowCall: true\n                        })\n                    ];\n                }\n            }\n            break;\n\n        case Syntax.ObjectExpression:\n            if (!expr.properties.length) {\n                result = '{}';\n                break;\n            }\n            multiline = expr.properties.length > 1;\n\n            withIndent(function (indent) {\n                fragment = generateExpression(expr.properties[0], {\n                    precedence: Precedence.Sequence,\n                    allowIn: true,\n                    allowCall: true,\n                    type: Syntax.Property\n                });\n            });\n\n            if (!multiline) {\n                // issues 4\n                // Do not transform from\n                //   dejavu.Class.declare({\n                //       method2: function () {}\n                //   });\n                // to\n                //   dejavu.Class.declare({method2: function () {\n                //       }});\n                if (!hasLineTerminator(toSourceNode(fragment).toString())) {\n                    result = [ '{', space, fragment, space, '}' ];\n                    break;\n                }\n            }\n\n            withIndent(function (indent) {\n                result = [ '{', newline, indent, fragment ];\n\n                if (multiline) {\n                    result.push(',' + newline);\n                    for (i = 1, len = expr.properties.length; i < len; i += 1) {\n                        result.push(indent, generateExpression(expr.properties[i], {\n                            precedence: Precedence.Sequence,\n                            allowIn: true,\n                            allowCall: true,\n                            type: Syntax.Property\n                        }));\n                        if (i + 1 < len) {\n                            result.push(',' + newline);\n                        }\n                    }\n                }\n            });\n\n            if (!endsWithLineTerminator(toSourceNode(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base, '}');\n            break;\n\n        case Syntax.ObjectPattern:\n            if (!expr.properties.length) {\n                result = '{}';\n                break;\n            }\n\n            multiline = false;\n            if (expr.properties.length === 1) {\n                property = expr.properties[0];\n                if (property.value.type !== Syntax.Identifier) {\n                    multiline = true;\n                }\n            } else {\n                for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                    property = expr.properties[i];\n                    if (!property.shorthand) {\n                        multiline = true;\n                        break;\n                    }\n                }\n            }\n            result = ['{', multiline ? newline : '' ];\n\n            withIndent(function (indent) {\n                for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                    result.push(multiline ? indent : '', generateExpression(expr.properties[i], {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    }));\n                    if (i + 1 < len) {\n                        result.push(',' + (multiline ? newline : space));\n                    }\n                }\n            });\n\n            if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : '', '}');\n            break;\n\n        case Syntax.ThisExpression:\n            result = 'this';\n            break;\n\n        case Syntax.Identifier:\n            result = expr.name;\n            break;\n\n        case Syntax.Literal:\n            if (expr.hasOwnProperty('raw') && parse) {\n                try {\n                    raw = parse(expr.raw).body[0].expression;\n                    if (raw.type === Syntax.Literal) {\n                        if (raw.value === expr.value) {\n                            result = expr.raw;\n                            break;\n                        }\n                    }\n                } catch (e) {\n                    // not use raw property\n                }\n            }\n\n            if (expr.value === null) {\n                result = 'null';\n                break;\n            }\n\n            if (typeof expr.value === 'string') {\n                result = escapeString(expr.value);\n                break;\n            }\n\n            if (typeof expr.value === 'number') {\n                result = generateNumber(expr.value);\n                break;\n            }\n\n            if (typeof expr.value === 'boolean') {\n                result = expr.value ? 'true' : 'false';\n                break;\n            }\n\n            result = generateRegExp(expr.value);\n            break;\n\n        case Syntax.ComprehensionExpression:\n            result = [\n                '[',\n                generateExpression(expr.body, {\n                    precedence: Precedence.Assignment,\n                    allowIn: true,\n                    allowCall: true\n                })\n            ];\n\n            if (expr.blocks) {\n                for (i = 0, len = expr.blocks.length; i < len; i += 1) {\n                    fragment = generateExpression(expr.blocks[i], {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    });\n                    result = join(result, fragment);\n                }\n            }\n\n            if (expr.filter) {\n                result = join(result, 'if' + space);\n                fragment = generateExpression(expr.filter, {\n                    precedence: Precedence.Sequence,\n                    allowIn: true,\n                    allowCall: true\n                });\n                if (extra.moz.parenthesizedComprehensionBlock) {\n                    result = join(result, [ '(', fragment, ')' ]);\n                } else {\n                    result = join(result, fragment);\n                }\n            }\n            result.push(']');\n            break;\n\n        case Syntax.ComprehensionBlock:\n            if (expr.left.type === Syntax.VariableDeclaration) {\n                fragment = [\n                    expr.left.kind + ' ',\n                    generateStatement(expr.left.declarations[0], {\n                        allowIn: false\n                    })\n                ];\n            } else {\n                fragment = generateExpression(expr.left, {\n                    precedence: Precedence.Call,\n                    allowIn: true,\n                    allowCall: true\n                });\n            }\n\n            fragment = join(fragment, expr.of ? 'of' : 'in');\n            fragment = join(fragment, generateExpression(expr.right, {\n                precedence: Precedence.Sequence,\n                allowIn: true,\n                allowCall: true\n            }));\n\n            if (extra.moz.parenthesizedComprehensionBlock) {\n                result = [ 'for' + space + '(', fragment, ')' ];\n            } else {\n                result = join('for' + space, fragment);\n            }\n            break;\n\n        default:\n            throw new Error('Unknown expression type: ' + expr.type);\n        }\n\n        return toSourceNode(result, expr);\n    }\n\n    function generateStatement(stmt, option) {\n        var i, len, result, node, allowIn, functionBody, directiveContext, fragment, semicolon;\n\n        allowIn = true;\n        semicolon = ';';\n        functionBody = false;\n        directiveContext = false;\n        if (option) {\n            allowIn = option.allowIn === undefined || option.allowIn;\n            if (!semicolons && option.semicolonOptional === true) {\n                semicolon = '';\n            }\n            functionBody = option.functionBody;\n            directiveContext = option.directiveContext;\n        }\n\n        switch (stmt.type) {\n        case Syntax.BlockStatement:\n            result = ['{', newline];\n\n            withIndent(function () {\n                for (i = 0, len = stmt.body.length; i < len; i += 1) {\n                    fragment = addIndent(generateStatement(stmt.body[i], {\n                        semicolonOptional: i === len - 1,\n                        directiveContext: functionBody\n                    }));\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            });\n\n            result.push(addIndent('}'));\n            break;\n\n        case Syntax.BreakStatement:\n            if (stmt.label) {\n                result = 'break ' + stmt.label.name + semicolon;\n            } else {\n                result = 'break' + semicolon;\n            }\n            break;\n\n        case Syntax.ContinueStatement:\n            if (stmt.label) {\n                result = 'continue ' + stmt.label.name + semicolon;\n            } else {\n                result = 'continue' + semicolon;\n            }\n            break;\n\n        case Syntax.DirectiveStatement:\n            if (stmt.raw) {\n                result = stmt.raw + semicolon;\n            } else {\n                result = escapeDirective(stmt.directive) + semicolon;\n            }\n            break;\n\n        case Syntax.DoWhileStatement:\n            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n            result = join('do', maybeBlock(stmt.body));\n            result = maybeBlockSuffix(stmt.body, result);\n            result = join(result, [\n                'while' + space + '(',\n                generateExpression(stmt.test, {\n                    precedence: Precedence.Sequence,\n                    allowIn: true,\n                    allowCall: true\n                }),\n                ')' + semicolon\n            ]);\n            break;\n\n        case Syntax.CatchClause:\n            withIndent(function () {\n                result = [\n                    'catch' + space + '(',\n                    generateExpression(stmt.param, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    }),\n                    ')'\n                ];\n            });\n            result.push(maybeBlock(stmt.body));\n            break;\n\n        case Syntax.DebuggerStatement:\n            result = 'debugger' + semicolon;\n            break;\n\n        case Syntax.EmptyStatement:\n            result = ';';\n            break;\n\n        case Syntax.ExpressionStatement:\n            result = [generateExpression(stmt.expression, {\n                precedence: Precedence.Sequence,\n                allowIn: true,\n                allowCall: true\n            })];\n            // 12.4 '{', 'function' is not allowed in this position.\n            // wrap expression with parentheses\n            if (result.toString().charAt(0) === '{' || (result.toString().slice(0, 8) === 'function' && \" (\".indexOf(result.toString().charAt(8)) >= 0) || (directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {\n                result = ['(', result, ')' + semicolon];\n            } else {\n                result.push(semicolon);\n            }\n            break;\n\n        case Syntax.VariableDeclarator:\n            if (stmt.init) {\n                result = [\n                    generateExpression(stmt.id, {\n                        precedence: Precedence.Assignment,\n                        allowIn: allowIn,\n                        allowCall: true\n                    }) + space + '=' + space,\n                    generateExpression(stmt.init, {\n                        precedence: Precedence.Assignment,\n                        allowIn: allowIn,\n                        allowCall: true\n                    })\n                ];\n            } else {\n                result = stmt.id.name;\n            }\n            break;\n\n        case Syntax.VariableDeclaration:\n            result = [stmt.kind];\n            // special path for\n            // var x = function () {\n            // };\n            if (stmt.declarations.length === 1 && stmt.declarations[0].init &&\n                    stmt.declarations[0].init.type === Syntax.FunctionExpression) {\n                result.push(' ', generateStatement(stmt.declarations[0], {\n                    allowIn: allowIn\n                }));\n            } else {\n                // VariableDeclarator is typed as Statement,\n                // but joined with comma (not LineTerminator).\n                // So if comment is attached to target node, we should specialize.\n                withIndent(function () {\n                    node = stmt.declarations[0];\n                    if (extra.comment && node.leadingComments) {\n                        result.push('\\n', addIndent(generateStatement(node, {\n                            allowIn: allowIn\n                        })));\n                    } else {\n                        result.push(' ', generateStatement(node, {\n                            allowIn: allowIn\n                        }));\n                    }\n\n                    for (i = 1, len = stmt.declarations.length; i < len; i += 1) {\n                        node = stmt.declarations[i];\n                        if (extra.comment && node.leadingComments) {\n                            result.push(',' + newline, addIndent(generateStatement(node, {\n                                allowIn: allowIn\n                            })));\n                        } else {\n                            result.push(',' + space, generateStatement(node, {\n                                allowIn: allowIn\n                            }));\n                        }\n                    }\n                });\n            }\n            result.push(semicolon);\n            break;\n\n        case Syntax.ThrowStatement:\n            result = [join(\n                'throw',\n                generateExpression(stmt.argument, {\n                    precedence: Precedence.Sequence,\n                    allowIn: true,\n                    allowCall: true\n                })\n            ), semicolon];\n            break;\n\n        case Syntax.TryStatement:\n            result = ['try', maybeBlock(stmt.block)];\n            result = maybeBlockSuffix(stmt.block, result);\n            for (i = 0, len = stmt.handlers.length; i < len; i += 1) {\n                result = join(result, generateStatement(stmt.handlers[i]));\n                if (stmt.finalizer || i + 1 !== len) {\n                    result = maybeBlockSuffix(stmt.handlers[i].body, result);\n                }\n            }\n            if (stmt.finalizer) {\n                result = join(result, ['finally', maybeBlock(stmt.finalizer)]);\n            }\n            break;\n\n        case Syntax.SwitchStatement:\n            withIndent(function () {\n                result = [\n                    'switch' + space + '(',\n                    generateExpression(stmt.discriminant, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    }),\n                    ')' + space + '{' + newline\n                ];\n            });\n            if (stmt.cases) {\n                for (i = 0, len = stmt.cases.length; i < len; i += 1) {\n                    fragment = addIndent(generateStatement(stmt.cases[i], {semicolonOptional: i === len - 1}));\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            }\n            result.push(addIndent('}'));\n            break;\n\n        case Syntax.SwitchCase:\n            withIndent(function () {\n                if (stmt.test) {\n                    result = [\n                        join('case', generateExpression(stmt.test, {\n                            precedence: Precedence.Sequence,\n                            allowIn: true,\n                            allowCall: true\n                        })),\n                        ':'\n                    ];\n                } else {\n                    result = ['default:'];\n                }\n\n                i = 0;\n                len = stmt.consequent.length;\n                if (len && stmt.consequent[0].type === Syntax.BlockStatement) {\n                    fragment = maybeBlock(stmt.consequent[0]);\n                    result.push(fragment);\n                    i = 1;\n                }\n\n                if (i !== len && !endsWithLineTerminator(toSourceNode(result).toString())) {\n                    result.push(newline);\n                }\n\n                for (; i < len; i += 1) {\n                    fragment = addIndent(generateStatement(stmt.consequent[i], {semicolonOptional: i === len - 1 && semicolon === ''}));\n                    result.push(fragment);\n                    if (i + 1 !== len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            });\n            break;\n\n        case Syntax.IfStatement:\n            withIndent(function () {\n                result = [\n                    'if' + space + '(',\n                    generateExpression(stmt.test, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    }),\n                    ')'\n                ];\n            });\n            if (stmt.alternate) {\n                result.push(maybeBlock(stmt.consequent));\n                result = maybeBlockSuffix(stmt.consequent, result);\n                if (stmt.alternate.type === Syntax.IfStatement) {\n                    result = join(result, ['else ', generateStatement(stmt.alternate, {semicolonOptional: semicolon === ''})]);\n                } else {\n                    result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));\n                }\n            } else {\n                result.push(maybeBlock(stmt.consequent, semicolon === ''));\n            }\n            break;\n\n        case Syntax.ForStatement:\n            withIndent(function () {\n                result = ['for' + space + '('];\n                if (stmt.init) {\n                    if (stmt.init.type === Syntax.VariableDeclaration) {\n                        result.push(generateStatement(stmt.init, {allowIn: false}));\n                    } else {\n                        result.push(generateExpression(stmt.init, {\n                            precedence: Precedence.Sequence,\n                            allowIn: false,\n                            allowCall: true\n                        }), ';');\n                    }\n                } else {\n                    result.push(';');\n                }\n\n                if (stmt.test) {\n                    result.push(space, generateExpression(stmt.test, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    }), ';');\n                } else {\n                    result.push(';');\n                }\n\n                if (stmt.update) {\n                    result.push(space, generateExpression(stmt.update, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    }), ')');\n                } else {\n                    result.push(')');\n                }\n            });\n\n            result.push(maybeBlock(stmt.body, semicolon === ''));\n            break;\n\n        case Syntax.ForInStatement:\n            result = ['for' + space + '('];\n            withIndent(function () {\n                if (stmt.left.type === Syntax.VariableDeclaration) {\n                    withIndent(function () {\n                        result.push(stmt.left.kind + ' ', generateStatement(stmt.left.declarations[0], {\n                            allowIn: false\n                        }));\n                    });\n                } else {\n                    result.push(generateExpression(stmt.left, {\n                        precedence: Precedence.Call,\n                        allowIn: true,\n                        allowCall: true\n                    }));\n                }\n\n                result = join(result, 'in');\n                result = [join(\n                    result,\n                    generateExpression(stmt.right, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    })\n                ), ')'];\n            });\n            result.push(maybeBlock(stmt.body, semicolon === ''));\n            break;\n\n        case Syntax.LabeledStatement:\n            result = [stmt.label.name + ':', maybeBlock(stmt.body, semicolon === '')];\n            break;\n\n        case Syntax.Program:\n            len = stmt.body.length;\n            result = [safeConcatenation && len > 0 ? '\\n' : ''];\n            for (i = 0; i < len; i += 1) {\n                fragment = addIndent(\n                    generateStatement(stmt.body[i], {\n                        semicolonOptional: !safeConcatenation && i === len - 1,\n                        directiveContext: true\n                    })\n                );\n                result.push(fragment);\n                if (i + 1 < len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {\n                    result.push(newline);\n                }\n            }\n            break;\n\n        case Syntax.FunctionDeclaration:\n            result = [(stmt.generator && !extra.moz.starlessGenerator ? 'function* ' : 'function ') + stmt.id.name, generateFunctionBody(stmt)];\n            break;\n\n        case Syntax.ReturnStatement:\n            if (stmt.argument) {\n                result = [join(\n                    'return',\n                    generateExpression(stmt.argument, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    })\n                ), semicolon];\n            } else {\n                result = ['return' + semicolon];\n            }\n            break;\n\n        case Syntax.WhileStatement:\n            withIndent(function () {\n                result = [\n                    'while' + space + '(',\n                    generateExpression(stmt.test, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    }),\n                    ')'\n                ];\n            });\n            result.push(maybeBlock(stmt.body, semicolon === ''));\n            break;\n\n        case Syntax.WithStatement:\n            withIndent(function () {\n                result = [\n                    'with' + space + '(',\n                    generateExpression(stmt.object, {\n                        precedence: Precedence.Sequence,\n                        allowIn: true,\n                        allowCall: true\n                    }),\n                    ')'\n                ];\n            });\n            result.push(maybeBlock(stmt.body, semicolon === ''));\n            break;\n\n        default:\n            throw new Error('Unknown statement type: ' + stmt.type);\n        }\n\n        // Attach comments\n\n        if (extra.comment) {\n            result = addCommentsToStatement(stmt, result);\n        }\n\n        fragment = toSourceNode(result).toString();\n        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\\n') {\n            result = toSourceNode(result).replaceRight(/\\s+$/, '');\n        }\n\n        return toSourceNode(result, stmt);\n    }\n\n    function generate(node, options) {\n        var defaultOptions = getDefaultOptions(), result, pair;\n\n        if (options != null) {\n            // Obsolete options\n            //\n            //   `options.indent`\n            //   `options.base`\n            //\n            // Instead of them, we can use `option.format.indent`.\n            if (typeof options.indent === 'string') {\n                defaultOptions.format.indent.style = options.indent;\n            }\n            if (typeof options.base === 'number') {\n                defaultOptions.format.indent.base = options.base;\n            }\n            options = updateDeeply(defaultOptions, options);\n            indent = options.format.indent.style;\n            if (typeof options.base === 'string') {\n                base = options.base;\n            } else {\n                base = stringRepeat(indent, options.format.indent.base);\n            }\n        } else {\n            options = defaultOptions;\n            indent = options.format.indent.style;\n            base = stringRepeat(indent, options.format.indent.base);\n        }\n        json = options.format.json;\n        renumber = options.format.renumber;\n        hexadecimal = json ? false : options.format.hexadecimal;\n        quotes = json ? 'double' : options.format.quotes;\n        escapeless = options.format.escapeless;\n        if (options.format.compact) {\n            newline = space = indent = base = '';\n        } else {\n            newline = '\\n';\n            space = ' ';\n        }\n        parentheses = options.format.parentheses;\n        semicolons = options.format.semicolons;\n        safeConcatenation = options.format.safeConcatenation;\n        directive = options.directive;\n        parse = json ? null : options.parse;\n        sourceMap = options.sourceMap;\n        extra = options;\n\n        if (sourceMap) {\n            if (!exports.browser) {\n                // We assume environment is node.js\n                // And prevent from including source-map by browserify\n                SourceNode = require('source-map').SourceNode;\n            } else {\n                SourceNode = global.sourceMap.SourceNode;\n            }\n        } else {\n            SourceNode = SourceNodeMock;\n        }\n\n        switch (node.type) {\n        case Syntax.BlockStatement:\n        case Syntax.BreakStatement:\n        case Syntax.CatchClause:\n        case Syntax.ContinueStatement:\n        case Syntax.DirectiveStatement:\n        case Syntax.DoWhileStatement:\n        case Syntax.DebuggerStatement:\n        case Syntax.EmptyStatement:\n        case Syntax.ExpressionStatement:\n        case Syntax.ForStatement:\n        case Syntax.ForInStatement:\n        case Syntax.FunctionDeclaration:\n        case Syntax.IfStatement:\n        case Syntax.LabeledStatement:\n        case Syntax.Program:\n        case Syntax.ReturnStatement:\n        case Syntax.SwitchStatement:\n        case Syntax.SwitchCase:\n        case Syntax.ThrowStatement:\n        case Syntax.TryStatement:\n        case Syntax.VariableDeclaration:\n        case Syntax.VariableDeclarator:\n        case Syntax.WhileStatement:\n        case Syntax.WithStatement:\n            result = generateStatement(node);\n            break;\n\n        case Syntax.AssignmentExpression:\n        case Syntax.ArrayExpression:\n        case Syntax.ArrayPattern:\n        case Syntax.BinaryExpression:\n        case Syntax.CallExpression:\n        case Syntax.ConditionalExpression:\n        case Syntax.FunctionExpression:\n        case Syntax.Identifier:\n        case Syntax.Literal:\n        case Syntax.LogicalExpression:\n        case Syntax.MemberExpression:\n        case Syntax.NewExpression:\n        case Syntax.ObjectExpression:\n        case Syntax.ObjectPattern:\n        case Syntax.Property:\n        case Syntax.SequenceExpression:\n        case Syntax.ThisExpression:\n        case Syntax.UnaryExpression:\n        case Syntax.UpdateExpression:\n        case Syntax.YieldExpression:\n\n            result = generateExpression(node, {\n                precedence: Precedence.Sequence,\n                allowIn: true,\n                allowCall: true\n            });\n            break;\n\n        default:\n            throw new Error('Unknown node type: ' + node.type);\n        }\n\n        if (!sourceMap) {\n            return result.toString();\n        }\n\n        pair = result.toStringWithSourceMap({\n            file: options.sourceMap,\n            sourceRoot: options.sourceMapRoot\n        });\n\n        if (options.sourceMapWithCode) {\n            return pair;\n        }\n        return pair.map.toString();\n    }\n\n    // simple visitor implementation\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        DebuggerStatement: [],\n        EmptyStatement: [],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handlers', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    VisitorOption = {\n        Break: 1,\n        Skip: 2\n    };\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    function lowerBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                i = current + 1;\n                len -= diff + 1;\n            } else {\n                len = diff;\n            }\n        }\n        return i;\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target, token;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            if (target < tokens.length) {\n                comment.extendedRange[0] = tokens[target].range[1];\n            } else if (token.length) {\n                comment.extendedRange[1] = tokens[tokens.length - 1].range[0];\n            }\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        traverse(tree, {\n            cursor: 0,\n            enter: function (node) {\n                var comment;\n\n                while (this.cursor < comments.length) {\n                    comment = comments[this.cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(this.cursor, 1);\n                    } else {\n                        this.cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (this.cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[this.cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        traverse(tree, {\n            cursor: 0,\n            leave: function (node) {\n                var comment;\n\n                while (this.cursor < comments.length) {\n                    comment = comments[this.cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(this.cursor, 1);\n                    } else {\n                        this.cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (this.cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[this.cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.version = require('./package.json').version;\n    exports.generate = generate;\n    exports.attachComments = attachComments;\n    exports.browser = false;\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n"]},"metadata":{},"sourceType":"script"}